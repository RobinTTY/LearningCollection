<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.4">
<title data-react-helmet="true">gRPC | Learning Collection Knowledge Base</title><meta data-react-helmet="true" property="og:url" content="https://RobinTTY.github.io/LearningCollection/General Concepts/grpc"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="gRPC | Learning Collection Knowledge Base"><meta data-react-helmet="true" name="description" content="Resource:"><meta data-react-helmet="true" property="og:description" content="Resource:"><link data-react-helmet="true" rel="shortcut icon" href="/LearningCollection/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://RobinTTY.github.io/LearningCollection/General Concepts/grpc"><link data-react-helmet="true" rel="alternate" href="https://RobinTTY.github.io/LearningCollection/General Concepts/grpc" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://RobinTTY.github.io/LearningCollection/General Concepts/grpc" hreflang="x-default"><link rel="stylesheet" href="/LearningCollection/assets/css/styles.bd168e87.css">
<link rel="preload" href="/LearningCollection/assets/js/runtime~main.f1e526fc.js" as="script">
<link rel="preload" href="/LearningCollection/assets/js/main.a5aa482e.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/LearningCollection/"><img src="/LearningCollection/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/LearningCollection/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">Learning Collection</b></a><a class="navbar__item navbar__link navbar__link--active" href="/LearningCollection/">Docs</a></div><div class="navbar__items navbar__items--right"><div class="react-toggle toggle_3Zt9 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">ðŸŒœ</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">ðŸŒž</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><button class="clean-btn backToTopButton_35hR" type="button" title="Scroll to top"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA"><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">C-Sharp</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Databases</a></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">General Concepts</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/LearningCollection/General Concepts/callStack">Call Stack</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/LearningCollection/General Concepts/certificates">Certificates</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/LearningCollection/General Concepts/dependencyInjection">Dependency Injection</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/LearningCollection/General Concepts/dlls">Dynamic Link Library (DLL)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/LearningCollection/General Concepts/rpc">Remote Procedure Call (RPC)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/LearningCollection/General Concepts/semaphoreVsMutex">Semaphore vs Mutex</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/LearningCollection/General Concepts/stackVsHeap">Stack vs Heap</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/LearningCollection/General Concepts/grpc">gRPC</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Tools</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Web</a></li><li class="menu__list-item"><a class="menu__link" href="/LearningCollection/">Introduction</a></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="tocCollapsible_1PrD tocMobile_3Hoh"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">On this page</button></div><div class="markdown"><header><h1 class="h1Heading_27L5">gRPC</h1></header><p>Resource: <a href="https://www.grpc.io/docs/guides/" target="_blank" rel="noopener noreferrer">https://www.grpc.io/docs/guides/</a></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="overview"></a>Overview<a class="hash-link" href="#overview" title="Direct link to heading">#</a></h2><p>In gRPC a <strong>client application can directly call methods on a server application on a different machine as if it was a local object</strong>,
making it easier for you to create distributed applications and services. As in many RPC systems, <strong>gRPC is based around the idea of
defining a service, specifying the methods that can be called remotely with their parameters and return types</strong>. On the server side,
the server implements this interface and runs a gRPC server to handle client calls. On the client side, the client has a stub
(referred to as just a client in some languages) that provides the same methods as the server.</p><p><img alt="grpcOverview" src="/LearningCollection/assets/images/grpcOverview-e887f42e3afb2833fd6a0887eb79bf5b.PNG"></p><p>gRPC clients and servers can run and talk to each other in a variety of environments - from servers inside Google to your own
desktop - and can be written in any of gRPCâ€™s supported languages. So, for example, you can easily create a gRPC server in Java with
clients in Go, Python, or Ruby. <strong>In addition, the latest Google APIs will have gRPC versions of their interfaces, letting you easily
build Google functionality into your applications</strong>.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="what-is-a-protocol-buffer"></a>What is a protocol buffer<a class="hash-link" href="#what-is-a-protocol-buffer" title="Direct link to heading">#</a></h2><p>Resource: <a href="https://developers.google.com/protocol-buffers/docs/overview" target="_blank" rel="noopener noreferrer">https://developers.google.com/protocol-buffers/docs/overview</a></p><p>Protocol buffers are a flexible, efficient, automated mechanism for serializing structured data â€“ think XML, but smaller, faster, and simpler.
You define how you want your data to be structured once, then you can use special generated source code to easily write and read your structured
data to and from a variety of data streams and using a variety of languages. You can even update your data structure without breaking deployed
programs that are compiled against the &quot;old&quot; format.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="how-do-they-work"></a>How do they work<a class="hash-link" href="#how-do-they-work" title="Direct link to heading">#</a></h3><p>You specify how you want the information you&#x27;re serializing to be structured by defining protocol buffer message types in .proto files.
Each protocol buffer message is a small logical record of information, containing a series of name-value pairs. Here&#x27;s a very basic example of a
.proto file that defines a message containing information about a person:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly proto"><pre tabindex="0" class="prism-code language-proto codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">message Person {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  required string name = 1;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  required int32 id = 2;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  optional string email = 3;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  enum PhoneType {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    MOBILE = 0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    HOME = 1;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    WORK = 2;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  message PhoneNumber {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    required string number = 1;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    optional PhoneType type = 2 [default = HOME];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  repeated PhoneNumber phone = 4;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>Each message type has one or more uniquely numbered fields, and each field has a name and a value type, where value types can be numbers
(integer or floating-point), booleans, strings, raw bytes, or even (as in the example above) other protocol buffer message types, allowing you
to structure your data hierarchically. You can specify optional fields, required fields, and repeated fields. You can find more information about
writing .proto files in the <a href="https://developers.google.com/protocol-buffers/docs/proto" target="_blank" rel="noopener noreferrer">Protocol Buffer Language Guide</a>.</p><p><strong>Once you&#x27;ve defined your messages, you run the protocol buffer compiler for your application&#x27;s language on your .proto file to generate data
access classes.</strong> These provide simple accessors for each field (like name() and set_name()) as well as methods to serialize/parse the whole
structure to/from raw bytes â€“ so, for instance, if your chosen language is C++, running the compiler on the above example will generate a class
called Person. You can then use this class in your application to populate, serialize, and retrieve Person protocol buffer messages. You might
then write some code like this:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly C++"><pre tabindex="0" class="prism-code language-C++ codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Person person;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">person.set_name(&quot;John Doe&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">person.set_id(1234);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">person.set_email(&quot;jdoe@example.com&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">fstream output(&quot;myfile&quot;, ios::out | ios::binary);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">person.SerializeToOstream(&amp;output);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>Then, later on, you could read your message back in:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly C++"><pre tabindex="0" class="prism-code language-C++ codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">fstream input(&quot;myfile&quot;, ios::in | ios::binary);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Person person;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">person.ParseFromIstream(&amp;input);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">cout &lt;&lt; &quot;Name: &quot; &lt;&lt; person.name() &lt;&lt; endl;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">cout &lt;&lt; &quot;E-mail: &quot; &lt;&lt; person.email() &lt;&lt; endl;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>You can add new fields to your message formats without breaking backwards-compatibility; old binaries simply ignore the new field when parsing. So
if you have a communications protocol that uses protocol buffers as its data format, you can extend your protocol without having to worry about
breaking existing code.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="why-not-just-use-xml"></a>Why not just use XML<a class="hash-link" href="#why-not-just-use-xml" title="Direct link to heading">#</a></h3><p>Protocol buffers have many advantages over XML for serializing structured data. Protocol buffers:</p><ul><li>are simpler</li><li>are 3 to 10 times smaller</li><li>are 20 to 100 times faster</li><li>are less ambiguous</li><li>generate data access classes that are easier to use programmatically</li></ul><p>For example, let&#x27;s say you want to model a person with a name and an email. In XML, you need to do:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly XML"><pre tabindex="0" class="prism-code language-XML codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;person&gt;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  &lt;name&gt;John Doe&lt;/name&gt;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  &lt;email&gt;jdoe@example.com&lt;/email&gt;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;/person</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>while the corresponding protocol buffer message (in protocol buffer text format) is:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly XML"><pre tabindex="0" class="prism-code language-XML codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain"># Textual representation of a protocol buffer.</span></span><span class="token-line" style="color:#393A34"><span class="token plain"># This is *not* the binary format used on the wire.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">person {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  name: &quot;John Doe&quot;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  email: &quot;jdoe@example.com&quot;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>When this message is encoded to the protocol buffer binary format (the text format above is just a convenient human-readable representation for
debugging and editing), it would probably be 28 bytes long and take around 100-200 nanoseconds to parse. The XML version is at least 69 bytes if
you remove whitespace, and would take around 5,000-10,000 nanoseconds to parse.</p><p>Also, manipulating a protocol buffer is much easier:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly C++"><pre tabindex="0" class="prism-code language-C++ codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">cout &lt;&lt; &quot;Name: &quot; &lt;&lt; person.name() &lt;&lt; endl;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">cout &lt;&lt; &quot;E-mail: &quot; &lt;&lt; person.email() &lt;&lt; endl;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>Whereas with XML you would have to do something like:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly C++"><pre tabindex="0" class="prism-code language-C++ codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">cout &lt;&lt; &quot;Name: &quot;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   &lt;&lt; person.getElementsByTagName(&quot;name&quot;)-&gt;item(0)-&gt;innerText()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   &lt;&lt; endl;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">cout &lt;&lt; &quot;E-mail: &quot;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   &lt;&lt; person.getElementsByTagName(&quot;email&quot;)-&gt;item(0)-&gt;innerText()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   &lt;&lt; endl;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>However, protocol buffers are not always a better solution than XML â€“ for instance, protocol buffers would not be a good way to model a text-based
document with markup (e.g. HTML), since you cannot easily interleave structure with text. n addition, XML is human-readable and human-editable;
protocol buffers, at least in their native format, are not. XML is also â€“ to some extent â€“ self-describing. A protocol buffer is only meaningful if
you have the message definition (the .proto file).</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="why-the-name-protocol-buffers"></a>Why the name &quot;Protocol Buffers&quot;<a class="hash-link" href="#why-the-name-protocol-buffers" title="Direct link to heading">#</a></h2><p>Resource: <a href="https://developers.google.com/protocol-buffers/docs/faq" target="_blank" rel="noopener noreferrer">grpc.io/protocolBuffers</a></p><p>The name originates from the early days of the format, before we had the protocol buffer compiler to generate classes for us. At the time, there was a class called ProtocolBuffer which actually acted as a buffer for an individual method. Users would add tag/value pairs to this buffer individually by calling methods like AddValue(tag, value). The raw bytes were stored in a buffer which could then be written out once the message had been constructed.</p><p>Since that time, the &quot;buffers&quot; part of the name has lost its meaning, but it is still the name we use. Today, people usually use the term &quot;protocol message&quot; to refer to a message in an abstract sense, &quot;protocol buffer&quot; to refer to a serialized copy of a message, and &quot;protocol message object&quot; to refer to an in-memory object representing the parsed message.</p></div><footer class="row docusaurus-mt-lg"><div class="col"><a href="https://github.com/RobinTTY/LearningCollection/tree/master/website/docs/General Concepts/What is grpc.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_3DPF"></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/LearningCollection/General Concepts/stackVsHeap"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Â« Stack vs Heap</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/LearningCollection/Tools/antlr"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">ANTLR Â»</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#overview" class="table-of-contents__link">Overview</a></li><li><a href="#what-is-a-protocol-buffer" class="table-of-contents__link">What is a protocol buffer</a><ul><li><a href="#how-do-they-work" class="table-of-contents__link">How do they work</a></li><li><a href="#why-not-just-use-xml" class="table-of-contents__link">Why not just use XML</a></li></ul></li><li><a href="#why-the-name-protocol-buffers" class="table-of-contents__link">Why the name &quot;Protocol Buffers&quot;</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">My other sites</div><ul class="footer__items"><li class="footer__item"><a href="https://robintty.github.io/" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Website<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">Socials</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/RobinTTY" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://www.linkedin.com/in/robin-m%C3%BCller-574782170/" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>LinkedIn<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright Â© 2021 Robin MÃ¼ller. Built with Docusaurus.</div></div></div></footer></div>
<script src="/LearningCollection/assets/js/runtime~main.f1e526fc.js"></script>
<script src="/LearningCollection/assets/js/main.a5aa482e.js"></script>
</body>
</html>