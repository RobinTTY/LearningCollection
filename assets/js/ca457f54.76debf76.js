"use strict";(globalThis.webpackChunklearning_knowledge_base=globalThis.webpackChunklearning_knowledge_base||[]).push([[4074],{62426:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>i,contentTitle:()=>a,default:()=>p,frontMatter:()=>c,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"web/typescript/decorators/class-decorators","title":"Class Decorators","description":"A Class Decorator is declared just before a class declaration. The class decorator is applied to the constructor of the class and can be used to observe, modify, or replace a class definition. A class decorator cannot be used in a declaration file, or in any other ambient context (such as on a declare class).","source":"@site/docs/web/typescript/decorators/class-decorators.md","sourceDirName":"web/typescript/decorators","slug":"/web/typescript/decorators/class-decorators","permalink":"/LearningCollection/web/typescript/decorators/class-decorators","draft":false,"unlisted":false,"editUrl":"https://github.com/RobinTTY/LearningCollection/tree/master/website/docs/web/typescript/decorators/class-decorators.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"id":"class-decorators","title":"Class Decorators","sidebar_position":2},"sidebar":"docs","previous":{"title":"Introduction","permalink":"/LearningCollection/web/typescript/decorators/introduction"},"next":{"title":"Method Decorators","permalink":"/LearningCollection/web/typescript/decorators/method-decorators"}}');var s=o(74848),n=o(28453);const c={id:"class-decorators",title:"Class Decorators",sidebar_position:2},a=void 0,i={},l=[];function d(e){const t={code:"code",p:"p",pre:"pre",strong:"strong",...(0,n.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["A Class Decorator is declared just before a class declaration. The class decorator is applied to the constructor of the class and can be ",(0,s.jsx)(t.strong,{children:"used to observe, modify, or replace a class definition"}),". A class decorator cannot be used in a declaration file, or in any other ambient context (such as on a ",(0,s.jsx)(t.code,{children:"declare"})," class)."]}),"\n",(0,s.jsx)(t.p,{children:"The expression for the class decorator will be called as a function at runtime, with the constructor of the decorated class as its only argument. If the class decorator returns a value, it will replace the class declaration with the provided constructor function."}),"\n",(0,s.jsxs)(t.p,{children:["he following is an example of a class decorator (",(0,s.jsx)(t.code,{children:"@sealed"}),") applied to a ",(0,s.jsx)(t.code,{children:"BugReport"})," class:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:'@sealed\nclass BugReport {\n  type = "report";\n  title: string;\n\n  constructor(t: string) {\n    this.title = t;\n  }\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:["We can define the ",(0,s.jsx)(t.code,{children:"@sealed"})," decorator using the following function declaration:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"function sealed(constructor: Function) {\n  Object.seal(constructor);\n  Object.seal(constructor.prototype);\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["When ",(0,s.jsx)(t.code,{children:"@sealed"})," is executed, it will seal both the constructor and its prototype, and will therefore prevent any further functionality from being added to or removed from this class during runtime by accessing ",(0,s.jsx)(t.code,{children:"BugReport.prototype"})," or by defining properties on ",(0,s.jsx)(t.code,{children:"BugReport"})," itself (note that ES2015 classes are really just syntactic sugar to prototype-based constructor functions). This decorator does not prevent classes from sub-classing ",(0,s.jsx)(t.code,{children:"BugReport"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"Next we have an example of how to override the constructor to set new defaults:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:'function reportableClassDecorator<T extends { new (...args: any[]): {} }>(\n  constructor: T\n) {\n  return class extends constructor {\n    reportingURL = "http://www...";\n  };\n}\n\n@reportableClassDecorator\nclass BugReport {\n  type = "report";\n  title: string;\n\n  constructor(t: string) {\n    this.title = t;\n  }\n}\n\nconst bug = new BugReport("Needs dark mode");\nconsole.log(bug.title); // Prints "Needs dark mode"\nconsole.log(bug.type); // Prints "report"\n\n// Note that the decorator _does not_ change the TypeScript type\n// and so the new property `reportingURL` is not known\n// to the type system:\nbug.reportingURL; // Property \'reportingURL\' does not exist on type \'BugReport\'.\n'})})]})}function p(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,t,o)=>{o.d(t,{R:()=>c,x:()=>a});var r=o(96540);const s={},n=r.createContext(s);function c(e){const t=r.useContext(n);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),r.createElement(n.Provider,{value:t},e.children)}}}]);