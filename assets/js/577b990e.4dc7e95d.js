"use strict";(globalThis.webpackChunklearning_knowledge_base=globalThis.webpackChunklearning_knowledge_base||[]).push([[5643],{46533:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"kubernetes/network","title":"Network","description":"The Kubernetes network model is built out of several pieces:","source":"@site/docs/kubernetes/network.md","sourceDirName":"kubernetes","slug":"/kubernetes/network","permalink":"/LearningCollection/kubernetes/network","draft":false,"unlisted":false,"editUrl":"https://github.com/RobinTTY/LearningCollection/tree/master/website/docs/kubernetes/network.md","tags":[],"version":"current","frontMatter":{"id":"network","title":"Network"}}');var t=s(74848),i=s(28453);const l={id:"network",title:"Network"},o=void 0,c={},a=[{value:"CNI (Container Network Interface)",id:"cni-container-network-interface",level:2},{value:"Service Types",id:"service-types",level:2},{value:"DNS",id:"dns",level:2},{value:"Ingress",id:"ingress",level:2}];function d(e){const n={code:"code",h2:"h2",li:"li",p:"p",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"The Kubernetes network model is built out of several pieces:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Each pod in a cluster gets its own unique cluster-wide IP address"}),"\n",(0,t.jsxs)(n.li,{children:["The pod network (also called a cluster network) handles communication between pods. It ensures that (barring intentional network segmentation):","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"All pods can communicate with all other pods, whether they are on the same node or on different nodes. Pods can communicate with each other directly, without the use of proxies or address translation (NAT)."}),"\n",(0,t.jsx)(n.li,{children:"Agents on a node (such as system daemons, or kubelet) can communicate with all pods on that node."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"The Service API lets you provide a stable (long lived) IP address or hostname for a service implemented by one or more backend pods, where the individual pods making up the service can change over time."}),"\n",(0,t.jsx)(n.li,{children:"The Gateway API (or its predecessor, Ingress) allows you to make Services accessible to clients that are outside the cluster."}),"\n",(0,t.jsx)(n.li,{children:"NetworkPolicy is a built-in Kubernetes API that allows you to control traffic between pods, or between pods and the outside world."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"cni-container-network-interface",children:"CNI (Container Network Interface)"}),"\n",(0,t.jsx)(n.p,{children:"For cluster networking Kubernetes relies on the Container Network Interface (CNI) standard. Third party CNI plugins implement the actual networking functionality. Popular CNI plugins are:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Calico"}),"\n",(0,t.jsx)(n.li,{children:"Flannel"}),"\n",(0,t.jsx)(n.li,{children:"Cilium"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["To check which plugin is used in your cluster you can check via: ",(0,t.jsx)(n.code,{children:"ls /etc/cni/net.d/"})]}),"\n",(0,t.jsx)(n.h2,{id:"service-types",children:"Service Types"}),"\n",(0,t.jsx)(n.p,{children:"There are 3 different types that can be used to expose service inside or outside the cluster:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["ClusterIP (default)","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Exposes the service on a cluster-internal IP"}),"\n",(0,t.jsx)(n.li,{children:"Makes the service only reachable from within the cluster"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["NodePort","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Exposes the service on each Node's IP at a static port (the NodePort)"}),"\n",(0,t.jsx)(n.li,{children:"A ClusterIP service, to which the NodePort service routes, is automatically created"}),"\n",(0,t.jsxs)(n.li,{children:["Makes the service reachable from outside the cluster using ",(0,t.jsx)(n.code,{children:"<NodeIP>:<NodePort>"})]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["LoadBalancer","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Exposes the service externally using a cloud provider's load balancer"}),"\n",(0,t.jsx)(n.li,{children:"A NodePort and ClusterIP service, to which the external load balancer routes, are automatically created"}),"\n",(0,t.jsx)(n.li,{children:"Makes the service reachable from outside the cluster using the load balancer's IP address"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"kube-proxy is responsible for translating the services into usable network rules."}),"\n",(0,t.jsx)(n.h2,{id:"dns",children:"DNS"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Each service is automatically registered with the kube-dns (now CoreDNS) and has a CNAME record created like ",(0,t.jsx)(n.code,{children:"web-service.default.svc.cluster.local"})]}),"\n",(0,t.jsxs)(n.li,{children:["The same can be enabled for pods. They will get a CNAME like: ",(0,t.jsx)(n.code,{children:"pod-ip-address.namespace.pod.cluster.local"})]}),"\n",(0,t.jsx)(n.li,{children:"The CoreDNS service is registered as a pod in the cluster and is responsible for resolving IPs to hostnames and vice versa"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"ingress",children:"Ingress"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Ingress is an API object that manages external access to the services in a cluster, typically HTTP"}),"\n",(0,t.jsx)(n.li,{children:"Ingress can provide load balancing, SSL termination and name-based virtual hosting"}),"\n",(0,t.jsx)(n.li,{children:"Ingress was recently succeeded by Gateway API, which provides more flexibility and features"}),"\n",(0,t.jsxs)(n.li,{children:["An Ingress controller like nginx or traefik is required to implement the Ingress rules","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"the controller acts upon the ingress resources"}),"\n",(0,t.jsx)(n.li,{children:"the controller is deployed via a deployment exposed through a service, has its config in a ConfigMap and a ServiceAccount for Authorization"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"Routes can route traffic via different URL prefixes for instance"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>o});var r=s(96540);const t={},i=r.createContext(t);function l(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);