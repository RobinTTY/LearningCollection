"use strict";(self.webpackChunklearning_knowledge_base=self.webpackChunklearning_knowledge_base||[]).push([[2703],{47301:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"web/javascript/core-concepts/types","title":"Types","description":"JavaScript is a dynamic language with dynamic types. Variables in JavaScript are not directly associated with any particular value type, and any variable can be assigned (and re-assigned) values of all types:","source":"@site/docs/web/javascript/core-concepts/types.md","sourceDirName":"web/javascript/core-concepts","slug":"/web/javascript/core-concepts/types","permalink":"/LearningCollection/web/javascript/core-concepts/types","draft":false,"unlisted":false,"editUrl":"https://github.com/RobinTTY/LearningCollection/tree/master/website/docs/web/javascript/core-concepts/types.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"id":"types","title":"Types","sidebar_position":2},"sidebar":"docs","previous":{"title":"Variables and Constants","permalink":"/LearningCollection/web/javascript/core-concepts/variables-and-constants"},"next":{"title":"Arithmetic Operators","permalink":"/LearningCollection/web/javascript/core-concepts/arithmetic-operators"}}');var s=n(74848),a=n(28453);const r={id:"types",title:"Types",sidebar_position:2},o=void 0,l={},c=[{value:"JavaScript types",id:"javascript-types",level:2},{value:"Boolean type",id:"boolean-type",level:3},{value:"Null type",id:"null-type",level:3},{value:"Undefined type",id:"undefined-type",level:3},{value:"Number type",id:"number-type",level:3},{value:"BigInt type",id:"bigint-type",level:3},{value:"String type",id:"string-type",level:3},{value:"Symbol type",id:"symbol-type",level:3},{value:"<code>typeof</code> operator",id:"typeof-operator",level:2}];function d(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["JavaScript is a ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Dynamic_programming_language",children:"dynamic"})," language with ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Type_system#DYNAMIC",children:"dynamic types"}),". ",(0,s.jsx)(t.strong,{children:"Variables in JavaScript are not directly associated with any particular value type"}),", and any variable can be assigned (and re-assigned) values of all types:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'let foo = 42; // foo is now a number\nfoo = "bar"; // foo is now a string\nfoo = true; // foo is now a boolean\n'})}),"\n",(0,s.jsxs)(t.p,{children:["JavaScript is also a ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Strong_and_weak_typing",children:"weakly typed"})," language, which means it allows implicit type conversion when an operation involves mismatched types, instead of throwing type errors:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:'const foo = 42;\nconst result = foo + "1";\nconsole.log(result); // 421\n'})}),"\n",(0,s.jsx)(t.h2,{id:"javascript-types",children:"JavaScript types"}),"\n",(0,s.jsxs)(t.p,{children:["The set of types in the JavaScript language consists of ",(0,s.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#primitive_values",children:"primitive values"})," and ",(0,s.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#objects",children:"objects"}),":"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#primitive_values",children:"Primitive values"})," (immutable ",(0,s.jsx)(t.a,{href:"https://www.oxfordlearnersdictionaries.com/definition/english/datum",children:"datum"})," represented directly at the lowest level of the language)","\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"#boolean-type",children:"Boolean type"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"#null-type",children:"Null type"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"#undefined-type",children:"Undefined type"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"#number-type",children:"Number type"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"#bigint-type",children:"BigInt type"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"#string-type",children:"String type"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"#symbol-type",children:"Symbol type"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#objects",children:"Objects"})," (collections of properties)"]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:'All types except objects define immutable values (that is, values which can\'t be changed). For example, Strings are immutable. We refer to values of these types as "primitive values".'}),"\n",(0,s.jsx)(t.h3,{id:"boolean-type",children:"Boolean type"}),"\n",(0,s.jsxs)(t.p,{children:["Boolean represents a logical entity and can have two values: ",(0,s.jsx)(t.code,{children:"true"})," and ",(0,s.jsx)(t.code,{children:"false"}),"."]}),"\n",(0,s.jsx)(t.h3,{id:"null-type",children:"Null type"}),"\n",(0,s.jsxs)(t.p,{children:["The Null type has exactly one value: ",(0,s.jsx)(t.code,{children:"null"}),". It represents the intentional absence of any object value. ",(0,s.jsx)(t.code,{children:"null"})," expresses a lack of identification, indicating that a variable points to no object. In APIs, ",(0,s.jsx)(t.code,{children:"null"})," is often retrieved in a place where an object can be expected but no object is relevant."]}),"\n",(0,s.jsx)(t.h3,{id:"undefined-type",children:"Undefined type"}),"\n",(0,s.jsxs)(t.p,{children:["A variable that has not been assigned a value is of type ",(0,s.jsx)(t.code,{children:"undefined"}),". A method or statement also returns ",(0,s.jsx)(t.code,{children:"undefined"})," if the variable that is being evaluated does not have an assigned value. A function returns ",(0,s.jsx)(t.code,{children:"undefined"})," if a value was not returned."]}),"\n",(0,s.jsx)(t.h3,{id:"number-type",children:"Number type"}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"Number"})," type is a ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Double-precision_floating-point_format",children:"double-precision 64-bit binary format IEEE 754 value"}),". Although a number often represents only its value, JavaScript provides ",(0,s.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#bitwise_operators",children:"bitwise operators"}),"."]}),"\n",(0,s.jsx)(t.h3,{id:"bigint-type",children:"BigInt type"}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"BigInt"})," type is a numeric primitive in JavaScript that can represent integers with arbitrary precision. With BigInts, you can safely store and operate on large integers even beyond the safe integer limit for Numbers. BigInts cannot be operated on interchangeably with Numbers. Instead a TypeError will be thrown."]}),"\n",(0,s.jsx)(t.h3,{id:"string-type",children:"String type"}),"\n",(0,s.jsxs)(t.p,{children:["JavaScript's ",(0,s.jsx)(t.code,{children:"String"}),' type is used to represent textual data. It is a set of "elements" of 16-bit unsigned integer values. Each element in the String occupies a position in the String. The first element is at index 0, the next at index 1, and so on. JavaScript strings are immutable.']}),"\n",(0,s.jsx)(t.h3,{id:"symbol-type",children:"Symbol type"}),"\n",(0,s.jsxs)(t.p,{children:['A "symbol" represents a unique identifier. ',(0,s.jsx)(t.code,{children:"Symbol"})," is a built-in object whose constructor returns a symbol ",(0,s.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Glossary/Primitive",children:"primitive"})," \u2014 also called a Symbol value or just a Symbol \u2014 that's guaranteed to be unique."]}),"\n",(0,s.jsx)(t.p,{children:"Symbols are often used to add unique property keys to an object that won't collide with keys any other code might add to the object, and which are hidden from any mechanisms other code will typically use to access the object."}),"\n",(0,s.jsxs)(t.h2,{id:"typeof-operator",children:[(0,s.jsx)(t.code,{children:"typeof"})," operator"]}),"\n",(0,s.jsxs)(t.p,{children:["We can easily recognize the data type using the ",(0,s.jsx)(t.code,{children:"typeof"})," operator. There are two ways to write this operator:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"console.log(typeof(9)); // number\nconsole.log(typeof 9); // number\n"})})]})}function p(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>o});var i=n(96540);const s={},a=i.createContext(s);function r(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);