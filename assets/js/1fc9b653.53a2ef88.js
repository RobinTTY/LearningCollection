"use strict";(self.webpackChunklearning_knowledge_base=self.webpackChunklearning_knowledge_base||[]).push([[6886],{3905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>y});var n=a(7294);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var i=n.createContext({}),c=function(e){var t=n.useContext(i),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},d=function(e){var t=c(e.components);return n.createElement(i.Provider,{value:t},e.children)},p="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,r=e.originalType,i=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=c(a),u=o,y=p["".concat(i,".").concat(u)]||p[u]||h[u]||r;return a?n.createElement(y,l(l({ref:t},d),{},{components:a})):n.createElement(y,l({ref:t},d))}));function y(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=a.length,l=new Array(r);l[0]=u;var s={};for(var i in t)hasOwnProperty.call(t,i)&&(s[i]=t[i]);s.originalType=e,s[p]="string"==typeof e?e:o,l[1]=s;for(var c=2;c<r;c++)l[c]=a[c];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},4339:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>i,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var n=a(7462),o=(a(7294),a(3905));const r={id:"data-loaders",title:"Data Loaders",sidebar_position:6},l=void 0,s={unversionedId:"apis/graphql/hot-chocolate/data-loaders",id:"apis/graphql/hot-chocolate/data-loaders",title:"Data Loaders",description:"ataLoader is a generic utility to be used as part of the application's data fetching layer to provide a consistent API over various backends and reduce requests to those backends via batching and caching. It helps you to avoid the N+1 problem.",source:"@site/docs/apis/graphql/hot-chocolate/data-loaders.md",sourceDirName:"apis/graphql/hot-chocolate",slug:"/apis/graphql/hot-chocolate/data-loaders",permalink:"/LearningCollection/apis/graphql/hot-chocolate/data-loaders",draft:!1,editUrl:"https://github.com/RobinTTY/LearningCollection/tree/master/website/docs/apis/graphql/hot-chocolate/data-loaders.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{id:"data-loaders",title:"Data Loaders",sidebar_position:6},sidebar:"finance",previous:{title:"Resolvers",permalink:"/LearningCollection/apis/graphql/hot-chocolate/resolvers"},next:{title:"Important Annotations",permalink:"/LearningCollection/apis/graphql/hot-chocolate/important-annotations"}},i={},c=[{value:"Context: The N+1 Problem",id:"context-the-n1-problem",level:2},{value:"Example",id:"example",level:3},{value:"N+1 Problem in GraphQL",id:"n1-problem-in-graphql",level:3},{value:"HotChocolate Data Loaders",id:"hotchocolate-data-loaders",level:2},{value:"Execution",id:"execution",level:3},{value:"Data Consistency",id:"data-consistency",level:3}],d={toc:c},p="wrapper";function h(e){let{components:t,...a}=e;return(0,o.kt)(p,(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"ataLoader is a generic utility to be used as part of the application's data fetching layer to provide a consistent API over various backends and reduce requests to those backends via batching and caching. It helps you to avoid the N+1 problem."),(0,o.kt)("h2",{id:"context-the-n1-problem"},"Context: The N+1 Problem"),(0,o.kt)("p",null,"Every data fetching technology suffers the n+1 problem. Typically, it happens when you structure your code so that you first do a query to get a list of records, then subsequently do another query for each of those records."),(0,o.kt)("h3",{id:"example"},"Example"),(0,o.kt)("p",null,"Let's say we have a collection of ",(0,o.kt)("inlineCode",{parentName:"p"},"Car")," objects (database rows), and each ",(0,o.kt)("inlineCode",{parentName:"p"},"Car")," has a collection of ",(0,o.kt)("inlineCode",{parentName:"p"},"Wheel")," objects (also rows). In other words, ",(0,o.kt)("inlineCode",{parentName:"p"},"Car \u2192 Wheel")," is a 1-to-many relationship."),(0,o.kt)("p",null,"Now, let's say we need to iterate through all the cars, and for each one, print out a list of the wheels. The naive implementation would do the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM Cars;\n")),(0,o.kt)("p",null,"And then for each Car:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM Wheel WHERE CarId = ?\n")),(0,o.kt)("p",null,"In other words, you have one select for the Cars, and then N additional selects, where N is the total number of cars. Alternatively, one could get all wheels and perform the lookups in memory:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM Wheel;\n")),(0,o.kt)("p",null,"This reduces the number of round-trips to the database from N+1 to 2. Most ORM tools give you several ways to prevent N+1 selects."),(0,o.kt)("h3",{id:"n1-problem-in-graphql"},"N+1 Problem in GraphQL"),(0,o.kt)("p",null,"The difference between GraphQL and e.g. REST is, that the n+1 problem occurs on the server, rather than on the client. The clear benefit is, that we only have to deal with this problem once on the server, rather than on every client."),(0,o.kt)("p",null,"To depict the issue that data loaders solve in this context, let assume we have this schema:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-graphql"},"type Query {\n  person(id: ID): Person\n}\n\ntype Person {\n  id: ID\n  name: String\n  friends: [Person]\n}\n")),(0,o.kt)("p",null,"The above schema allows to fetch a person by its internal identifier and each person has a list of friends that is represented by a list of persons. A query against the above schema could look like the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-graphql"},'{\n  a: person(id: "a") {\n    name\n  }\n\n  b: person(id: "b") {\n    name\n  }\n}\n')),(0,o.kt)("p",null,"The problem with the GraphQL backend is that field resolvers are atomic and do not have any knowledge about the query as a whole. So, a field resolver does not know that it will be called multiple times in parallel to fetch similar or equal data from the same data source. ",(0,o.kt)("strong",{parentName:"p"},"The idea of a dataloader is to batch these two requests into one call to the database.")),(0,o.kt)("p",null,"Let's look at some code to understand what data loaders are doing. First, let's have a look at how we would write our field resolver without data loaders:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},"public async Task<Person> GetPerson(string id, [Service]IPersonRepository repository)\n{\n    return await repository.GetPersonById(id);\n}\n")),(0,o.kt)("h2",{id:"hotchocolate-data-loaders"},"HotChocolate Data Loaders"),(0,o.kt)("p",null,"The above example would result in two calls to the person repository that would then fetch the persons one by one from our data source. Instead of fetching the data from the repository directly, we fetch the data from the data loader. The data loader batches all the requests together into one request to the database:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"{16-23}","{16-23}":!0},"// This is one way of implementing a data loader. You will find the different ways of declaring\n// data loaders further down the page.\npublic class PersonBatchDataLoader : BatchDataLoader<string, Person>\n{\n    private readonly IPersonRepository _repository;\n\n    public PersonBatchDataLoader(\n        IPersonRepository repository,\n        IBatchScheduler batchScheduler,\n        DataLoaderOptions? options = null)\n        : base(batchScheduler, options)\n    {\n        _repository = repository;\n    }\n\n    protected override async Task<IReadOnlyDictionary<string, Person>> LoadBatchAsync(\n        IReadOnlyList<string> keys,\n        CancellationToken cancellationToken)\n    {\n        // instead of fetching one person, we fetch multiple persons\n        var persons =  await _repository.GetPersonByIds(keys);\n        return persons.ToDictionary(x => x.Id);\n    }\n}\n\n\npublic class Query\n{\n    public async Task<Person> GetPerson(\n        string id,\n        PersonBatchDataLoader dataLoader)\n        => await dataLoader.LoadAsync(id);\n}\n")),(0,o.kt)("h3",{id:"execution"},"Execution"),(0,o.kt)("p",null,"With a data loader, you can fetch entities with a key. These are the two generics you have in the class data loaders:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},"public class BatchDataLoader<TId, TEntity>\n")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"TId")," is used as an identifier of ",(0,o.kt)("inlineCode",{parentName:"p"},"TEntity"),". ",(0,o.kt)("inlineCode",{parentName:"p"},"TId")," is the type of the values you put into ",(0,o.kt)("inlineCode",{parentName:"p"},"LoadAsync"),"."),(0,o.kt)("p",null,"The execution engine of Hot Chocolate tries to batch as much as possible. It executes resolvers until the queue is empty and then triggers the data loader to resolve the data for the waiting resolvers."),(0,o.kt)("h3",{id:"data-consistency"},"Data Consistency"),(0,o.kt)("p",null,"Dataloaders do not only batch calls to the database, they also cache the database response. A data loader guarantees data consistency in a single request. If you load an entity with a data loader in your request more than once, it is given that these two entities are equivalent."),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"Data loaders do not fetch an entity if there is already an entity with the requested key in the cache.")))}h.isMDXComponent=!0}}]);