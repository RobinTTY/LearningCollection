"use strict";(self.webpackChunklearning_knowledge_base=self.webpackChunklearning_knowledge_base||[]).push([[6237],{99173:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>c,metadata:()=>o,toc:()=>r});const o=JSON.parse('{"id":"web/react/hooks/advanced-hooks/useCallback","title":"useCallback","description":"The useCallback hook basically allows us to store a function across component executions. This allows us to avoid the re-creation of the function every time a component is re-executed. The return value of useCallback is a memoized callback (with it we can reuse the same function across executions).","source":"@site/docs/web/react/hooks/advanced-hooks/useCallback.md","sourceDirName":"web/react/hooks/advanced-hooks","slug":"/web/react/hooks/advanced-hooks/useCallback","permalink":"/LearningCollection/web/react/hooks/advanced-hooks/useCallback","draft":false,"unlisted":false,"editUrl":"https://github.com/RobinTTY/LearningCollection/tree/master/website/docs/web/react/hooks/advanced-hooks/useCallback.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"id":"useCallback","title":"useCallback","sidebar_position":2},"sidebar":"docs","previous":{"title":"useImperativeHandle","permalink":"/LearningCollection/web/react/hooks/advanced-hooks/useImperativeHandle"},"next":{"title":"useMemo","permalink":"/LearningCollection/web/react/hooks/advanced-hooks/useMemo"}}');var t=a(74848),s=a(28453);const c={id:"useCallback",title:"useCallback",sidebar_position:2},i=void 0,l={},r=[{value:"Syntax",id:"syntax",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"useCallback"})," hook basically allows us to store a function across component executions. This allows us to avoid the re-creation of the function every time a component is re-executed. The return value of ",(0,t.jsx)(n.code,{children:"useCallback"})," is a ",(0,t.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Memoization",children:"memoized"})," callback (with it we can reuse the same function across executions)."]}),"\n",(0,t.jsx)(n.h2,{id:"syntax",children:"Syntax"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:"// we wrap the function we want to memoize inside useCallback\nconst memoizedCallback = useCallback(() => {\n  doSomething(a, b);\n}, [a, b]);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["A new function instance will only be generated if any value of the variables inside the dependency array changes between re-renders. If nothing changes, ",(0,t.jsx)(n.code,{children:"useCallback"})," will just return the cached version of the function instance."]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsx)(n.p,{children:"The array of dependencies is not passed as arguments to the callback. Conceptually, though, that\u2019s what they represent: every value referenced inside the callback should also appear in the dependencies array. In the future, a sufficiently advanced compiler could create this array automatically."})})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,n,a)=>{a.d(n,{R:()=>c,x:()=>i});var o=a(96540);const t={},s=o.createContext(t);function c(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);