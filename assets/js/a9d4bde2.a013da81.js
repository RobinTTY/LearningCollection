"use strict";(self.webpackChunklearning_knowledge_base=self.webpackChunklearning_knowledge_base||[]).push([[2617],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=c(n),d=i,h=u["".concat(s,".").concat(d)]||u[d]||m[d]||o;return n?a.createElement(h,r(r({ref:t},p),{},{components:n})):a.createElement(h,r({ref:t},p))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:i,r[1]=l;for(var c=2;c<o;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},3780:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>m,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var a=n(7462),i=(n(7294),n(3905));const o={id:"userFacingBackend",title:"User-Facing Backend",sidebar_position:4},r=void 0,l={unversionedId:"Databases/MongoDB/M220N MongoDB for .NET Developers/userFacingBackend",id:"Databases/MongoDB/M220N MongoDB for .NET Developers/userFacingBackend",title:"User-Facing Backend",description:"Aggregation Pipeline",source:"@site/docs/Databases/MongoDB/M220N MongoDB for .NET Developers/User-Facing Backend.md",sourceDirName:"Databases/MongoDB/M220N MongoDB for .NET Developers",slug:"/Databases/MongoDB/M220N MongoDB for .NET Developers/userFacingBackend",permalink:"/LearningCollection/Databases/MongoDB/M220N MongoDB for .NET Developers/userFacingBackend",draft:!1,editUrl:"https://github.com/RobinTTY/LearningCollection/tree/master/website/docs/Databases/MongoDB/M220N MongoDB for .NET Developers/User-Facing Backend.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{id:"userFacingBackend",title:"User-Facing Backend",sidebar_position:4},sidebar:"finance",previous:{title:"Using the Driver",permalink:"/LearningCollection/Databases/MongoDB/M220N MongoDB for .NET Developers/usingTheDriver"},next:{title:"Admin Backend",permalink:"/LearningCollection/Databases/MongoDB/M220N MongoDB for .NET Developers/adminBackend"}},s={},c=[{value:"Aggregation Pipeline",id:"aggregation-pipeline",level:2},{value:"Example",id:"example",level:3},{value:"Example of a similar (but not the same) pipeline in C#",id:"example-of-a-similar-but-not-the-same-pipeline-in-c",level:3},{value:"Faceted Search",id:"faceted-search",level:2},{value:"MFlix Functionality",id:"mflix-functionality",level:3},{value:"Basic Writes",id:"basic-writes",level:2},{value:"Example",id:"example-1",level:3},{value:"Basic Updates",id:"basic-updates",level:2},{value:"Examples",id:"examples",level:3},{value:"Write Concerns",id:"write-concerns",level:2},{value:"writeConcern: { w: 1 }",id:"writeconcern--w-1-",level:3},{value:"writeConcern: { w: majority }",id:"writeconcern--w-majority-",level:3},{value:"writeConcern: { w: 0 }",id:"writeconcern--w-0-",level:3},{value:"Example",id:"example-2",level:3},{value:"Joins",id:"joins",level:2},{value:"Basic Deletes",id:"basic-deletes",level:2}],p={toc:c},u="wrapper";function m(e){let{components:t,...o}=e;return(0,i.kt)(u,(0,a.Z)({},p,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"aggregation-pipeline"},"Aggregation Pipeline"),(0,i.kt)("h3",{id:"example"},"Example"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Aggregation Pipeline",src:n(8583).Z,width:"1911",height:"1285"})),(0,i.kt)("h3",{id:"example-of-a-similar-but-not-the-same-pipeline-in-c"},"Example of a similar (but not the same) pipeline in C#"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},'public void CountMovies()\n        {\n            // This stage finds all movies that have a specific director\n            var matchStage = new BsonDocument("$match",\n                new BsonDocument("directors", "Rob Reiner"));\n\n\n            // This stage sorts the results by the number of reviews,\n            // in descending order\n            var sortStage = new BsonDocument("$sort",\n                new BsonDocument("tomatoes.viewer.numReviews", -1));\n\n            // This stage generates the projection we want\n            var projectionStage = new BsonDocument("$project",\n                new BsonDocument\n                    {\n                        { "_id", 0 },\n                        { "Movie Title", "$title" },\n                        { "Year", "$year" },\n                        { "Average User Rating", "$tomatoes.viewer.rating" }\n                    });\n\n            /* We now put the stages together in a pipeline. Note that a\n             * pipeline definition requires us to specify the input and output\n             * types. In this case, the input is of type Movie, but because\n             * we are using a Projection with custom fields, our output is\n             * a generic BsonDocument object. To be really cool, we could\n             * create a mapping class for the output type, which is what we\'ve\n             * done for you in the MFlix application.\n             */\n\n            var pipeline = PipelineDefinition<Movie, BsonDocument>\n                .Create(new BsonDocument[] {\n                    matchStage,\n                    sortStage,\n                    projectionStage\n                });\n\n\n            var result = _moviesCollection.Aggregate(pipeline).ToList();\n            /* Note: we\'re making a synchronous Aggregate() call.\n             * If you want a challenge, change the line above to make an\n             * asynchronous call (hint: you\'ll need to make 2 changes),\n             * and then confirm the unit test still passes.\n             */\n\n            Assert.AreEqual(14, result.Count);\n            var firstMovie = result[0];\n            Assert.AreEqual("The Princess Bride", firstMovie.GetValue("Movie Title").AsString);\n            Assert.AreEqual(1987, firstMovie.GetValue("Year").AsInt32);\n            Assert.AreEqual(4.0, firstMovie.GetValue("Average User Rating").AsDouble);\n\n            /* We specifically excluded the "Id" field in the projection stage\n             * that we built in the code above, so let\'s make sure that field\n             * wasn\'t included in the resulting BsonDocument. We expect the call\n             * to GetValue() to throw a KeyNotFoundException exception if the\n             * field doesn\'t exist.\n             */\n\n            Assert.Throws<KeyNotFoundException>(()=> firstMovie.GetValue("Id"));\n        }\n')),(0,i.kt)("h2",{id:"faceted-search"},"Faceted Search"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"http://en.wikipedia.org/wiki/Faceted_search"},"Faceted search"),", or faceted navigation, is a way of browsing and searching for items in a set of data by applying filters on various properties (facets) of the items in the collection"),(0,i.kt)("li",{parentName:"ul"},"It is increasingly seen as an important part of the UI for many search platforms, and indeed nowadays is pretty much expected in places such as e-commerce websites"),(0,i.kt)("li",{parentName:"ul"},"It complements more free-form keyword search by facilitating exploration and discovery and is therefore useful when a user may not know the specific keywords they wish to search on.")),(0,i.kt)("p",null,"Some core functionality that a faceted search feature should provide might include:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"finding the items that match a particular value of a certain facet (e.g. colour:blue)"),(0,i.kt)("li",{parentName:"ul"},"finding the items in the intersection of multiple facet values (e.g. colour:blue AND size:medium)"),(0,i.kt)("li",{parentName:"ul"},"finding the items in the union of multiple facet values (e.g. colour:blue OR colour:red OR size:large)"),(0,i.kt)("li",{parentName:"ul"},'for each possible facet filter combination, display to the user the possible facet values on which it is possible to filter further ("drill down")'),(0,i.kt)("li",{parentName:"ul"},"for each facet value on which it is possible to drill down, display to the user the count of items matching that filter.")),(0,i.kt)("p",null,"For more info see the ",(0,i.kt)("a",{parentName:"p",href:"https://www.mongodb.com/blog/post/faceted-search-with-mongodb"},"MongoDB Blog"),"."),(0,i.kt)("h3",{id:"mflix-functionality"},"MFlix Functionality"),(0,i.kt)("p",null,"Faceted Search is a way of narrowing down search results by adding search parameters. For example let's say MFlix allows users to filter movies by a rating from 1 to 10, but Kate Winslet has only acted in movies that have a rating of 6 or higher."),(0,i.kt)("p",null,'If we didn\'t specify any other search parameters, MFlix would allow us to choose a rating between 1 and 10. But if we first search for "Kate Winslet", MFlix would only let us choose a rating between 6 and 10, because none of the movie documents in the result set have a rating below 6.'),(0,i.kt)("p",null,"To use faceted searches, the application must use the ",(0,i.kt)("strong",{parentName:"p"},"$facet pipeline stage")," of the Aggregation Framework."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note:")," To see how facets work see the ",(0,i.kt)("a",{parentName:"p",href:"https://university.mongodb.com/courses/M121/about"},"Aggregation Framework Course"),"."),(0,i.kt)("h2",{id:"basic-writes"},"Basic Writes"),(0,i.kt)("p",null,"To add something new to the database we can use the methods ",(0,i.kt)("inlineCode",{parentName:"p"},"InsertOneAsync")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"InsertManyAsync"),"."),(0,i.kt)("h3",{id:"example-1"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},'public async Task CreateMovieAsync()\n{\n\n    var newTheater = new Theater(27777,\n                    "4 Privet Drive",\n                    "Little Whinging",\n                    "LA",\n                    "343434");\n\n    await _theatersCollection.InsertOneAsync(newTheater);\n\n\n    // Add many\n    var theater1 = new Theater(27017, "1 Foo Street", "Dingledongle", "DE", "45678");\n    var theater2 = new Theater(27018, "234 Bar Ave.", "Wishywashy", "WY", "87654");\n    var theater3 = new Theater(27019, "75 Birthday Road", "Viejo Amigo", "CA", "99887");\n\n    await _theatersCollection.InsertManyAsync(\n        new List<Theater>()\n        {\n            theater1, theater2, theater3\n        }\n    );\n}\n')),(0,i.kt)("h2",{id:"basic-updates"},"Basic Updates"),(0,i.kt)("p",null,"To update something in the database we can use the methods ",(0,i.kt)("inlineCode",{parentName:"p"},"UpdateOneAsync"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"UpdateManyAsync")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"FindOneAndUpdateAsync"),"."),(0,i.kt)("h3",{id:"examples"},"Examples"),(0,i.kt)("p",null,"Updating one document:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},'// not type safe\nvar updateResult = _theatersCollection.UpdateOne(filter,\n    new BsonDocument("$set",\n        new BsonDocument("location.address.street1", "123 Main St."))\n    );\n\n// With the builder\n_theatersCollection.UpdateOne(filter,\n    Builders<Theater>.Update.Set(t => t.Location.Address.Street1,\n        "123 Main St.")\n    );\n\n// if you want to do something with the updated document use FindOneAndUpdateAsync\nvar updatedDoc = await _theatersCollection.FindOneAndUpdateAsync<Theater>(\n                filter,\n                Builders<Theater>.Update.Set(\n                    t => t.Location.Address.Street1,\n                    "123 Main St.")\n                );\n')),(0,i.kt)("p",null,"Updating many documents:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},'var update = Builders<Theater>\n                .Update.Set(t => t.Location.Address.City, "Bloomington");\n\n// And then we run UpdateManyAsync:\nvar result = await _theatersCollection.UpdateManyAsync(\n    filter,\n    update\n    );\n')),(0,i.kt)("h2",{id:"write-concerns"},"Write Concerns"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Write concerns are important when there are more than one data source"),(0,i.kt)("li",{parentName:"ul"},"An Atlas replica set is an example where write concerns can be important")),(0,i.kt)("h3",{id:"writeconcern--w-1-"},"writeConcern: { w: 1 }"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Only requests an acknowledgement that one node applied the write"),(0,i.kt)("li",{parentName:"ul"},"This is the default writeConcern in MongoDB")),(0,i.kt)("h3",{id:"writeconcern--w-majority-"},"writeConcern: { w: majority }"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Requests acknowledgement that a majority of nodes in the replica set applied the write"),(0,i.kt)("li",{parentName:"ul"},"Takes longer than w: 1"),(0,i.kt)("li",{parentName:"ul"},"Is more durable than w: 1",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Useful for ensuring vital writes are majority-committed"),(0,i.kt)("li",{parentName:"ul"},"e.g. user registration")))),(0,i.kt)("h3",{id:"writeconcern--w-0-"},"writeConcern: { w: 0 }"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Does not request an acknowledgement that any nodes applied the write",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},'"Fire and forget"'),(0,i.kt)("li",{parentName:"ul"},"acknowledgement can still indicate network errors or socket exceptions"))),(0,i.kt)("li",{parentName:"ul"},"Fastest writeConcern level"),(0,i.kt)("li",{parentName:"ul"},"Least durable writeConcern")),(0,i.kt)("h3",{id:"example-2"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},"await _usersCollection.WithWriteConcern(WriteConcern.WMajority).InsertOneAsync(user, cancellationToken: cancellationToken);\n")),(0,i.kt)("h2",{id:"joins"},"Joins"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Join two collections of data",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Movies and comments"))),(0,i.kt)("li",{parentName:"ul"},"Use new expressive $lookup",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"allows us to apply aggregation pipelines to data - before the data is joined"))),(0,i.kt)("li",{parentName:"ul"},"Build aggregation in Compass, and then export to language")),(0,i.kt)("p",null,"Join comments to movies (this pipeline is executed upon the movies collection):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},'// $match stage\n{\n  year: { "$gte": 1980, "$lt": 1990 }\n}\n\n// $lookup stage\n// from: collection we are joining from\n{\n  from: "comments",\n  // pipeline has access to fields inside comments collection\n  // but not to fields inside the movies collection\n  // if we need fields from movies we need to declare them in let\n  // this makes _id available in the pipeline as "id"\n  // this variable is referred to with the "$$" signs (movies collection)\n  // one "$" sign refers to the comments collection!\n  let: { "id": "$_id" },\n  pipeline: [\n    {\n      "$match":\n      // matches the comment "movie_id" field to the movie "id" field\n      { "$expr": { "$eq": [ "$movie_id", "$$id" ]} }\n    }\n  ],\n  // each movie has a new field movie_comments with the comments as array\n  as: "movie_comments"\n}\n\n// if we only care about how many comments there are, we can add a stage to our pipeline\n{\n  from: "comments",\n  let: { "id": "$_id" },\n  pipeline: [\n    {\n      "$match":\n      { "$expr": { "$eq": [ "$movie_id", "$$id" ]} }\n    },\n    {\n      "$count": "count"\n    }\n  ],\n  as: "movie_comments"\n}\n')),(0,i.kt)("p",null,"We can also export the pipeline from Compass to C# code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},'new BsonArray\n{\n    new BsonDocument("$match",\n    new BsonDocument("year",\n    new BsonDocument\n            {\n                { "$gte", 1980 },\n                { "$lt", 1990 }\n            })),\n    new BsonDocument("$lookup",\n    new BsonDocument\n        {\n            { "from", "comments" },\n            { "let",\n    new BsonDocument("id", "$_id") },\n            { "pipeline",\n    new BsonArray\n            {\n                new BsonDocument("$match",\n                new BsonDocument("$expr",\n                new BsonDocument("$eq",\n                new BsonArray\n                            {\n                                "$movie_id",\n                                "$$id"\n                            })))\n            } },\n            { "as", "movie_comments" }\n        })\n}\n')),(0,i.kt)("p",null,"Better approach:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},'/* Approach that uses several helpful methods in the driver:\n    * Aggregate(), Match(), and Lookup(), each of which is represented\n    * in the code above as MQL. The Lookup() method is a bit complex;\n    * here is an explanation of each of the parameters:\n    *\n    *  - The collection from which we want to lookup the values\n    *      (in this case, the Comments collection)\n    *  - The "key" in the Movies collection that will match a key in\n    *      the Comments collection.\n    *  - The "key" in the Comments collection that matches the previous\n    *      parameter. In both cases, it\'s the _id of each Movie we match\n    *      in the Match state.\n    *  - The property in which we want to put the lookup results. We\n    *      have already defined a Comments property on the Movie object\n    *      for just this purpose, so we specify it here.\n    *\n    */\nvar movies = _moviesCollection\n    .Aggregate()  // begins a fluent aggregation\n    .Match(m => (int)m.Year < 1990 && (int)m.Year >= 1980)\n    .Lookup(\n        _commentsCollection,\n        m => m.Id,\n        c => c.MovieId,\n        (Movie m)=>m.Comments\n        )\n    .ToList();\n\nvar firstMovie = movies.First();\n')),(0,i.kt)("h2",{id:"basic-deletes"},"Basic Deletes"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},'// delete one document\nvar filter = Builders<Theater>.Filter.Eq(t => t.TheaterId, 27017);\nvar result = await _theatersCollection.DeleteOneAsync(filter);\n\n// delete one document but return it\nfilter = Builders<Theater>.Filter.Eq(t => t.TheaterId, 27018);\nvar deletedDoc = await _theatersCollection.FindOneAndDeleteAsync(filter);\n\n// delete many\nvar filter = Builders<Theater>.Filter.Eq(t => t.Location.Address.City, "Movieville");\nvar result = await _theatersCollection.DeleteManyAsync(filter);\n')))}m.isMDXComponent=!0},8583:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/Pipeline-b4ab3c167f1f55b14cb4e3817a730a2b.PNG"}}]);