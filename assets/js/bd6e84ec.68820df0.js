"use strict";(self.webpackChunklearning_knowledge_base=self.webpackChunklearning_knowledge_base||[]).push([[3766],{41146:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>o});var t=n(74848),a=n(28453);const r={id:"classes",title:"Classes",sidebar_position:4},i=void 0,l={id:"web/typescript/core-concepts/classes",title:"Classes",description:"As with other JavaScript language features, TypeScript adds type annotations and other syntax to allow you to express relationships between classes and other types.",source:"@site/docs/web/typescript/core-concepts/classes.md",sourceDirName:"web/typescript/core-concepts",slug:"/web/typescript/core-concepts/classes",permalink:"/LearningCollection/web/typescript/core-concepts/classes",draft:!1,unlisted:!1,editUrl:"https://github.com/RobinTTY/LearningCollection/tree/master/website/docs/web/typescript/core-concepts/classes.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{id:"classes",title:"Classes",sidebar_position:4},sidebar:"docs",previous:{title:"Functions",permalink:"/LearningCollection/web/typescript/core-concepts/functions"},next:{title:"Interfaces",permalink:"/LearningCollection/web/typescript/core-concepts/interfaces"}},c={},o=[{value:"Class Members",id:"class-members",level:2},{value:"Fields",id:"fields",level:3},{value:"readonly",id:"readonly",level:4},{value:"Member Visibility",id:"member-visibility",level:4},{value:"Constructors",id:"constructors",level:3},{value:"Parameter Properties",id:"parameter-properties",level:4},{value:"Super Calls",id:"super-calls",level:4},{value:"Methods",id:"methods",level:3},{value:"Getters / Setters",id:"getters--setters",level:3},{value:"Static Members",id:"static-members",level:2},{value:"Class Heritage",id:"class-heritage",level:2},{value:"<code>implements</code> clauses",id:"implements-clauses",level:3},{value:"<code>extends</code> clauses",id:"extends-clauses",level:3},{value:"Overriding Methods",id:"overriding-methods",level:4},{value:"<code>abstract</code> Classes and Members",id:"abstract-classes-and-members",level:3}];function d(e){const s={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.p,{children:"As with other JavaScript language features, TypeScript adds type annotations and other syntax to allow you to express relationships between classes and other types."}),"\n",(0,t.jsx)(s.h2,{id:"class-members",children:"Class Members"}),"\n",(0,t.jsx)(s.p,{children:"Here\u2019s the most basic class - an empty one:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-ts",children:"class Point {}\n"})}),"\n",(0,t.jsx)(s.h3,{id:"fields",children:"Fields"}),"\n",(0,t.jsx)(s.p,{children:"A field declaration creates a public writeable property on a class:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-ts",children:"class Point {\n  x: number;\n  y: number;\n}\n\nconst pt = new Point();\npt.x = 0;\npt.y = 0;\n"})}),"\n",(0,t.jsx)(s.p,{children:"Fields can also have initializers; these will run automatically when the class is instantiated:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-ts",children:"class Point {\n  x = 0;\n  y = 0;\n}\n\nconst pt = new Point();\n// Prints 0, 0\nconsole.log(`${pt.x}, ${pt.y}`);\n"})}),"\n",(0,t.jsx)(s.admonition,{type:"note",children:(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"strictPropertyInitialization"})," setting controls whether class fields need to be initialized in the constructor."]})}),"\n",(0,t.jsx)(s.h4,{id:"readonly",children:"readonly"}),"\n",(0,t.jsxs)(s.p,{children:["Fields may be prefixed with the ",(0,t.jsx)(s.code,{children:"readonly"})," modifier. This prevents assignments to the field outside of the constructor."]}),"\n",(0,t.jsx)(s.h4,{id:"member-visibility",children:"Member Visibility"}),"\n",(0,t.jsx)(s.p,{children:"You can use TypeScript to control whether certain methods or properties are visible to code outside the class."}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"public"})," - the default, a public member can be accessed anywhere"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"protected"})," - a protected member can be accessed within the class and its subclasses"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"private"})," - a private member can only be accessed within the class"]}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"constructors",children:"Constructors"}),"\n",(0,t.jsx)(s.p,{children:"Class constructors are very similar to functions. You can add parameters with type annotations, default values, and overloads:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-ts",children:"class Point {\n  x: number;\n  y: number;\n\n  // Normal signature with defaults\n  constructor(x = 0, y = 0) {\n    this.x = x;\n    this.y = y;\n  }\n}\n"})}),"\n",(0,t.jsx)(s.p,{children:"There are just a few differences between class constructor signatures and function signatures:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Constructors can\u2019t have type parameters - these belong on the outer class declaration"}),"\n",(0,t.jsx)(s.li,{children:"Constructors can\u2019t have return type annotations - the class instance type is always what\u2019s returned"}),"\n"]}),"\n",(0,t.jsx)(s.h4,{id:"parameter-properties",children:"Parameter Properties"}),"\n",(0,t.jsxs)(s.p,{children:["TypeScript offers special syntax for turning a constructor parameter into a class property with the same name and value. These are called parameter properties and are created by prefixing a constructor argument with one of the visibility modifiers ",(0,t.jsx)(s.code,{children:"public"}),", ",(0,t.jsx)(s.code,{children:"private"}),", ",(0,t.jsx)(s.code,{children:"protected"}),", or ",(0,t.jsx)(s.code,{children:"readonly"}),". The resulting field gets those modifier(s):"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-ts",children:"class Params {\n  constructor(\n    public readonly x: number,\n    protected y: number,\n    private z: number\n  ) {\n    // No body necessary\n  }\n}\n\nconst a = new Params(1, 2, 3);\n"})}),"\n",(0,t.jsx)(s.h4,{id:"super-calls",children:"Super Calls"}),"\n",(0,t.jsxs)(s.p,{children:["Just as in JavaScript, if you have a base class, you\u2019ll need to call ",(0,t.jsx)(s.code,{children:"super();"})," in your constructor body before using any ",(0,t.jsx)(s.code,{children:"this"})," members."]}),"\n",(0,t.jsx)(s.h3,{id:"methods",children:"Methods"}),"\n",(0,t.jsx)(s.p,{children:"A function property on a class is called a method. Methods can use all the same type annotations as functions and constructors:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-ts",children:"class Point {\n  x = 10;\n  y = 10;\n\n  scale(n: number): void {\n    this.x *= n;\n    this.y *= n;\n  }\n}\n"})}),"\n",(0,t.jsx)(s.p,{children:"Other than the standard type annotations, TypeScript doesn\u2019t add anything else new to methods."}),"\n",(0,t.jsx)(s.h3,{id:"getters--setters",children:"Getters / Setters"}),"\n",(0,t.jsx)(s.p,{children:"Classes can also have accessors:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-ts",children:"class C {\n  _length = 0;\n  get length() {\n    return this._length;\n  }\n  set length(value) {\n    this._length = value;\n  }\n}\n"})}),"\n",(0,t.jsx)(s.admonition,{type:"note",children:(0,t.jsx)(s.p,{children:"Note that a field-backed get/set pair with no extra logic is very rarely useful in JavaScript. It\u2019s fine to expose public fields if you don\u2019t need to add additional logic during the get/set operations."})}),"\n",(0,t.jsx)(s.p,{children:"TypeScript has some special inference rules for accessors:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["If ",(0,t.jsx)(s.code,{children:"get"})," exists but no ",(0,t.jsx)(s.code,{children:"set"}),", the property is automatically ",(0,t.jsx)(s.code,{children:"readonly"})]}),"\n",(0,t.jsx)(s.li,{children:"If the type of the setter parameter is not specified, it is inferred from the return type of the getter"}),"\n",(0,t.jsxs)(s.li,{children:["Getters and setters must have the same ",(0,t.jsx)(s.a,{href:"https://www.typescriptlang.org/docs/handbook/2/classes.html#member-visibility",children:"Member Visibility"})]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"static-members",children:"Static Members"}),"\n",(0,t.jsxs)(s.p,{children:["Classes may have ",(0,t.jsx)(s.code,{children:"static"})," members. These members aren\u2019t associated with a particular instance of the class. They can be accessed through the class constructor object itself:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-ts",children:"class MyClass {\n  static x = 0;\n  static printX() {\n    console.log(MyClass.x);\n  }\n}\n\nconsole.log(MyClass.x);\nMyClass.printX();\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Static members can also use the same ",(0,t.jsx)(s.code,{children:"public"}),", ",(0,t.jsx)(s.code,{children:"protected"}),", and ",(0,t.jsx)(s.code,{children:"private"})," visibility modifiers. Static members are also inherited."]}),"\n",(0,t.jsx)(s.h2,{id:"class-heritage",children:"Class Heritage"}),"\n",(0,t.jsx)(s.p,{children:"Like other languages with object-oriented features, classes in JavaScript can inherit from base classes."}),"\n",(0,t.jsxs)(s.h3,{id:"implements-clauses",children:[(0,t.jsx)(s.code,{children:"implements"})," clauses"]}),"\n",(0,t.jsxs)(s.p,{children:["You can use an ",(0,t.jsx)(s.code,{children:"implements"})," clause to check that a class satisfies a particular ",(0,t.jsx)(s.code,{children:"interface"}),". An error will be issued if a class fails to correctly implement it:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-ts",children:"interface Pingable {\n  ping(): void;\n}\n\nclass Sonar implements Pingable {\n  ping() {\n    console.log(\"ping!\");\n  }\n}\n\nclass Ball implements Pingable {\n  // Class 'Ball' incorrectly implements interface 'Pingable'.\n  // Property 'ping' is missing in type 'Ball' but required in type 'Pingable'.\n  pong() {\n    console.log(\"pong!\");\n  }\n}\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Classes may also implement multiple interfaces, e.g. ",(0,t.jsx)(s.code,{children:"class C implements A, B"}),"."]}),"\n",(0,t.jsxs)(s.h3,{id:"extends-clauses",children:[(0,t.jsx)(s.code,{children:"extends"})," clauses"]}),"\n",(0,t.jsxs)(s.p,{children:["Classes may ",(0,t.jsx)(s.code,{children:"extend"})," from a base class. A derived class has all the properties and methods of its base class, and also define additional members:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-ts",children:'class Animal {\n  move() {\n    console.log("Moving along!");\n  }\n}\n\nclass Dog extends Animal {\n  woof(times: number) {\n    for (let i = 0; i < times; i++) {\n      console.log("woof!");\n    }\n  }\n}\n\nconst d = new Dog();\n// Base class method\nd.move();\n// Derived class method\nd.woof(3);\n'})}),"\n",(0,t.jsx)(s.h4,{id:"overriding-methods",children:"Overriding Methods"}),"\n",(0,t.jsxs)(s.p,{children:["A derived class can also override a base class field or property. You can use the ",(0,t.jsx)(s.code,{children:"super."})," syntax to access base class methods. TypeScript enforces that a derived class is always a subtype of its base class."]}),"\n",(0,t.jsx)(s.p,{children:"For example, here\u2019s a legal way to override a method:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-ts",children:'class Base {\n  greet() {\n    console.log("Hello, world!");\n  }\n}\n\nclass Derived extends Base {\n  greet(name?: string) {\n    if (name === undefined) {\n      super.greet();\n    } else {\n      console.log(`Hello, ${name.toUpperCase()}`);\n    }\n  }\n}\n\nconst d = new Derived();\nd.greet();\nd.greet("reader");\n'})}),"\n",(0,t.jsx)(s.p,{children:"It\u2019s important that a derived class follow its base class contract. Remember that it\u2019s very common (and always legal!) to refer to a derived class instance through a base class reference:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-ts",children:"// Alias the derived instance through a base class reference\nconst b: Base = d;\n// No problem\nb.greet();\n"})}),"\n",(0,t.jsxs)(s.h3,{id:"abstract-classes-and-members",children:[(0,t.jsx)(s.code,{children:"abstract"})," Classes and Members"]}),"\n",(0,t.jsxs)(s.p,{children:["An abstract method or abstract field is one that ",(0,t.jsx)(s.strong,{children:"hasn\u2019t had an implementation provided"}),". These members ",(0,t.jsx)(s.strong,{children:"must exist inside an abstract class"}),", which ",(0,t.jsx)(s.strong,{children:"cannot be directly instantiated"}),"."]}),"\n",(0,t.jsxs)(s.p,{children:["The role of abstract classes is to ",(0,t.jsx)(s.strong,{children:"serve as a base class for subclasses"})," which do implement all the abstract members. When a class doesn\u2019t have any abstract members, it is said to be concrete."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-ts",children:'abstract class Base {\n  abstract getName(): string;\n\n  printName() {\n    console.log("Hello, " + this.getName());\n  }\n}\n\n// Error: Cannot create an instance of an abstract class.\nconst b = new Base();\n'})}),"\n",(0,t.jsxs)(s.p,{children:["We can\u2019t instantiate ",(0,t.jsx)(s.code,{children:"Base"})," with ",(0,t.jsx)(s.code,{children:"new"})," because it\u2019s abstract. Instead, we need to make a derived class and implement the abstract members:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-ts",children:'class Derived extends Base {\n  getName() {\n    return "world";\n  }\n}\n\nconst d = new Derived();\nd.printName();\n'})})]})}function h(e={}){const{wrapper:s}={...(0,a.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,s,n)=>{n.d(s,{R:()=>i,x:()=>l});var t=n(96540);const a={},r=t.createContext(a);function i(e){const s=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),t.createElement(r.Provider,{value:s},e.children)}}}]);