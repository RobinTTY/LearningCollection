"use strict";(self.webpackChunklearning_knowledge_base=self.webpackChunklearning_knowledge_base||[]).push([[6886],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>m});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),c=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},p=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},h="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),h=c(a),u=r,m=h["".concat(s,".").concat(u)]||h[u]||d[u]||o;return a?n.createElement(m,l(l({ref:t},p),{},{components:a})):n.createElement(m,l({ref:t},p))}));function m(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,l=new Array(o);l[0]=u;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[h]="string"==typeof e?e:r,l[1]=i;for(var c=2;c<o;c++)l[c]=a[c];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},4339:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var n=a(7462),r=(a(7294),a(3905));const o={id:"data-loaders",title:"Data Loaders",sidebar_position:6},l=void 0,i={unversionedId:"apis/graphql/hot-chocolate/data-loaders",id:"apis/graphql/hot-chocolate/data-loaders",title:"Data Loaders",description:"ataLoader is a generic utility to be used as part of the application's data fetching layer to provide a consistent API over various backends and reduce requests to those backends via batching and caching. It helps you to avoid the N+1 problem.",source:"@site/docs/apis/graphql/hot-chocolate/data-loaders.md",sourceDirName:"apis/graphql/hot-chocolate",slug:"/apis/graphql/hot-chocolate/data-loaders",permalink:"/LearningCollection/apis/graphql/hot-chocolate/data-loaders",draft:!1,editUrl:"https://github.com/RobinTTY/LearningCollection/tree/master/website/docs/apis/graphql/hot-chocolate/data-loaders.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{id:"data-loaders",title:"Data Loaders",sidebar_position:6},sidebar:"finance",previous:{title:"Resolvers",permalink:"/LearningCollection/apis/graphql/hot-chocolate/resolvers"},next:{title:"Important Annotations",permalink:"/LearningCollection/apis/graphql/hot-chocolate/important-annotations"}},s={},c=[{value:"Context: The N+1 Problem",id:"context-the-n1-problem",level:2},{value:"Example",id:"example",level:3},{value:"N+1 Problem in GraphQL",id:"n1-problem-in-graphql",level:3}],p={toc:c},h="wrapper";function d(e){let{components:t,...a}=e;return(0,r.kt)(h,(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"ataLoader is a generic utility to be used as part of the application's data fetching layer to provide a consistent API over various backends and reduce requests to those backends via batching and caching. It helps you to avoid the N+1 problem."),(0,r.kt)("h2",{id:"context-the-n1-problem"},"Context: The N+1 Problem"),(0,r.kt)("p",null,"Every data fetching technology suffers the n+1 problem. Typically, it happens when you structure your code so that you first do a query to get a list of records, then subsequently do another query for each of those records."),(0,r.kt)("h3",{id:"example"},"Example"),(0,r.kt)("p",null,"Let's say we have a collection of ",(0,r.kt)("inlineCode",{parentName:"p"},"Car")," objects (database rows), and each ",(0,r.kt)("inlineCode",{parentName:"p"},"Car")," has a collection of ",(0,r.kt)("inlineCode",{parentName:"p"},"Wheel")," objects (also rows). In other words, ",(0,r.kt)("inlineCode",{parentName:"p"},"Car \u2192 Wheel")," is a 1-to-many relationship."),(0,r.kt)("p",null,"Now, let's say we need to iterate through all the cars, and for each one, print out a list of the wheels. The naive implementation would do the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM Cars;\n")),(0,r.kt)("p",null,"And then for each Car:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM Wheel WHERE CarId = ?\n")),(0,r.kt)("p",null,"In other words, you have one select for the Cars, and then N additional selects, where N is the total number of cars. Alternatively, one could get all wheels and perform the lookups in memory:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM Wheel;\n")),(0,r.kt)("p",null,"This reduces the number of round-trips to the database from N+1 to 2. Most ORM tools give you several ways to prevent N+1 selects."),(0,r.kt)("h3",{id:"n1-problem-in-graphql"},"N+1 Problem in GraphQL"),(0,r.kt)("p",null,"The difference between GraphQL and e.g. REST is, that the n+1 problem occurs on the server, rather than on the client. The clear benefit is, that we only have to deal with this problem once on the server, rather than on every client."),(0,r.kt)("p",null,"To depict the issue that data loaders solve in this context, let assume we have this schema:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"type Query {\n  person(id: ID): Person\n}\n\ntype Person {\n  id: ID\n  name: String\n  friends: [Person]\n}\n")),(0,r.kt)("p",null,"The above schema allows to fetch a person by its internal identifier and each person has a list of friends that is represented by a list of persons. A query against the above schema could look like the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},'{\n  a: person(id: "a") {\n    name\n  }\n\n  b: person(id: "b") {\n    name\n  }\n}\n')))}d.isMDXComponent=!0}}]);