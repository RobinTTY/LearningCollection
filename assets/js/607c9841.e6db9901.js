"use strict";(self.webpackChunklearning_knowledge_base=self.webpackChunklearning_knowledge_base||[]).push([[1737],{9858:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>l});var i=t(4848),r=t(8453);const a={title:"Tracking Behavior"},s=void 0,o={id:"csharp/entity-framework/querying-data/tracking-behavior",title:"Tracking Behavior",description:"Tracking behavior controls if Entity Framework Core keeps information about an entity instance in its change tracker. If an entity is tracked:",source:"@site/docs/csharp/entity-framework/querying-data/tracking-behavior.md",sourceDirName:"csharp/entity-framework/querying-data",slug:"/csharp/entity-framework/querying-data/tracking-behavior",permalink:"/LearningCollection/csharp/entity-framework/querying-data/tracking-behavior",draft:!1,unlisted:!1,editUrl:"https://github.com/RobinTTY/LearningCollection/tree/master/website/docs/csharp/entity-framework/querying-data/tracking-behavior.md",tags:[],version:"current",frontMatter:{title:"Tracking Behavior"},sidebar:"docs",previous:{title:"Basic Querying",permalink:"/LearningCollection/csharp/entity-framework/querying-data/basic-querying"},next:{title:"Integration Testing",permalink:"/LearningCollection/csharp/entity-framework/testing/integration-testing"}},c={},l=[{value:"Tracking queries",id:"tracking-queries",level:2},{value:"No-tracking queries",id:"no-tracking-queries",level:2},{value:"Identity resolution",id:"identity-resolution",level:2},{value:"Default tracking behavior",id:"default-tracking-behavior",level:2}];function d(e){const n={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"Tracking behavior controls if Entity Framework Core keeps information about an entity instance in its change tracker. If an entity is tracked:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["any changes detected in the entity are persisted to the database during ",(0,i.jsx)(n.code,{children:"SaveChanges"}),"."]}),"\n",(0,i.jsx)(n.li,{children:"navigation properties are fixed up between the entities in a tracking query result and the entities that are in the change tracker."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"tracking-queries",children:"Tracking queries"}),"\n",(0,i.jsxs)(n.p,{children:["By default, queries that return entity types are tracking. A tracking query means any changes to entity instances are persisted by ",(0,i.jsx)(n.code,{children:"SaveChanges"}),". In the following example, the change to the blogs rating is detected and persisted to the database during ",(0,i.jsx)(n.code,{children:"SaveChanges"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"var blog = context.Blogs.SingleOrDefault(b => b.BlogId == 1);\nblog.Rating = 5;\ncontext.SaveChanges();\n"})}),"\n",(0,i.jsx)(n.p,{children:"When the results are returned in a tracking query, EF Core checks if the entity is already in the context. If EF Core finds an existing entity, then the same instance is returned, which can potentially use less memory and be faster than a no-tracking query. EF Core doesn't overwrite current and original values of the entity's properties in the entry with the database values. If the entity isn't found in the context, EF Core creates a new entity instance and attaches it to the context. Query results don't contain any entity which is added to the context but not yet saved to the database."}),"\n",(0,i.jsx)(n.h2,{id:"no-tracking-queries",children:"No-tracking queries"}),"\n",(0,i.jsx)(n.p,{children:"No-tracking queries are useful when the results are used in a read-only scenario. They're generally quicker to execute because there's no need to set up the change tracking information. If the entities retrieved from the database don't need to be updated, then a no-tracking query should be used. An individual query can be set to be no-tracking. A no-tracking query also give results based on what's in the database disregarding any local changes or added entities."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"var blogs = context.Blogs\n    .AsNoTracking()\n    .ToList();\n"})}),"\n",(0,i.jsx)(n.p,{children:"The default tracking behavior can be changed at the context instance level:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",metastring:"{1}",children:"context.ChangeTracker.QueryTrackingBehavior = QueryTrackingBehavior.NoTracking;\n\nvar blogs = context.Blogs.ToList();\n"})}),"\n",(0,i.jsx)(n.h2,{id:"identity-resolution",children:"Identity resolution"}),"\n",(0,i.jsx)(n.p,{children:"Since a tracking query uses the change tracker, EF Core does identity resolution in a tracking query. When materializing an entity, EF Core returns the same entity instance from the change tracker if it's already being tracked. If the result contains the same entity multiple times, the same instance is returned for each occurrence. No-tracking queries:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Don't use the change tracker and don't do identity resolution."}),"\n",(0,i.jsx)(n.li,{children:"Return a new instance of the entity even when the same entity is contained in the result multiple times."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Tracking and no-tracking can be combined in the same query. That is, you can have a no-tracking query, which does identity resolution in the results with ",(0,i.jsx)(n.code,{children:"AsNoTrackingWithIdentityResolution<TEntity>(IQueryable<TEntity>)"}),". When the query to use identity resolution is configured with no tracking, a stand-alone change tracker is used in the background when generating query results so each instance is materialized only once. Since this change tracker is different from the one in the context, the results are not tracked by the context. After the query is enumerated fully, the change tracker goes out of scope and garbage collected as required."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"var blogs = context.Blogs\n    .AsNoTrackingWithIdentityResolution()\n    .ToList();\n"})}),"\n",(0,i.jsx)(n.h2,{id:"default-tracking-behavior",children:"Default tracking behavior"}),"\n",(0,i.jsx)(n.p,{children:"If you find yourself changing the tracking behavior for many queries, you may want to change the default instead:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)\n{\n    optionsBuilder\n        .UseSqlServer(@"Server=(localdb)\\mssqllocaldb;Database=EFQuerying.Tracking;Trusted_Connection=True;ConnectRetryCount=0")\n        .UseQueryTrackingBehavior(QueryTrackingBehavior.NoTracking);\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["This makes all your queries no-tracking by default. You can still add ",(0,i.jsx)(n.code,{children:"AsTracking"})," to make specific queries tracking."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var i=t(6540);const r={},a=i.createContext(r);function s(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);