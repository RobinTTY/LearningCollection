"use strict";(self.webpackChunklearning_knowledge_base=self.webpackChunklearning_knowledge_base||[]).push([[4712],{1907:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"csharp/comparisons/threadVsTask","title":"Thread vs Task","description":"Thread: lower level concept, always a seperate Thread rather than executing on the Treadpool -> actual OS-level Thread with own stack + kernel ressources","source":"@site/docs/csharp/comparisons/thread-vs-task.md","sourceDirName":"csharp/comparisons","slug":"/csharp/comparisons/threadVsTask","permalink":"/LearningCollection/csharp/comparisons/threadVsTask","draft":false,"unlisted":false,"editUrl":"https://github.com/RobinTTY/LearningCollection/tree/master/website/docs/csharp/comparisons/thread-vs-task.md","tags":[],"version":"current","frontMatter":{"id":"threadVsTask","title":"Thread vs Task"},"sidebar":"docs","previous":{"title":"private protected vs protected internal","permalink":"/LearningCollection/csharp/comparisons/private-protected-vs-protected-internal"},"next":{"title":"Doctype","permalink":"/LearningCollection/web/html/doctype"}}');var o=t(74848),a=t(28453);const r={id:"threadVsTask",title:"Thread vs Task"},i=void 0,l={},h=[{value:"What to use",id:"what-to-use",level:2},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const n={h2:"h2",li:"li",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Thread:"})," lower level concept, always a seperate Thread rather than executing on the Treadpool -> actual OS-level Thread with own stack + kernel ressources\n",(0,o.jsx)(n.strong,{children:"Task:"})," more than just an abstration of where to run some code, it's really just the promise of a result in the future"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Task.Delay: doesn't need any actual CPU time, like setting a timer to go off in the future"}),"\n",(0,o.jsx)(n.li,{children:'Task.Run: is saying "I want to execute this code seperately", the exact thread on which that code executes depends on a nmber of factors'}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"ThreadPool:"})," is a wrapper around a pool of threads maintained by the ",(0,o.jsx)(n.strong,{children:"CLR (Common Runtime Language)"}),". ThreadPool gives you no control at all. You can submit work to execute at some point, and you can control the size of the pool, but you can't set anything else. You can't even tell when the pool will start running the work you submit to it."]}),"\n",(0,o.jsx)(n.h2,{id:"what-to-use",children:"What to use"}),"\n",(0,o.jsx)(n.p,{children:"Thread:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"highest level of control"}),"\n",(0,o.jsx)(n.li,{children:"costly, consumes non-trivial amount of memory for its stack"}),"\n",(0,o.jsx)(n.li,{children:"additional overhead for context-switch between threads"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Task:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Task class from the Task Parallel Library offers the best of both worlds"}),"\n",(0,o.jsx)(n.li,{children:"Like the ThreadPool, a task does not create its own OS thread"}),"\n",(0,o.jsx)(n.li,{children:"Instead, tasks are executed by a TaskScheduler; the default scheduler simply runs on the ThreadPool"}),"\n",(0,o.jsx)(n.li,{children:"Unlike the ThreadPool, Task also allows you to find out when it finishes, and (via the generic Task) to return a result"}),"\n",(0,o.jsx)(n.li,{children:"You can call ContinueWith() on an existing Task to make it run more code once the task finishes (if it's already finished, it will run the callback immediately). If the task is generic, ContinueWith() will pass you the task's result, allowing you to run more code that uses it"}),"\n",(0,o.jsxs)(n.li,{children:["You can also synchronously wait for a task to finish by calling Wait() (or, for a generic task, by getting the Result property). Like Thread.Join(), this will block the calling thread until the task finishes.","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Synchronously waiting for a task is usually bad idea; it prevents the calling thread from doing any other work, and can also lead to deadlocks if the task ends up waiting (even asynchronously) for the current thread."}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["Since tasks still run on the ThreadPool, they should not be used for long-running operations, since they can still fill up the thread pool and block new work","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Instead, Task provides a LongRunning option, which will tell the TaskScheduler to spin up a new thread rather than running on the ThreadPool."}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.li,{children:"All newer high-level concurrency APIs, including the Parallel.For*() methods, PLINQ, C# 5 await, and modern async methods in the BCL, are all built on Task."}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"The bottom line is that Task is almost always the best option; it provides a much more powerful API and avoids wasting OS threads."}),"\n",(0,o.jsx)(n.li,{children:"The only reasons to explicitly create your own Threads in modern code are setting per-thread options, or maintaining a persistent thread that needs to maintain its own identity."}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>i});var s=t(96540);const o={},a=s.createContext(o);function r(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);