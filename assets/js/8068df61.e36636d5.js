"use strict";(self.webpackChunklearning_knowledge_base=self.webpackChunklearning_knowledge_base||[]).push([[6092],{21290:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"web/typescript/advanced-concepts/intersections","title":"Intersection Types","description":"interfaces allowed us to build up new types from other types by extending them. TypeScript provides another construct called intersection types that is mainly used to combine existing object types.","source":"@site/docs/web/typescript/advanced-concepts/intersections.md","sourceDirName":"web/typescript/advanced-concepts","slug":"/web/typescript/advanced-concepts/intersections","permalink":"/LearningCollection/web/typescript/advanced-concepts/intersections","draft":false,"unlisted":false,"editUrl":"https://github.com/RobinTTY/LearningCollection/tree/master/website/docs/web/typescript/advanced-concepts/intersections.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"id":"intersections","title":"Intersection Types","sidebar_position":1},"sidebar":"docs","previous":{"title":"Type Assertions","permalink":"/LearningCollection/web/typescript/core-concepts/type-assertions"},"next":{"title":"Type Guards","permalink":"/LearningCollection/web/typescript/advanced-concepts/type-guards"}}');var i=t(74848),o=t(28453);const r={id:"intersections",title:"Intersection Types",sidebar_position:1},c=void 0,a={},l=[{value:"Intersection of Unions",id:"intersection-of-unions",level:2},{value:"Interfaces vs. Intersections",id:"interfaces-vs-intersections",level:2}];function d(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"interfaces"})," allowed us to build up new types from other types by extending them. TypeScript provides another construct called intersection types that is mainly used to ",(0,i.jsx)(n.strong,{children:"combine existing object types"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["An intersection type is defined using the ",(0,i.jsx)(n.code,{children:"&"})," operator."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"interface Colorful {\n  color: string;\n}\ninterface Circle {\n  radius: number;\n}\n\ntype ColorfulCircle = Colorful & Circle;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Here, we\u2019ve intersected ",(0,i.jsx)(n.code,{children:"Colorful"})," and ",(0,i.jsx)(n.code,{children:"Circle"})," to produce a new type that has all the members of ",(0,i.jsx)(n.code,{children:"Colorful"})," and ",(0,i.jsx)(n.code,{children:"Circle"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"function draw(circle: Colorful & Circle) {\n  console.log(`Color was ${circle.color}`);\n  console.log(`Radius was ${circle.radius}`);\n}\n\n// okay\ndraw({ color: \"blue\", radius: 42 });\n\n// Argument of type '{ color: string; raidus: number; }' is not\n// assignable to parameter of type 'Colorful & Circle'.\ndraw({ color: \"red\", raidus: 42 });\n"})}),"\n",(0,i.jsx)(n.h2,{id:"intersection-of-unions",children:"Intersection of Unions"}),"\n",(0,i.jsx)(n.p,{children:"We can also intersect unions:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"type Combinable = string | number;\ntype Numeric = number | boolean;\n\n// Universal is of type number since that is the only possible intersection of the two unions\ntype Universal = Combinable & Numeric;\n"})}),"\n",(0,i.jsx)(n.h2,{id:"interfaces-vs-intersections",children:"Interfaces vs. Intersections"}),"\n",(0,i.jsxs)(n.p,{children:["With interfaces, we could use an ",(0,i.jsx)(n.code,{children:"extends"})," clause to extend from other types, and we were able to do something similar with intersections and name the result with a type alias. The principle ",(0,i.jsx)(n.strong,{children:"difference between the two is how conflicts are handled"}),", and that difference is typically one of the main reasons why you\u2019d pick one over the other between an interface and a type alias of an intersection type."]})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>c});var s=t(96540);const i={},o=s.createContext(i);function r(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);