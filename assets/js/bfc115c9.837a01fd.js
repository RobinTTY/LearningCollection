"use strict";(self.webpackChunklearning_knowledge_base=self.webpackChunklearning_knowledge_base||[]).push([[4257],{11133:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>h,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>r,toc:()=>l});var s=t(74848),i=t(28453);const a={id:"pagination",title:"Pagination",sidebar_position:6},o=void 0,r={id:"apis/graphql/pagination",title:"Pagination",description:"Often, sets of data are too large to pass them directly to the consumer of our service. Pagination solves this problem by giving the consumer the ability to fetch a set in chunks. The current landscape of the pagination in GraphQL is hugely influenced by the Relay spec for Connections.",source:"@site/docs/apis/graphql/pagination.md",sourceDirName:"apis/graphql",slug:"/apis/graphql/pagination",permalink:"/LearningCollection/apis/graphql/pagination",draft:!1,unlisted:!1,editUrl:"https://github.com/RobinTTY/LearningCollection/tree/master/website/docs/apis/graphql/pagination.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{id:"pagination",title:"Pagination",sidebar_position:6},sidebar:"docs",previous:{title:"Server",permalink:"/LearningCollection/apis/graphql/server"},next:{title:"Miscellaneous Concepts",permalink:"/LearningCollection/apis/graphql/advanced-concepts/miscellaneous-concepts"}},h={},l=[{value:"Connections vs Offset",id:"connections-vs-offset",level:2},{value:"Offset problem visualized",id:"offset-problem-visualized",level:3},{value:"Connections approach",id:"connections-approach",level:3},{value:"An Example (Relay spec)",id:"an-example-relay-spec",level:2},{value:"How pagination is modeled",id:"how-pagination-is-modeled",level:3}];function c(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Often, sets of data are too large to pass them directly to the consumer of our service. Pagination solves this problem by giving the consumer the ability to fetch a set in chunks. The current landscape of the pagination in GraphQL is hugely influenced by the ",(0,s.jsx)(n.a,{href:"https://relay.dev/graphql/connections.htm",children:"Relay spec"})," for Connections."]}),"\n",(0,s.jsx)(n.h2,{id:"connections-vs-offset",children:"Connections vs Offset"}),"\n",(0,s.jsx)(n.p,{children:"GraphQL connections use cursor based pagination which is very well suited for large data sets as compared to offset based pagination. Offset pagination has drawbacks:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"If items are being written to the dataset at a high frequency, the page window becomes unreliable, potentially skipping or returning duplicate results."}),"\n",(0,s.jsxs)(n.li,{children:["Using ",(0,s.jsx)(n.code,{children:"LIMIT <count> OFFSET <offset>"})," doesn\u2019t scale well for large datasets. As the offset increases the farther you go within the dataset, the database still has to read up to offset + count rows from disk, before discarding the offset and only returning count rows"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"offset-problem-visualized",children:"Offset problem visualized"}),"\n",(0,s.jsx)(n.p,{children:"We get some paginated data with our first request:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"offset-problem",src:t(37210).A+"",width:"1240",height:"247"})}),"\n",(0,s.jsx)(n.p,{children:"Before we can request the next page, the data set changes and we get a shifted result:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"offset-problem2",src:t(64402).A+"",width:"1195",height:"187"})}),"\n",(0,s.jsx)(n.h3,{id:"connections-approach",children:"Connections approach"}),"\n",(0,s.jsx)(n.p,{children:"Connections solve this problem by using a cursor based pagination. Instead of using an offset, we use a cursor to fetch the next page. The cursor is a pointer to a specific item in the data set. The cursor is opaque to the client and can be anything that can be sorted. For example, it could be a date, a unique ID, or a pointer to an object in a database."}),"\n",(0,s.jsx)(n.p,{children:"The spec outlines the following components:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"connection"}),": a wrapper for details on a list of data you\u2019re paginating through. A connection has two fields: edges and pageInfo."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"edges"}),": a list of edge types."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"edge"}),": a wrapper around the object being returned in the list. An edge type has two fields: node and cursor."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"node"}),": this is the actual object, for example, user details."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"cursor"}),": this is a string field that is used to identify a specific edge."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"pageInfo"}),": contains two fields hasPreviousPage and hasNextPage which can be used to determine whether or not you need to request another set of results."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"While the above might seem verbose, it allows the server to implement a robust pagination scheme:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Returning a list of edge wrappers, each with a cursor, enables the client to paginate forwards and backwards from any point within the result set."}),"\n",(0,s.jsx)(n.li,{children:"The pageInfo details let the client clearly know if there is a previous or next page to fetch."}),"\n",(0,s.jsx)(n.li,{children:"Requiring the cursor to be a string value promotes the use of an opaque cursor value. The javascript implementation of the Relay spec for instance uses Base64 encoded IDs as cursor values. This discourages the client from implying what value goes in this field and gives the server the ability to encode additional information within the cursor."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"With this setup we can request the next page without having to worry about the data set changing:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"cursor-pagination1",src:t(84885).A+"",width:"1267",height:"304"})}),"\n",(0,s.jsx)(n.p,{children:"Second request:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"cursor-pagination2",src:t(99134).A+"",width:"1219",height:"265"})}),"\n",(0,s.jsx)(n.h2,{id:"an-example-relay-spec",children:"An Example (Relay spec)"}),"\n",(0,s.jsx)(n.p,{children:"There are three important points to understand:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Edges themselves have properties"})," \u2014 for example, in a list of your friends, the date when you friended that person is a property of the edge between you, rather than of the other person per se. We handle this by creating nodes that represent the edges."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"The list itself has properties"}),", such as whether or not there is a next page available. We handle this with a node that represent the list itself as well as one for the current page."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Pagination is done by cursors"})," \u2014 opaque symbols that point to the next page of results \u2014 rather than offsets."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Imagine we want to show a list of the user\u2019s friends. At a high level, we imagine a graph where the viewer and their friends are each nodes. From the viewer to each friend node is an edge, and the edge itself has properties:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"conceptual-graph1",src:t(80531).A+"",width:"1570",height:"894"})}),"\n",(0,s.jsx)(n.p,{children:"In GraphQL, only nodes can have properties, not edges. So the first thing we\u2019ll do is represent the conceptual edge from you to your friend with its very own node:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"conceptual-graph2",src:t(34776).A+"",width:"1466",height:"1076"})}),"\n",(0,s.jsxs)(n.p,{children:["Now the properties of the edge are represented by a new type of node called a ",(0,s.jsx)(n.code,{children:"FriendsEdge"}),". The GraphQL to query this would like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:"fragment FriendsFragment1 on Viewer {\n  friends {\n    since // a property of the edge\n    node {\n      name // a property of the friend itself\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"how-pagination-is-modeled",children:"How pagination is modeled"}),"\n",(0,s.jsx)(n.p,{children:"Now we have a good place in the GraphQL schema to put edge-specific information such as the date when the edge was created (that is, the date you friended that person). Now consider what we would need to model in our schema in order to support pagination and infinite scrolling:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The client must be able to specify ",(0,s.jsx)(n.strong,{children:"how large of a page"})," it wants."]}),"\n",(0,s.jsxs)(n.li,{children:["The client must be informed as to ",(0,s.jsx)(n.strong,{children:"whether any more pages are available"}),", so that it can enable or disable the \u2018next page\u2019 button (or, for infinite scrolling, can stop making further requests)."]}),"\n",(0,s.jsxs)(n.li,{children:["The client must be ",(0,s.jsx)(n.strong,{children:"able to ask for the next page"})," after the one it already has."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Specifying the page size is done with field arguments. In other words, instead of just ",(0,s.jsx)(n.code,{children:"friends"})," the query will say ",(0,s.jsx)(n.code,{children:"friends(first: 3)"}),", passing the page size an argument to the ",(0,s.jsx)(n.code,{children:"friends"})," field."]}),"\n",(0,s.jsxs)(n.p,{children:["For the server to say whether there is a next page or not, we need to ",(0,s.jsx)(n.strong,{children:"introduce a node in the graph that has information about the list of friends itself"}),", just like we are introducing a node for each edge to store information about the edge itself. This new node is called ",(0,s.jsx)(n.strong,{children:"a Connection"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"The Connection node represents the connection itself between you and your friends:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"e.g. it could have a totalCount field that says how many friends you have"}),"\n",(0,s.jsxs)(n.li,{children:["It always has two fields which represent the current page:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"pageInfo"})," field with metadata about the current page, such as whether there is another page available"]}),"\n",(0,s.jsxs)(n.li,{children:["An ",(0,s.jsx)(n.code,{children:"edges"})," field that points to the edges we saw before"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"conceptual-graph3",src:t(55905).A+"",width:"1924",height:"1334"})}),"\n",(0,s.jsxs)(n.p,{children:["Finally, we need a way to request the next page of results. You\u2019ll notice in the above diagram that the ",(0,s.jsx)(n.code,{children:"PageInfo"})," node has a field called ",(0,s.jsx)(n.code,{children:"lastCursor"}),". This is an opaque token provided by the server that represents the position in the list of the last edge that we were given (the friend \u201cCharmaine\u201d). We can then pass this cursor back to the server in order to retrieve the next page."]}),"\n",(0,s.jsxs)(n.p,{children:["By passing the ",(0,s.jsx)(n.code,{children:"lastCursor"})," value back to the server as an argument to the ",(0,s.jsx)(n.code,{children:"friends"})," field, we can ask the server for friends that are after the ones we\u2019ve already retrieved:"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"conceptual-graph4",src:t(38190).A+"",width:"1926",height:"1336"})}),"\n",(0,s.jsxs)(n.p,{children:["This overall scheme for modeling paginated lists is specified in detail in the ",(0,s.jsx)(n.a,{href:"https://relay.dev/graphql/connections.htm",children:"GraphQL Cursor Connections Spec"}),". It is flexible for many different applications, and although Relay relies on this convention to handle pagination automatically, designing your schema this way is a good idea whether or not you use Relay."]})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},80531:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/conceptual-graph1-a88c591f79c81af5d67b28122e17c581.png"},34776:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/conceptual-graph2-63a89a1f08749046137894e4b24774cc.png"},55905:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/conceptual-graph3-13e2ea59a6271992070d77ae4ae5e9b6.png"},38190:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/conceptual-graph4-88f27142830f48b2f0184ebcd0e9ad8d.png"},84885:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/cursor-pagination1-6c0fbda5cf31aa5f1e80fae2e304ece9.png"},99134:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/cursor-pagination2-afc854c5e10f8eb3b6ef4744d39cc467.png"},37210:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/offset-problem-59e011ffc98303c7b9d77acea08fab78.png"},64402:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/offset-problem2-62dcd9815cfbca52afbd4c1291396f13.png"},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>r});var s=t(96540);const i={},a=s.createContext(i);function o(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);