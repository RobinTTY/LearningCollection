"use strict";(self.webpackChunklearning_knowledge_base=self.webpackChunklearning_knowledge_base||[]).push([[589],{4213:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>l});var o=t(5893),i=t(1151);const s={id:"pagination",title:"Pagination",sidebar_position:7},a=void 0,r={id:"csharp/libraries/hot-chocolate/pagination",title:"Pagination",description:"HotChocolate supports both offset and cursor based pagination. The cursor based pagination is based on the Relay spec.",source:"@site/docs/csharp/libraries/hot-chocolate/pagination.md",sourceDirName:"csharp/libraries/hot-chocolate",slug:"/csharp/libraries/hot-chocolate/pagination",permalink:"/LearningCollection/csharp/libraries/hot-chocolate/pagination",draft:!1,unlisted:!1,editUrl:"https://github.com/RobinTTY/LearningCollection/tree/master/website/docs/csharp/libraries/hot-chocolate/pagination.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{id:"pagination",title:"Pagination",sidebar_position:7},sidebar:"docs",previous:{title:"Data Loaders",permalink:"/LearningCollection/csharp/libraries/hot-chocolate/data-loaders"},next:{title:"Extending Types",permalink:"/LearningCollection/csharp/libraries/hot-chocolate/advanced-concepts/extending-types"}},c={},l=[{value:"Usage",id:"usage",level:2},{value:"Naming",id:"naming",level:3},{value:"Options",id:"options",level:3},{value:"Total count",id:"total-count",level:4},{value:"Custom pagination logic",id:"custom-pagination-logic",level:2},{value:"Changing the node type",id:"changing-the-node-type",level:3},{value:"Adding fields to an Edge",id:"adding-fields-to-an-edge",level:3},{value:"Adding fields to a Connection",id:"adding-fields-to-a-connection",level:3}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",p:"p",pre:"pre",...(0,i.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.p,{children:["HotChocolate supports both offset and cursor based pagination. The cursor based pagination is based on the ",(0,o.jsx)(n.a,{href:"https://relay.dev/graphql/connections.htm",children:"Relay spec"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,o.jsxs)(n.p,{children:["To add pagination capabilities, we add the ",(0,o.jsx)(n.code,{children:"UsePaging"})," middleware:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"public class Query\n{\n    [UsePaging]\n    public IEnumerable<User> GetUsers([Service] IUserRespository repository)\n        => repository.GetUsers();\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["For the ",(0,o.jsx)(n.code,{children:"UsePaging"})," middleware to work, our resolver needs to return an ",(0,o.jsx)(n.code,{children:"IEnumerable<T>"})," or an ",(0,o.jsx)(n.code,{children:"IQueryable<T>"}),". The middleware will then apply the pagination arguments to what we have returned. In the case of an ",(0,o.jsx)(n.code,{children:"IQueryable<T>"})," this means that the pagination operations can be directly translated to native database queries. HotChocolate also offer pagination integrations for some database technologies that do not use ",(0,o.jsx)(n.code,{children:"IQueryable"}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"naming",children:"Naming"}),"\n",(0,o.jsxs)(n.p,{children:["The name of the Connection and Edge type is automatically inferred from the field name. If our field is called ",(0,o.jsx)(n.code,{children:"users"}),", a ",(0,o.jsx)(n.code,{children:"UsersConnection"})," and ",(0,o.jsx)(n.code,{children:"UsersEdge"})," type is automatically generated. We can also specify a custom name for our Connection like the following:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'public class Query\n{\n    [UsePaging(ConnectionName = "CustomUsers")]\n    public IEnumerable<User> GetUsers([Service] IUserRespository repository)\n    {\n        // Omitted code for brevity\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"options",children:"Options"}),"\n",(0,o.jsx)(n.p,{children:"We can define a number of options on a per-field basis trough properties on the attribute, e.g.:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"[UsePaging(MaxPageSize = 100)]\npublic IEnumerable<User> GetUsers([Service] IUserRespository repository)\n{\n    // Omitted code for brevity\n}\n"})}),"\n",(0,o.jsx)(n.h4,{id:"total-count",children:"Total count"}),"\n",(0,o.jsxs)(n.p,{children:["Sometimes we might want to return the total number of pageable entries. For this to work we need to enable the ",(0,o.jsx)(n.code,{children:"IncludeTotalCount"})," flag on the ",(0,o.jsx)(n.code,{children:"UsePaging"})," middleware:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"[UsePaging(IncludeTotalCount = true)]\npublic IEnumerable<User> GetUsers([Service] IUserRespository repository)\n{\n    // Omitted code for brevity\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["This will add a new field called ",(0,o.jsx)(n.code,{children:"totalCount"})," to our Connection. If our resolver returns an ",(0,o.jsx)(n.code,{children:"IEnumerable<T>"})," or an ",(0,o.jsx)(n.code,{children:"IQueryable<T>"})," the ",(0,o.jsx)(n.code,{children:"totalCount"})," will be automatically computed, if it has been specified as a subfield in the query."]}),"\n",(0,o.jsxs)(n.p,{children:["If we have customized our pagination and our resolver now returns a ",(0,o.jsx)(n.code,{children:"Connection<T>"}),", we have to explicitly declare how the ",(0,o.jsx)(n.code,{children:"totalCount"})," value is computed:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"var connection = new Connection<User>(\n    edges,\n    pageInfo,\n    getTotalCount: cancellationToken => ValueTask.FromResult(0)\n  );\n"})}),"\n",(0,o.jsx)(n.h2,{id:"custom-pagination-logic",children:"Custom pagination logic"}),"\n",(0,o.jsxs)(n.p,{children:["If we need more control over the pagination process we can do so, by returning a ",(0,o.jsx)(n.code,{children:"Connection<T>"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"{\n    [UsePaging]\n    public Connection<User> GetUsers(string? after, int? first, string sortBy)\n    {\n        // Get users using the above arguments\n        IEnumerable<User> users = null;\n\n        var edges = users.Select(user => new Edge<User>(user, user.Id))\n                            .ToList();\n        var pageInfo = new ConnectionPageInfo(false, false, null, null);\n\n        var connection = new Connection<User>(edges, pageInfo,\n                            ct => ValueTask.FromResult(0));\n\n        return connection;\n    }\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"changing-the-node-type",children:"Changing the node type"}),"\n",(0,o.jsxs)(n.p,{children:["Lets say we are returning a collection of ",(0,o.jsx)(n.code,{children:"string"})," from our pagination resolver, but we want these ",(0,o.jsx)(n.code,{children:"string"})," to be represented in the schema using the ",(0,o.jsx)(n.code,{children:"ID"})," scalar. We can change the node type like the following:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"public class Query\n{\n    [UsePaging(typeof(IdType))]\n    public IEnumerable<string> GetIds()\n    {\n        // Omitted code for brevity\n    }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The same applies of course, if we are returning a collection of ",(0,o.jsx)(n.code,{children:"User"})," from our pagination resolver, but we want to use the ",(0,o.jsx)(n.code,{children:"UserType"})," for representation in the schema."]}),"\n",(0,o.jsx)(n.h3,{id:"adding-fields-to-an-edge",children:"Adding fields to an Edge"}),"\n",(0,o.jsxs)(n.p,{children:["We can add new fields to an Edge type, by creating a type extension that targets the Edge type by its name. If our Edge is named ",(0,o.jsx)(n.code,{children:"UsersEdge"}),", we can add a new field to it like the following:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'[ExtendObjectType("UsersEdge")]\npublic class UsersEdge\n{\n    public string NewField([Parent] Edge<User> edge)\n    {\n        var cursor = edge.Cursor;\n        var user = edge.Node;\n\n        // Omitted code for brevity\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"adding-fields-to-a-connection",children:"Adding fields to a Connection"}),"\n",(0,o.jsxs)(n.p,{children:["We can add new fields to a Connection type, by creating a type extension that targets the Connection type by its name. If our Connection is named ",(0,o.jsx)(n.code,{children:"UsersConnection"}),", we can add a new field to it like the following:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'[ExtendObjectType("UsersConnection")]\npublic class UsersConnectionExtension\n{\n    public string NewField()\n    {\n        // Omitted code for brevity\n    }\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"These additional fields are great to perform aggregations either on the entire dataset, by for example issuing a second database call, or on top of the paginated result. We can access the pagination result like the following:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'[ExtendObjectType("UsersConnection")]\npublic class UsersConnectionExtension\n{\n    public string NewField([Parent] Connection<User> connection)\n    {\n        var result = connection.Edges.Sum(e => e.Node.SomeField);\n\n        // Omitted code for brevity\n    }\n}\n'})})]})}function h(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>r,a:()=>a});var o=t(7294);const i={},s=o.createContext(i);function a(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);