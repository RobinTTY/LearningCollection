"use strict";(self.webpackChunklearning_knowledge_base=self.webpackChunklearning_knowledge_base||[]).push([[6322],{2876:(e,n,l)=>{l.r(n),l.d(n,{assets:()=>i,contentTitle:()=>s,default:()=>p,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var t=l(5893),a=l(1151);const r={title:"Nullability"},s=void 0,o={id:"csharp/core-concepts/nullability",title:"Nullability",description:"In C#, the null literal is used to denote the absence of a value. A nullable type is a type that allows for null values.",source:"@site/docs/csharp/core-concepts/nullability.md",sourceDirName:"csharp/core-concepts",slug:"/csharp/core-concepts/nullability",permalink:"/LearningCollection/csharp/core-concepts/nullability",draft:!1,unlisted:!1,editUrl:"https://github.com/RobinTTY/LearningCollection/tree/master/website/docs/csharp/core-concepts/nullability.md",tags:[],version:"current",frontMatter:{title:"Nullability"},sidebar:"docs",previous:{title:"IEnumerable",permalink:"/LearningCollection/csharp/core-concepts/interfaces/ienumerable"},next:{title:"Generics",permalink:"/LearningCollection/csharp/core-concepts/generics"}},i={},c=[];function u(e){const n={admonition:"admonition",code:"code",p:"p",pre:"pre",...(0,a.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["In C#, the ",(0,t.jsx)(n.code,{children:"null"})," literal is used to denote the absence of a value. A nullable type is a type that allows for ",(0,t.jsx)(n.code,{children:"null"})," values."]}),"\n",(0,t.jsxs)(n.admonition,{type:"info",children:[(0,t.jsxs)(n.p,{children:["Prior to C# 8.0, reference types were always nullable and value types were not. A value type can be made nullable though by appending it with a question mark (",(0,t.jsx)(n.code,{children:"?"}),")."]}),(0,t.jsxs)(n.admonition,{type:"info",children:[(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'string nullableReferenceType = "hello";\nnullableReferenceType = null;   // Valid as type is nullable\n\nint nonNullableValueType = 5;\nnonNullableValueType = null;    // Compile error as type is not nullable\n\nint? nullableValueType = 5;     // Define nullable value type\nnullableValueType = null;       // Valid as type is nullable\n'})}),(0,t.jsxs)(n.p,{children:["Accessing a member of a variable which value is ",(0,t.jsx)(n.code,{children:"null"})," will compile fine, but result in a ",(0,t.jsx)(n.code,{children:"NullReferenceException"})," being thrown at runtime:"]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"string sentence = null;\n\n// Throws NullReferenceException at runtime\nsentence.Length;\n"})}),(0,t.jsx)(n.p,{children:"To counter this common type of mistake, C# 8 allows one to opt-into a feature that makes reference types non-nullable by default:"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'string nonNullableReferenceType = "book";\nnonNullableReferenceType = null;  // Compile warning (no error!)\n\nstring? nullableReferenceType = "movie";\nnullableReferenceType = null;     // Valid as type is nullable\n'})}),(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"??"})," operator allows one to return a default value when the value is ",(0,t.jsx)(n.code,{children:"null"}),":"]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'string? name1 = "John";\nname1 ?? "Paul"; // => "John"\n\nstring? name2 = null;\nname2 ?? "George"; // => "George"\n'})}),(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"?."})," operator allows one to call members safely on a possibly ",(0,t.jsx)(n.code,{children:"null"})," value:"]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'string? fruit = "apple";\nfruit?.Length; // => 5\n\nstring? vegetable = null;\nvegetable?.Length; // => null\n'})})]})]})]})}function p(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},1151:(e,n,l)=>{l.d(n,{Z:()=>o,a:()=>s});var t=l(7294);const a={},r=t.createContext(a);function s(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);