"use strict";(self.webpackChunklearning_knowledge_base=self.webpackChunklearning_knowledge_base||[]).push([[5910],{18353:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var n=t(74848),a=t(28453);const o={id:"parameter-decorators",title:"Parameter Decorators",sidebar_position:6},i=void 0,s={id:"web/typescript/decorators/parameter-decorators",title:"Parameter Decorators",description:"A Parameter Decorator is declared just before a parameter declaration. The parameter decorator is applied to the function for a class constructor or method declaration. A parameter decorator cannot be used in a declaration file, an overload, or in any other ambient context (such as in a declare class).",source:"@site/docs/web/typescript/decorators/parameter-decorators.md",sourceDirName:"web/typescript/decorators",slug:"/web/typescript/decorators/parameter-decorators",permalink:"/LearningCollection/web/typescript/decorators/parameter-decorators",draft:!1,unlisted:!1,editUrl:"https://github.com/RobinTTY/LearningCollection/tree/master/website/docs/web/typescript/decorators/parameter-decorators.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{id:"parameter-decorators",title:"Parameter Decorators",sidebar_position:6},sidebar:"docs",previous:{title:"Property Decorators",permalink:"/LearningCollection/web/typescript/decorators/property-decorators"},next:{title:"Compiler Configuration",permalink:"/LearningCollection/web/typescript/compiler-configuration"}},c={},d=[];function l(e){const r={code:"code",li:"li",ol:"ol",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(r.p,{children:["A Parameter Decorator is declared just before a parameter declaration. The parameter decorator is applied to the function for a class constructor or method declaration. A parameter decorator cannot be used in a declaration file, an overload, or in any other ambient context (such as in a ",(0,n.jsx)(r.code,{children:"declare"})," class)."]}),"\n",(0,n.jsx)(r.p,{children:"The expression for the parameter decorator will be called as a function at runtime, with the following three arguments:"}),"\n",(0,n.jsxs)(r.ol,{children:["\n",(0,n.jsx)(r.li,{children:"Either the constructor function of the class for a static member, or the prototype of the class for an instance member"}),"\n",(0,n.jsx)(r.li,{children:"The name of the member"}),"\n",(0,n.jsx)(r.li,{children:"The ordinal index of the parameter in the function\u2019s parameter list"}),"\n"]}),"\n",(0,n.jsx)(r.p,{children:"The return value of the parameter decorator is ignored."}),"\n",(0,n.jsxs)(r.p,{children:["he following is an example of a parameter decorator (",(0,n.jsx)(r.code,{children:"@required"}),") applied to parameter of a member of the ",(0,n.jsx)(r.code,{children:"BugReport"})," class:"]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-ts",children:'class BugReport {\n  type = "report";\n  title: string;\n\n  constructor(t: string) {\n    this.title = t;\n  }\n\n  @validate\n  print(@required verbose: boolean) {\n    if (verbose) {\n      return `type: ${this.type}\\ntitle: ${this.title}`;\n    } else {\n      return this.title;\n    }\n  }\n}\n'})}),"\n",(0,n.jsxs)(r.p,{children:["We can then define the ",(0,n.jsx)(r.code,{children:"@required"})," and ",(0,n.jsx)(r.code,{children:"@validate"})," decorators using the following function declarations:"]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-ts",children:'import "reflect-metadata";\nconst requiredMetadataKey = Symbol("required");\n\nfunction required(\n  target: Object,\n  propertyKey: string | symbol,\n  parameterIndex: number\n) {\n  let existingRequiredParameters: number[] =\n    Reflect.getOwnMetadata(requiredMetadataKey, target, propertyKey) || [];\n  existingRequiredParameters.push(parameterIndex);\n  Reflect.defineMetadata(\n    requiredMetadataKey,\n    existingRequiredParameters,\n    target,\n    propertyKey\n  );\n}\n\nfunction validate(\n  target: any,\n  propertyName: string,\n  descriptor: TypedPropertyDescriptor<Function>\n) {\n  let method = descriptor.value!;\n\n  descriptor.value = function () {\n    let requiredParameters: number[] = Reflect.getOwnMetadata(\n      requiredMetadataKey,\n      target,\n      propertyName\n    );\n    if (requiredParameters) {\n      for (let parameterIndex of requiredParameters) {\n        if (\n          parameterIndex >= arguments.length ||\n          arguments[parameterIndex] === undefined\n        ) {\n          throw new Error("Missing required argument.");\n        }\n      }\n    }\n    return method.apply(this, arguments);\n  };\n}\n'})}),"\n",(0,n.jsxs)(r.p,{children:["The ",(0,n.jsx)(r.code,{children:"@required"})," decorator adds a metadata entry that marks the parameter as required. The ",(0,n.jsx)(r.code,{children:"@validate"})," decorator then wraps the existing ",(0,n.jsx)(r.code,{children:"greet"})," method in a function that validates the arguments before invoking the original method."]})]})}function p(e={}){const{wrapper:r}={...(0,a.R)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},28453:(e,r,t)=>{t.d(r,{R:()=>i,x:()=>s});var n=t(96540);const a={},o=n.createContext(a);function i(e){const r=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function s(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),n.createElement(o.Provider,{value:r},e.children)}}}]);