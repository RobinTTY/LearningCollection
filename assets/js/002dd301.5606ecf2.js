"use strict";(self.webpackChunklearning_knowledge_base=self.webpackChunklearning_knowledge_base||[]).push([[8935],{58529:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>s,metadata:()=>o,toc:()=>d});var a=n(74848),i=n(28453);const s={title:"Updating Data"},r=void 0,o={id:"csharp/entity-framework/querying-data/updating-data",title:"Updating Data",description:"There are multiple ways to update data in EF Core. The simplest way may be to query the data to update first and then to update it in a second operation:",source:"@site/docs/csharp/entity-framework/querying-data/updating-data.md",sourceDirName:"csharp/entity-framework/querying-data",slug:"/csharp/entity-framework/querying-data/updating-data",permalink:"/LearningCollection/csharp/entity-framework/querying-data/updating-data",draft:!1,unlisted:!1,editUrl:"https://github.com/RobinTTY/LearningCollection/tree/master/website/docs/csharp/entity-framework/querying-data/updating-data.md",tags:[],version:"current",frontMatter:{title:"Updating Data"},sidebar:"docs",previous:{title:"Inserting Data",permalink:"/LearningCollection/csharp/entity-framework/querying-data/inserting-data"},next:{title:"Deleting Data",permalink:"/LearningCollection/csharp/entity-framework/querying-data/deleting-data"}},l={},d=[{value:"Efficient updating using <code>ExecuteUpdate</code>",id:"efficient-updating-using-executeupdate",level:2},{value:"Updating multiple properties",id:"updating-multiple-properties",level:3},{value:"Referencing the existing property value",id:"referencing-the-existing-property-value",level:3},{value:"Navigations and related entities",id:"navigations-and-related-entities",level:3}];function c(e){const t={code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:"There are multiple ways to update data in EF Core. The simplest way may be to query the data to update first and then to update it in a second operation:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'var author = _context.Authors.FirstOrDefault(a => a.FirstName == "Julie" && a.LastName == "Lerman");\n\nif(author != null)\n{\n  author.FirstName = "Julia";\n  _context.SaveChanges();\n}\n'})}),"\n",(0,a.jsxs)(t.h2,{id:"efficient-updating-using-executeupdate",children:["Efficient updating using ",(0,a.jsx)(t.code,{children:"ExecuteUpdate"})]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.code,{children:"ExecuteUpdate"})," provides a similar way to express a SQL ",(0,a.jsx)(t.code,{children:"UPDATE"})," statement:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:"context.Blogs\n    .Where(b => b.Rating < 3)\n    .ExecuteUpdate(setters => setters.SetProperty(b => b.IsVisible, false));\n"})}),"\n",(0,a.jsxs)(t.p,{children:["We first use LINQ to determine which Blogs should be affected, then need to express the change to be applied to the matching Blogs. This is done by calling ",(0,a.jsx)(t.code,{children:"SetProperty"})," within the ",(0,a.jsx)(t.code,{children:"ExecuteUpdate"})," call, and providing it with two arguments: the property to be changed (",(0,a.jsx)(t.code,{children:"IsVisible"}),"), and the new value it should have (",(0,a.jsx)(t.code,{children:"false"}),"). This causes the following SQL to be executed:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:"UPDATE [b]\nSET [b].[IsVisible] = CAST(0 AS bit)\nFROM [Blogs] AS [b]\nWHERE [b].[Rating] < 3\n"})}),"\n",(0,a.jsx)(t.h3,{id:"updating-multiple-properties",children:"Updating multiple properties"}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.code,{children:"ExecuteUpdate"})," allows updating multiple properties in a single invocation. For example, to both set ",(0,a.jsx)(t.code,{children:"IsVisible"})," to false and to set Rating to zero, simply chain additional ",(0,a.jsx)(t.code,{children:"SetProperty"})," calls together:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:"context.Blogs\n    .Where(b => b.Rating < 3)\n    .ExecuteUpdate(setters => setters\n        .SetProperty(b => b.IsVisible, false)\n        .SetProperty(b => b.Rating, 0));\n"})}),"\n",(0,a.jsx)(t.p,{children:"This executes the following SQL:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:"UPDATE [b]\nSET [b].[Rating] = 0,\n    [b].[IsVisible] = CAST(0 AS bit)\nFROM [Blogs] AS [b]\nWHERE [b].[Rating] < 3\n"})}),"\n",(0,a.jsx)(t.h3,{id:"referencing-the-existing-property-value",children:"Referencing the existing property value"}),"\n",(0,a.jsxs)(t.p,{children:["The above examples updated the property to a new constant value. ",(0,a.jsx)(t.code,{children:"ExecuteUpdate"})," also allows referencing the existing property value when calculating the new value; for example, to increase the rating of all matching Blogs by one, use the following:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:"context.Blogs\n    .Where(b => b.Rating < 3)\n    .ExecuteUpdate(setters => setters.SetProperty(b => b.Rating, b => b.Rating + 1));\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Note that the second argument to ",(0,a.jsx)(t.code,{children:"SetProperty"})," is now a lambda function, and not a constant as before. Its ",(0,a.jsx)(t.code,{children:"b"})," parameter represents the ",(0,a.jsx)(t.code,{children:"Blog"})," being updated; within that lambda, ",(0,a.jsx)(t.code,{children:"b.Rating"})," thus contains the rating before any change occurred. This executes the following SQL:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:"UPDATE [b]\nSET [b].[Rating] = [b].[Rating] + 1\nFROM [Blogs] AS [b]\nWHERE [b].[Rating] < 3\n"})}),"\n",(0,a.jsx)(t.h3,{id:"navigations-and-related-entities",children:"Navigations and related entities"}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.code,{children:"ExecuteUpdate"})," does not currently support referencing navigations within the ",(0,a.jsx)(t.code,{children:"SetProperty"})," lambda. For example, let's say we want to update all the Blogs' ratings so that each Blog's new rating is the average of all its Posts' ratings. We may try to use ",(0,a.jsx)(t.code,{children:"ExecuteUpdate"})," as follows:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:"context.Blogs.ExecuteUpdate(\n    setters => setters.SetProperty(b => b.Rating, b => b.Posts.Average(p => p.Rating)));\n"})}),"\n",(0,a.jsxs)(t.p,{children:["However, EF does allow performing this operation by first using ",(0,a.jsx)(t.code,{children:"Select"})," to calculate the average rating and project it to an anonymous type, and then using ",(0,a.jsx)(t.code,{children:"ExecuteUpdate"})," over that:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:"context.Blogs\n    .Select(b => new { Blog = b, NewRating = b.Posts.Average(p => p.Rating) })\n    .ExecuteUpdate(setters => setters.SetProperty(b => b.Blog.Rating, b => b.NewRating));\n"})})]})}function p(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>o});var a=n(96540);const i={},s=a.createContext(i);function r(e){const t=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(s.Provider,{value:t},e.children)}}}]);