"use strict";(self.webpackChunklearning_knowledge_base=self.webpackChunklearning_knowledge_base||[]).push([[9408],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},f=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,s=e.originalType,l=e.parentName,u=r(e,["components","mdxType","originalType","parentName"]),p=c(n),f=o,m=p["".concat(l,".").concat(f)]||p[f]||d[f]||s;return n?a.createElement(m,i(i({ref:t},u),{},{components:n})):a.createElement(m,i({ref:t},u))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var s=n.length,i=new Array(s);i[0]=f;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r[p]="string"==typeof e?e:o,i[1]=r;for(var c=2;c<s;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}f.displayName="MDXCreateElement"},8539:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>s,metadata:()=>r,toc:()=>c});var a=n(7462),o=(n(7294),n(3905));const s={id:"useEffect",title:"useEffect",sidebar_position:2},i=void 0,r={unversionedId:"web/react/hooks/useEffect",id:"web/react/hooks/useEffect",title:"useEffect",description:'The Effect Hook lets you perform side effects in function components. Data fetching, setting up a subscription, storing data in browser storage, and manually changing the DOM in React components are all examples of side effects. Whether or not you\u2019re used to calling these operations "side effects" (or just "effects"), you\u2019ve likely performed them in your components before.',source:"@site/docs/web/react/hooks/useEffect.md",sourceDirName:"web/react/hooks",slug:"/web/react/hooks/useEffect",permalink:"/LearningCollection/web/react/hooks/useEffect",draft:!1,editUrl:"https://github.com/RobinTTY/LearningCollection/tree/master/website/docs/web/react/hooks/useEffect.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{id:"useEffect",title:"useEffect",sidebar_position:2},sidebar:"finance",previous:{title:"useState",permalink:"/LearningCollection/web/react/hooks/useState"},next:{title:"useContext",permalink:"/LearningCollection/web/react/hooks/useContext"}},l={},c=[{value:"Using the effect hook",id:"using-the-effect-hook",level:2},{value:"Effects without cleanup",id:"effects-without-cleanup",level:3},{value:"Example using classes",id:"example-using-classes",level:4},{value:"Example using hooks",id:"example-using-hooks",level:4},{value:"Effects with cleanup",id:"effects-with-cleanup",level:3},{value:"Example using classes",id:"example-using-classes-1",level:4},{value:"Example using hooks",id:"example-using-hooks-1",level:4},{value:"Tips for using effects",id:"tips-for-using-effects",level:2},{value:"Use multiple effects to separate concerns",id:"use-multiple-effects-to-separate-concerns",level:3},{value:"Optimizing performance by skipping effects",id:"optimizing-performance-by-skipping-effects",level:3},{value:"Using timeouts to optimize performance",id:"using-timeouts-to-optimize-performance",level:3}],u={toc:c},p="wrapper";function d(e){let{components:t,...n}=e;return(0,o.kt)(p,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"The Effect Hook lets you perform side effects in function components. ",(0,o.kt)("strong",{parentName:"p"},"Data fetching, setting up a subscription, storing data in browser storage, and manually changing the DOM")," in React components are all ",(0,o.kt)("strong",{parentName:"p"},"examples of side effects"),'. Whether or not you\u2019re used to calling these operations "side effects" (or just "effects"), you\u2019ve likely performed them in your components before.'),(0,o.kt)("h2",{id:"using-the-effect-hook"},"Using the effect hook"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},'import React, { useState, useEffect } from "react";\n\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  // Similar to componentDidMount and componentDidUpdate:\n  useEffect(() => {\n    // Update the document title using the browser API\n    document.title = `You clicked ${count} times`;\n  });\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>Click me</button>\n    </div>\n  );\n}\n')),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"You can think of useEffect Hook as ",(0,o.kt)("inlineCode",{parentName:"p"},"componentDidMount"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"componentDidUpdate"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"componentWillUnmount")," combined.")),(0,o.kt)("p",null,"There are two common kinds of side effects in React components: those that don\u2019t require cleanup, and those that do. Let\u2019s look at this distinction in more detail."),(0,o.kt)("h3",{id:"effects-without-cleanup"},"Effects without cleanup"),(0,o.kt)("p",null,"Sometimes, we want to ",(0,o.kt)("strong",{parentName:"p"},"run some additional code after React has updated the DOM"),". Network requests, manual DOM mutations, and logging are common examples of effects that don\u2019t require a cleanup. Thats because we can run them and immediately forget about them. Let\u2019s compare how classes and Hooks let us express such side effects."),(0,o.kt)("h4",{id:"example-using-classes"},"Example using classes"),(0,o.kt)("p",null,"In React class components, the ",(0,o.kt)("inlineCode",{parentName:"p"},"render")," method itself shouldn\u2019t cause side effects. It would be too early \u2014 we typically want to perform our effects after React has updated the DOM."),(0,o.kt)("p",null,"This is why in React classes, we put side effects into ",(0,o.kt)("inlineCode",{parentName:"p"},"componentDidMount")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"componentDidUpdate"),". Coming back to our example, here is a React counter class component that updates the document title right after React makes changes to the DOM:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"{9-14}","{9-14}":!0},"class Example extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0,\n    };\n  }\n\n  componentDidMount() {\n    document.title = `You clicked ${this.state.count} times`;\n  }\n  componentDidUpdate() {\n    document.title = `You clicked ${this.state.count} times`;\n  }\n\n  render() {\n    return (\n      <div>\n        <p>You clicked {this.state.count} times</p>\n        <button onClick={() => this.setState({ count: this.state.count + 1 })}>\n          Click me\n        </button>\n      </div>\n    );\n  }\n}\n")),(0,o.kt)("p",null,"Note how ",(0,o.kt)("strong",{parentName:"p"},"we have to duplicate the code between these two lifecycle methods")," in class. This is because in many cases we want to perform the same side effect regardless of whether the component just mounted, or if it has been updated. Conceptually, we want it to happen after every render \u2014 but React class components don\u2019t have a method like this. We could extract a separate method but we would still have to call it in two places."),(0,o.kt)("h4",{id:"example-using-hooks"},"Example using hooks"),(0,o.kt)("p",null,"We\u2019ve already seen this example at the top of this page, but let\u2019s take a closer look at it:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"{1,6-8}","{1,6-8}":!0},'import React, { useState, useEffect } from "react";\n\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    document.title = `You clicked ${count} times`;\n  });\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>Click me</button>\n    </div>\n  );\n}\n')),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"What does useEffect do?:"),' By using this Hook, you tell React that your component needs to do something after render. React will remember the function you passed (we\u2019ll refer to it as our "effect"), and call it later after performing the DOM updates. In this effect, we set the document title, but we could also perform data fetching or call some other imperative API.'),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Why is useEffect called inside a component?:")," Placing ",(0,o.kt)("inlineCode",{parentName:"li"},"useEffect")," inside the component lets us access the ",(0,o.kt)("inlineCode",{parentName:"li"},"count")," state variable (or any props) right from the effect. We don\u2019t need a special API to read it \u2014 it\u2019s already in the function scope. Hooks embrace JavaScript closures and avoid introducing React-specific APIs where JavaScript already provides a solution."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Does useEffect run after every render?:"),' Yes! By default, it runs both after the first render and after every update. Instead of thinking in terms of "mounting" and "updating", you might find it easier to think that effects happen "after render". React guarantees the DOM has been updated by the time it runs the effects.')),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"Unlike ",(0,o.kt)("inlineCode",{parentName:"p"},"componentDidMount")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"componentDidUpdate"),", effects scheduled with useEffect don\u2019t block the browser from updating the screen. This makes your app feel more responsive. The majority of effects don\u2019t need to happen synchronously. In the uncommon cases where they do (such as measuring the layout), there is a separate ",(0,o.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/hooks-reference.html#uselayouteffect"},"useLayoutEffect")," Hook with an API identical to ",(0,o.kt)("inlineCode",{parentName:"p"},"useEffect"),".")),(0,o.kt)("h3",{id:"effects-with-cleanup"},"Effects with cleanup"),(0,o.kt)("p",null,"Some effects require cleanup. For example, ",(0,o.kt)("strong",{parentName:"p"},"we might want to set up a subscription")," to some external data source. In that case, it is important to clean up so that we don\u2019t introduce a memory leak! Let\u2019s compare how we can do it with classes and with Hooks."),(0,o.kt)("h4",{id:"example-using-classes-1"},"Example using classes"),(0,o.kt)("p",null,"In a React class, you would typically set up a subscription in ",(0,o.kt)("inlineCode",{parentName:"p"},"componentDidMount"),", and clean it up in ",(0,o.kt)("inlineCode",{parentName:"p"},"componentWillUnmount"),". For example, let\u2019s say we have a ",(0,o.kt)("inlineCode",{parentName:"p"},"ChatAPI")," module that lets us subscribe to a friend\u2019s online status. Here\u2019s how we might subscribe and display that status using a class:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"{8-24}","{8-24}":!0},'class FriendStatus extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { isOnline: null };\n    this.handleStatusChange = this.handleStatusChange.bind(this);\n  }\n\n  componentDidMount() {\n    ChatAPI.subscribeToFriendStatus(\n      this.props.friend.id,\n      this.handleStatusChange\n    );\n  }\n  componentWillUnmount() {\n    ChatAPI.unsubscribeFromFriendStatus(\n      this.props.friend.id,\n      this.handleStatusChange\n    );\n  }\n  handleStatusChange(status) {\n    this.setState({\n      isOnline: status.isOnline,\n    });\n  }\n\n  render() {\n    if (this.state.isOnline === null) {\n      return "Loading...";\n    }\n    return this.state.isOnline ? "Online" : "Offline";\n  }\n}\n')),(0,o.kt)("p",null,"Notice how ",(0,o.kt)("inlineCode",{parentName:"p"},"componentDidMount")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"componentWillUnmount")," need to mirror each other. Lifecycle methods force us to split this logic even though conceptually code in both of them is related to the same effect."),(0,o.kt)("h4",{id:"example-using-hooks-1"},"Example using hooks"),(0,o.kt)("p",null,"Code for adding and removing a subscription is so tightly related that ",(0,o.kt)("inlineCode",{parentName:"p"},"useEffect")," is designed to keep it together. If your effect returns a function, React will run it when it is time to clean up:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"{6-15}","{6-15}":!0},'import React, { useState, useEffect } from "react";\n\nfunction FriendStatus(props) {\n  const [isOnline, setIsOnline] = useState(null);\n\n  useEffect(() => {\n    function handleStatusChange(status) {\n      setIsOnline(status.isOnline);\n    }\n    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n    // Specify how to clean up after this effect:\n    return function cleanup() {\n      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n    };\n  });\n\n  if (isOnline === null) {\n    return "Loading...";\n  }\n  return isOnline ? "Online" : "Offline";\n}\n')),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Why did we return a function from our effect?"),": This is the optional cleanup mechanism for effects. Every effect may return a function that cleans up after it. This lets us keep the logic for adding and removing subscriptions close to each other. They\u2019re part of the same effect!"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"When exactly does React clean up an effect?")," React performs the cleanup when the component unmounts. However, as we learned earlier, effects run for every render and not just once. This is why React also cleans up effects from the previous render before running the effects next time. This helps avoid bugs and can be opted out of in case it creates performance issues later.")),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"We don\u2019t have to return a named function from the effect (like we did here with ",(0,o.kt)("inlineCode",{parentName:"p"},"effect"),"). We can also return an arrow function or call it something different.")),(0,o.kt)("h2",{id:"tips-for-using-effects"},"Tips for using effects"),(0,o.kt)("h3",{id:"use-multiple-effects-to-separate-concerns"},"Use multiple effects to separate concerns"),(0,o.kt)("p",null,"Class lifecycle methods often contain unrelated logic, but related logic gets broken up into several methods. Here is a component that combines the counter and the friend status indicator logic from the previous examples:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"class FriendStatusWithCounter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0, isOnline: null };\n    this.handleStatusChange = this.handleStatusChange.bind(this);\n  }\n\n  componentDidMount() {\n    document.title = `You clicked ${this.state.count} times`;\n    ChatAPI.subscribeToFriendStatus(\n      this.props.friend.id,\n      this.handleStatusChange\n    );\n  }\n\n  componentDidUpdate() {\n    document.title = `You clicked ${this.state.count} times`;\n  }\n\n  componentWillUnmount() {\n    ChatAPI.unsubscribeFromFriendStatus(\n      this.props.friend.id,\n      this.handleStatusChange\n    );\n  }\n\n  handleStatusChange(status) {\n    this.setState({\n      isOnline: status.isOnline\n    });\n  }\n  // ...\n")),(0,o.kt)("p",null,"Note how the logic that sets ",(0,o.kt)("inlineCode",{parentName:"p"},"document.title")," is split between ",(0,o.kt)("inlineCode",{parentName:"p"},"componentDidMount")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"componentDidUpdate"),". The subscription logic is also spread between ",(0,o.kt)("inlineCode",{parentName:"p"},"componentDidMount")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"componentWillUnmount"),". And ",(0,o.kt)("inlineCode",{parentName:"p"},"componentDidMount")," contains code for both tasks."),(0,o.kt)("p",null,"So, how can Hooks solve this problem? Just like you can use the State Hook more than once, you can also use several effects. This lets us separate unrelated logic into different effects:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"{3,8}","{3,8}":!0},"function FriendStatusWithCounter(props) {\n  const [count, setCount] = useState(0);\n  useEffect(() => {\n    document.title = `You clicked ${count} times`;\n  });\n\n  const [isOnline, setIsOnline] = useState(null);\n  useEffect(() => {\n    function handleStatusChange(status) {\n      setIsOnline(status.isOnline);\n    }\n\n    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n    return () => {\n      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n    };\n  });\n  // ...\n}\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Hooks let us split the code based on what it is doing")," rather than a lifecycle method name. React will apply every effect used by the component, in the order they were specified."),(0,o.kt)("h3",{id:"optimizing-performance-by-skipping-effects"},"Optimizing performance by skipping effects"),(0,o.kt)("p",null,"In some cases, ",(0,o.kt)("strong",{parentName:"p"},"cleaning up or applying the effect after every render might create a performance problem"),". You can tell React to skip applying an effect if certain values haven\u2019t changed between re-renders. To do so, pass an array as an optional second argument to ",(0,o.kt)("inlineCode",{parentName:"p"},"useEffect"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"{3}","{3}":!0},"useEffect(() => {\n  document.title = `You clicked ${count} times`;\n}, [count]); // Only re-run the effect if count changes\n")),(0,o.kt)("p",null,"In the example above, we pass ",(0,o.kt)("inlineCode",{parentName:"p"},"[count]")," as the second argument. What does this mean? If the ",(0,o.kt)("inlineCode",{parentName:"p"},"count")," is ",(0,o.kt)("inlineCode",{parentName:"p"},"5"),", and then our component re-renders with ",(0,o.kt)("inlineCode",{parentName:"p"},"count")," still equal to ",(0,o.kt)("inlineCode",{parentName:"p"},"5"),", React will compare ",(0,o.kt)("inlineCode",{parentName:"p"},"[5]")," from the previous render and ",(0,o.kt)("inlineCode",{parentName:"p"},"[5]")," from the next render. Because all items in the array are the same ",(0,o.kt)("inlineCode",{parentName:"p"},"(5 === 5)"),", React would skip the effect. If there are multiple items in the array, React will re-run the effect even if just one of them is different."),(0,o.kt)("p",null,"This also works for effects that have a cleanup phase:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"{10}","{10}":!0},"useEffect(() => {\n  function handleStatusChange(status) {\n    setIsOnline(status.isOnline);\n  }\n\n  ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n  return () => {\n    ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n  };\n}, [props.friend.id]); // Only re-subscribe if props.friend.id changes\n")),(0,o.kt)("p",null,"If you want to run an effect and clean it up only once (on mount and unmount), you can pass an empty array (",(0,o.kt)("inlineCode",{parentName:"p"},"[]"),") as a second argument."),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"Make sure the array includes ",(0,o.kt)("strong",{parentName:"p"},"all values from the component scope (such as props and state) that change over time and that are used by the effect.")," Otherwise, your code will reference stale values from previous renders. Using the ",(0,o.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/eslint-plugin-react-hooks#installation"},"eslint-hooks-plugin")," is recommended to warn against incorrectly applied dependencies.")),(0,o.kt)("h3",{id:"using-timeouts-to-optimize-performance"},"Using timeouts to optimize performance"),(0,o.kt)("p",null,"If we still run into performance problems after specifying dependencies, we can use timeouts to try and eliminate these problems. This is useful for instance if an effect is run repeatedly, due to user interaction. For example, we can use a timeout to run the effect only after 500ms and if the user triggers the effect again in that time period, the execution of the last one will be cancelled and the new one will wait 500ms again before executing."),(0,o.kt)("p",null,"Here is a small example used for form validation:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"{3,6,10}","{3,6,10}":!0},'// ...\nuseEffect(() => {\n  const identifier = setTimeout(() => {\n    console.log("Checking form validity!");\n    setFormIsValid(emailIsValid && passwordIsValid);\n  }, 500);\n\n  return () => {\n    console.log("CLEANUP");\n    clearTimeout(identifier);\n  };\n}, [emailIsValid, passwordIsValid]);\n// ...\n')),(0,o.kt)("p",null,"The cleanup method of the effect will run before the effect is re-executed, therefore canceling the form validation by clearing the timeout. If the user stops changing both fields (email and password) the validation will run after 500ms. For cases like basic form validation this optimization is not necessary but it can become interesting for more performance hungry effects, which shouldn't be executed too often."))}d.isMDXComponent=!0}}]);