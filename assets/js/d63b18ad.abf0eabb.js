"use strict";(self.webpackChunklearning_knowledge_base=self.webpackChunklearning_knowledge_base||[]).push([[3858],{6422:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>a,metadata:()=>o,toc:()=>l});var r=t(4848),s=t(8453);const a={id:"index-signatures",title:"Index Signatures",sidebar_position:4},i=void 0,o={id:"web/typescript/advanced-concepts/index-signatures",title:"Index Signatures",description:"Sometimes you don\u2019t know all the names of a type\u2019s properties ahead of time, but you do know the shape of the values. In those cases you can use an index signature to describe the types of possible values, for example:",source:"@site/docs/web/typescript/advanced-concepts/index-signatures.md",sourceDirName:"web/typescript/advanced-concepts",slug:"/web/typescript/advanced-concepts/index-signatures",permalink:"/LearningCollection/web/typescript/advanced-concepts/index-signatures",draft:!1,unlisted:!1,editUrl:"https://github.com/RobinTTY/LearningCollection/tree/master/website/docs/web/typescript/advanced-concepts/index-signatures.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{id:"index-signatures",title:"Index Signatures",sidebar_position:4},sidebar:"docs",previous:{title:"Discriminated Unions",permalink:"/LearningCollection/web/typescript/advanced-concepts/discriminated-unions"},next:{title:"Optional Chaining",permalink:"/LearningCollection/web/typescript/advanced-concepts/optional-chaining"}},c={},l=[{value:"Properties",id:"properties",level:2},{value:"When to use Index Signatures",id:"when-to-use-index-signatures",level:2}];function d(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Sometimes you don\u2019t know all the names of a type\u2019s properties ahead of time, but you do know the shape of the values. In those cases you can use an index signature to describe the types of possible values, for example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"interface StringArray {\n  [index: number]: string;\n}\n \nconst myArray: StringArray = getStringArray();\nconst secondItem = myArray[1]; // secondItem is a string\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Above, we have a ",(0,r.jsx)(n.code,{children:"StringArray"})," interface which has an index signature. This index signature states that when a ",(0,r.jsx)(n.code,{children:"StringArray"})," is indexed with a ",(0,r.jsx)(n.code,{children:"number"}),", it will return a ",(0,r.jsx)(n.code,{children:"string"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Only some types are allowed for index signature properties: ",(0,r.jsx)(n.code,{children:"string"}),", ",(0,r.jsx)(n.code,{children:"number"}),", ",(0,r.jsx)(n.code,{children:"symbol"}),", template string patterns, and union types consisting only of these."]}),"\n",(0,r.jsx)(n.h2,{id:"properties",children:"Properties"}),"\n",(0,r.jsx)(n.p,{children:"While string index signatures are a powerful way to describe the \u201cdictionary\u201d pattern, they also enforce that all properties match their return type:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"interface NumberDictionary {\n  [index: string]: number;\n \n  length: number; // ok\n  name: string; // Error: Property 'name' of type 'string' is not assignable to 'string' index type 'number'\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"However, properties of different types are acceptable if the index signature is a union of the property types:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"interface NumberOrStringDictionary {\n  [index: string]: number | string;\n  length: number; // ok, length is a number\n  name: string; // ok, name is a string\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Finally, you can make index signatures readonly in order to prevent assignment to their indices:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"interface ReadonlyStringArray {\n  readonly [index: number]: string;\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"when-to-use-index-signatures",children:"When to use Index Signatures"}),"\n",(0,r.jsx)(n.p,{children:"Imagine you have 2 objects describing the salary of two employees:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"const salary1 = {\n  salary: 55_000,\n  bonus: 5_000\n};\n \nconst salary2 = {\n  contractSalary: 75_000\n};\n"})}),"\n",(0,r.jsx)(n.p,{children:"You want to implement a function that returns the total remuneration based on the salary object:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function totalSalary(salaryObject: ???) {\n  let total = 0;\n  for (const name in salaryObject) {\n    total += salaryObject[name];\n  }\n  return total;\n}\ntotalSalary(salary1); // => 60 000\ntotalSalary(salary2); // => 75 000\n"})}),"\n",(0,r.jsx)(n.p,{children:"In this case an index signature fits perfectly:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function totalSalary(salaryObject: { [key: string]: number }) {\n  let total = 0;\n  for (const name in salaryObject) {\n    total += salaryObject[name];\n  }\n  return total;\n}\n \ntotalSalary(salary1); // => 60 000\ntotalSalary(salary2); // => 75 000\n"})})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var r=t(6540);const s={},a=r.createContext(s);function i(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);