"use strict";(self.webpackChunklearning_knowledge_base=self.webpackChunklearning_knowledge_base||[]).push([[5859],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var u=r.createContext({}),c=function(e){var t=r.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(u.Provider,{value:t},e.children)},l="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,u=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),l=c(n),m=a,h=l["".concat(u,".").concat(m)]||l[m]||d[m]||o;return n?r.createElement(h,i(i({ref:t},p),{},{components:n})):r.createElement(h,i({ref:t},p))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=m;var s={};for(var u in t)hasOwnProperty.call(t,u)&&(s[u]=t[u]);s.originalType=e,s[l]="string"==typeof e?e:a,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},4118:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var r=n(7462),a=(n(7294),n(3905));const o={id:"keeping-components-pure",title:"Keeping Components Pure",sidebar_position:7},i=void 0,s={unversionedId:"web/react/main-concepts/describing-ui/keeping-components-pure",id:"web/react/main-concepts/describing-ui/keeping-components-pure",title:"Keeping Components Pure",description:"Some JavaScript functions are pure. Pure functions only perform a calculation and nothing more. By strictly only writing your components as pure functions, you can avoid an entire class of baffling bugs and unpredictable behavior as your codebase grows. To get these benefits, though, there are a few rules you must follow.",source:"@site/docs/web/react/main-concepts/describing-ui/keeping-components-pure.md",sourceDirName:"web/react/main-concepts/describing-ui",slug:"/web/react/main-concepts/describing-ui/keeping-components-pure",permalink:"/LearningCollection/web/react/main-concepts/describing-ui/keeping-components-pure",draft:!1,editUrl:"https://github.com/RobinTTY/LearningCollection/tree/master/website/docs/web/react/main-concepts/describing-ui/keeping-components-pure.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{id:"keeping-components-pure",title:"Keeping Components Pure",sidebar_position:7},sidebar:"finance",previous:{title:"Rendering Lists",permalink:"/LearningCollection/web/react/main-concepts/describing-ui/rendering-lists"},next:{title:"Styling Components",permalink:"/LearningCollection/web/react/main-concepts/stylingComponents"}},u={},c=[{value:"Purity: Components as formulas",id:"purity-components-as-formulas",level:2},{value:"Side Effects: (un)intended consequences",id:"side-effects-unintended-consequences",level:2},{value:"Detecting impure calculations with StrictMode",id:"detecting-impure-calculations-with-strictmode",level:2},{value:"Local mutation: Your component\u2019s little secret",id:"local-mutation-your-components-little-secret",level:2},{value:"Where you can cause side effects",id:"where-you-can-cause-side-effects",level:2},{value:"Why does React care about purity?",id:"why-does-react-care-about-purity",level:2}],p={toc:c},l="wrapper";function d(e){let{components:t,...n}=e;return(0,a.kt)(l,(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Some JavaScript functions are pure. Pure functions only perform a calculation and nothing more. By strictly only writing your components as pure functions, you can avoid an entire class of baffling bugs and unpredictable behavior as your codebase grows. To get these benefits, though, there are a few rules you must follow."),(0,a.kt)("h2",{id:"purity-components-as-formulas"},"Purity: Components as formulas"),(0,a.kt)("p",null,"In computer science (and especially the world of functional programming), ",(0,a.kt)("a",{parentName:"p",href:"https://wikipedia.org/wiki/Pure_function"},"a pure function")," is a function with the following characteristics:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"It minds its own business.")," It does not change any objects or variables that existed before it was called."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Same inputs, same output.")," Given the same inputs, a pure function should always return the same result.")),(0,a.kt)("p",null,"React is designed around this concept. ",(0,a.kt)("strong",{parentName:"p"},"React assumes that every component you write is a pure function.")," This means that React components you write must always return the same JSX given the same inputs."),(0,a.kt)("h2",{id:"side-effects-unintended-consequences"},"Side Effects: (un)intended consequences"),(0,a.kt)("p",null,"React\u2019s rendering process must always be pure. Components should only return their JSX, and not change any objects or variables that existed before rendering\u2014that would make them impure!"),(0,a.kt)("p",null,"Here is a component that breaks this rule:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"let guest = 0;\n\nfunction Cup() {\n  // Bad: changing a preexisting variable!\n  guest = guest + 1;\n  return <h2>Tea cup for guest #{guest}</h2>;\n}\n\nexport default function TeaSet() {\n  return (\n    <>\n      <Cup />\n      <Cup />\n      <Cup />\n    </>\n  );\n}\n")),(0,a.kt)("p",null,"This component is reading and writing a ",(0,a.kt)("inlineCode",{parentName:"p"},"guest")," variable declared outside of it. This means that calling this component multiple times will produce different JSX! And what\u2019s more, if other components read ",(0,a.kt)("inlineCode",{parentName:"p"},"guest"),", they will produce different JSX, too, depending on when they were rendered! That\u2019s not predictable."),(0,a.kt)("p",null,"You can fix this component by passing ",(0,a.kt)("inlineCode",{parentName:"p"},"guest")," as a prop instead:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"function Cup({ guest }) {\n  return <h2>Tea cup for guest #{guest}</h2>;\n}\n\nexport default function TeaSet() {\n  return (\n    <>\n      <Cup guest={1} />\n      <Cup guest={2} />\n      <Cup guest={3} />\n    </>\n  );\n}\n")),(0,a.kt)("p",null,"Now your component is pure, as the JSX it returns only depends on the ",(0,a.kt)("inlineCode",{parentName:"p"},"guest")," prop. In general, you should not expect your components to be rendered in any particular order."),(0,a.kt)("h2",{id:"detecting-impure-calculations-with-strictmode"},"Detecting impure calculations with StrictMode"),(0,a.kt)("p",null,"In React there are three kinds of inputs that you can read while rendering: ",(0,a.kt)("inlineCode",{parentName:"p"},"props"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"state"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"context"),". You should always treat these inputs as read-only. When you want to change something in response to user input, you should ",(0,a.kt)("inlineCode",{parentName:"p"},"set state")," instead of writing to a variable. You should never change preexisting variables or objects while your component is rendering."),(0,a.kt)("p",null,"React offers a \u201cStrict Mode\u201d in which it calls each component\u2019s function twice during development. ",(0,a.kt)("strong",{parentName:"p"},"By calling the component functions twice, Strict Mode helps find components that break these rules.")," Strict Mode has no effect in production, so it won\u2019t slow down the app for your users. To opt into Strict Mode, you can wrap your root component into ",(0,a.kt)("inlineCode",{parentName:"p"},"<React.StrictMode>"),". Some frameworks do this by default."),(0,a.kt)("h2",{id:"local-mutation-your-components-little-secret"},"Local mutation: Your component\u2019s little secret"),(0,a.kt)("p",null,"In the above example, the problem was that the component changed a preexisting variable while rendering. This is often called a \u201cmutation\u201d to make it sound a bit scarier. Pure functions don\u2019t mutate variables outside of the function\u2019s scope or objects that were created before the call\u2014that makes them impure!"),(0,a.kt)("p",null,"However, ",(0,a.kt)("strong",{parentName:"p"},"it\u2019s completely fine to change variables and objects that you\u2019ve just created while rendering"),". In this example, you create an ",(0,a.kt)("inlineCode",{parentName:"p"},"[]")," array, assign it to a ",(0,a.kt)("inlineCode",{parentName:"p"},"cups")," variable, and then ",(0,a.kt)("inlineCode",{parentName:"p"},"push")," a dozen cups into it:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"function Cup({ guest }) {\n  return <h2>Tea cup for guest #{guest}</h2>;\n}\n\nexport default function TeaGathering() {\n  let cups = [];\n  for (let i = 1; i <= 12; i++) {\n    cups.push(<Cup key={i} guest={i} />);\n  }\n  return cups;\n}\n")),(0,a.kt)("p",null,"If the ",(0,a.kt)("inlineCode",{parentName:"p"},"cups")," variable or the ",(0,a.kt)("inlineCode",{parentName:"p"},"[]")," array were created outside the ",(0,a.kt)("inlineCode",{parentName:"p"},"TeaGathering")," function, this would be a huge problem! You would be changing a preexisting object by pushing items into that array."),(0,a.kt)("p",null,"However, it\u2019s fine because you\u2019ve created them during the same render, inside ",(0,a.kt)("inlineCode",{parentName:"p"},"TeaGathering"),". No code outside of ",(0,a.kt)("inlineCode",{parentName:"p"},"TeaGathering")," will ever know that this happened. This is called \u201c",(0,a.kt)("strong",{parentName:"p"},"local mutation"),"\u201d\u2014it\u2019s like your component\u2019s little secret."),(0,a.kt)("h2",{id:"where-you-can-cause-side-effects"},"Where you can cause side effects"),(0,a.kt)("p",null,"While functional programming relies heavily on purity, at some point, somewhere, something has to change. That\u2019s kind of the point of programming! These changes\u2014updating the screen, starting an animation, changing the data\u2014are called ",(0,a.kt)("strong",{parentName:"p"},"side effects"),". They\u2019re things that happen \u201con the side\u201d, not during rendering."),(0,a.kt)("p",null,"In React, side effects usually belong inside ",(0,a.kt)("a",{parentName:"p",href:"https://react.dev/learn/responding-to-events"},"event handlers"),". Event handlers are functions that React runs when you perform some action\u2014for example, when you click a button. Even though event handlers are defined inside your component, they don\u2019t run during rendering! So event handlers don\u2019t need to be pure."),(0,a.kt)("p",null,"If you\u2019ve exhausted all other options and can\u2019t find the right event handler for your side effect, you can still attach it to your returned JSX with a ",(0,a.kt)("a",{parentName:"p",href:"https://react.dev/reference/react/useEffect"},(0,a.kt)("inlineCode",{parentName:"a"},"useEffect"))," call in your component. This tells React to execute it later, after rendering, when side effects are allowed. However, this approach should be your last resort. When possible, try to express your logic with rendering alone."),(0,a.kt)("h2",{id:"why-does-react-care-about-purity"},"Why does React care about purity?"),(0,a.kt)("p",null,"Writing pure functions takes some habit and discipline. But it also unlocks marvelous opportunities:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Your components could run in a different environment\u2014for example, on the server! Since they return the same result for the same inputs, one component can serve many user requests."),(0,a.kt)("li",{parentName:"ul"},"You can improve performance by ",(0,a.kt)("a",{parentName:"li",href:"https://react.dev/reference/react/memo"},"skipping rendering")," components whose inputs have not changed. This is safe because pure functions always return the same results, so they are safe to cache."),(0,a.kt)("li",{parentName:"ul"},"If some data changes in the middle of rendering a deep component tree, React can restart rendering without wasting time to finish the outdated render. Purity makes it safe to stop calculating at any time.")),(0,a.kt)("p",null,"Every new React feature we\u2019re building takes advantage of purity. From data fetching to animations to performance, keeping components pure unlocks the power of the React paradigm."))}d.isMDXComponent=!0}}]);