"use strict";(self.webpackChunklearning_knowledge_base=self.webpackChunklearning_knowledge_base||[]).push([[5740],{99813:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var r=n(74848),t=n(28453);const i={id:"resolvers",title:"Resolvers",sidebar_position:5},a=void 0,o={id:"csharp/libraries/hot-chocolate/resolvers",title:"Resolvers",description:"Resolvers are the main building blocks when it comes to fetching data. Every field in our GraphQL schema is backed by such a resolver function, responsible for returning the field's value. Since a resolver is just a function, we can use it to retrieve data from a database, a REST service, or any other data source as needed.",source:"@site/docs/csharp/libraries/hot-chocolate/resolvers.md",sourceDirName:"csharp/libraries/hot-chocolate",slug:"/csharp/libraries/hot-chocolate/resolvers",permalink:"/LearningCollection/csharp/libraries/hot-chocolate/resolvers",draft:!1,unlisted:!1,editUrl:"https://github.com/RobinTTY/LearningCollection/tree/master/website/docs/csharp/libraries/hot-chocolate/resolvers.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{id:"resolvers",title:"Resolvers",sidebar_position:5},sidebar:"docs",previous:{title:"Subscriptions",permalink:"/LearningCollection/csharp/libraries/hot-chocolate/subscriptions"},next:{title:"Data Loaders",permalink:"/LearningCollection/csharp/libraries/hot-chocolate/data-loaders"}},l={},c=[{value:"Resolver Tree",id:"resolver-tree",level:2},{value:"Defining a Resolver",id:"defining-a-resolver",level:2},{value:"Properties",id:"properties",level:3},{value:"Regular Resolver",id:"regular-resolver",level:3},{value:"Async Resolver",id:"async-resolver",level:3},{value:"ResolveWith",id:"resolvewith",level:3},{value:"Arguments",id:"arguments",level:2},{value:"Accessing Parent Values",id:"accessing-parent-values",level:3},{value:"Automatic Registration",id:"automatic-registration",level:2}];function d(e){const s={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.p,{children:"Resolvers are the main building blocks when it comes to fetching data. Every field in our GraphQL schema is backed by such a resolver function, responsible for returning the field's value. Since a resolver is just a function, we can use it to retrieve data from a database, a REST service, or any other data source as needed."}),"\n",(0,r.jsx)(s.h2,{id:"resolver-tree",children:"Resolver Tree"}),"\n",(0,r.jsx)(s.p,{children:"A resolver tree is a projection of a GraphQL operation that is prepared for execution. For better understanding, let's imagine we have a simple GraphQL query like the following, where we select some fields of the currently logged-in user."}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-graphql",children:"query {\n  me {\n    name\n    company {\n      id\n      name\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(s.p,{children:"In Hot Chocolate, this query results in the following resolver tree."}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.img,{alt:"resolver-tree",src:n(79782).A+"",width:"1350",height:"358"})}),"\n",(0,r.jsxs)(s.p,{children:["This tree will be traversed by the execution engine, starting with one or more root resolvers. In the above example the ",(0,r.jsx)(s.code,{children:"me"})," field represents the only root resolver."]}),"\n",(0,r.jsxs)(s.p,{children:["Field resolvers that are sub-selections of a field, can only be executed after a value has been resolved for their parent field. In the case of the above example this means that the ",(0,r.jsx)(s.code,{children:"name"})," and ",(0,r.jsx)(s.code,{children:"company"})," resolvers can only run, after the ",(0,r.jsx)(s.code,{children:"me"})," resolver has finished."]}),"\n",(0,r.jsx)(s.admonition,{type:"danger",children:(0,r.jsx)(s.p,{children:"Resolvers of field sub-selections can and will be executed in parallel.\nBecause of this it is important that resolvers, with the exception of top level mutation field resolvers, do not contain side-effects, since their execution order may vary."})}),"\n",(0,r.jsx)(s.p,{children:"The execution of a request finishes, once each resolver of the selected fields has produced a result. This is of course an oversimplification that differs from the actual implementation."}),"\n",(0,r.jsx)(s.h2,{id:"defining-a-resolver",children:"Defining a Resolver"}),"\n",(0,r.jsx)(s.p,{children:"Resolvers can be defined in a way that should feel very familiar to C# developers, especially in the Annotation-based approach."}),"\n",(0,r.jsx)(s.h3,{id:"properties",children:"Properties"}),"\n",(0,r.jsx)(s.p,{children:"Hot Chocolate automatically converts properties with a public get accessor to a resolver that simply returns its value."}),"\n",(0,r.jsx)(s.h3,{id:"regular-resolver",children:"Regular Resolver"}),"\n",(0,r.jsx)(s.p,{children:"A regular resolver is just a simple method, which returns a value."}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-csharp",children:'public class Query\n{\n    public string Foo() => "Bar";\n}\n\npublic class Startup\n{\n    public void ConfigureServices(IServiceCollection services)\n    {\n        services\n            .AddGraphQLServer()\n            .AddQueryType<Query>();\n    }\n}\n'})}),"\n",(0,r.jsx)(s.h3,{id:"async-resolver",children:"Async Resolver"}),"\n",(0,r.jsxs)(s.p,{children:["Most data fetching operations, like calling a service or communicating with a database, will be asynchronous.\nIn Hot Chocolate, we can simply mark our resolver methods and delegates as ",(0,r.jsx)(s.code,{children:"async"})," or return a ",(0,r.jsx)(s.code,{children:"Task<T>"})," and it becomes an async-capable resolver.\nWe can also add a ",(0,r.jsx)(s.code,{children:"CancellationToken"})," argument to our resolver. Hot Chocolate will automatically cancel this token if the request has been aborted."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-csharp",children:"public class Query\n{\n    public async Task<string> Foo(CancellationToken ct)\n    {\n        // Omitted code for brevity\n    }\n}\n"})}),"\n",(0,r.jsxs)(s.p,{children:["When using a delegate resolver, the ",(0,r.jsx)(s.code,{children:"CancellationToken"})," is passed as second argument to the delegate."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-csharp",children:'descriptor\n    .Field("foo")\n    .Resolve((context, ct) =>\n    {\n        // Omitted code for brevity\n    });\n'})}),"\n",(0,r.jsx)(s.h3,{id:"resolvewith",children:"ResolveWith"}),"\n",(0,r.jsx)(s.p,{children:"Thus far we have looked at two ways to specify resolvers in Code-first:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Add new methods to the CLR type, e.g. the ",(0,r.jsx)(s.code,{children:"T"})," type of ",(0,r.jsx)(s.code,{children:"ObjectType<T>"})]}),"\n",(0,r.jsx)(s.li,{children:"Add new fields to the schema type in the form of delegates"}),"\n"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-csharp",children:'descriptor.Field("foo").Resolve(context => )\n'})}),"\n",(0,r.jsxs)(s.p,{children:["But there's a third way. We can describe our field using the ",(0,r.jsx)(s.code,{children:"descriptor"}),", but instead of a resolver delegate, we can point to a method on another class, responsible for resolving this field."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-csharp",children:'public class FooResolvers\n{\n    public string GetFoo(string arg, [Service] FooService service)\n    {\n        // Omitted code for brevity\n    }\n}\n\npublic class QueryType : ObjectType\n{\n    protected override void Configure(IObjectTypeDescriptor descriptor)\n    {\n        descriptor\n            .Field("foo")\n            .Argument("arg", a => a.Type<NonNullType<StringType>>())\n            .ResolveWith<FooResolvers>(r => r.GetFoo(default, default));\n    }\n}\n'})}),"\n",(0,r.jsx)(s.h2,{id:"arguments",children:"Arguments"}),"\n",(0,r.jsxs)(s.p,{children:["We can access arguments we defined for our resolver like regular arguments of a function. There are also specific arguments that will be automatically populated by Hot Chocolate when the resolver is executed. These include ",(0,r.jsx)(s.a,{href:"https://chillicream.com/docs/hotchocolate/v13/fetching-data/resolvers/#injecting-services",children:"Dependency injection"})," services, ",(0,r.jsx)(s.a,{href:"https://chillicream.com/docs/hotchocolate/v13/fetching-data/dataloader",children:"DataLoaders"}),", state, or even context like a ",(0,r.jsx)(s.a,{href:"https://chillicream.com/docs/hotchocolate/v13/fetching-data/resolvers/#accessing-parent-values",children:"parent"})," value."]}),"\n",(0,r.jsx)(s.h3,{id:"accessing-parent-values",children:"Accessing Parent Values"}),"\n",(0,r.jsx)(s.p,{children:"The resolver of each field on a type has access to the value that was resolved for said type."}),"\n",(0,r.jsx)(s.p,{children:"Let's look at an example. We have the following schema:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-graphql",children:"type Query {\n  me: User!;\n}\n\ntype User {\n  id: ID!;\n  friends: [User!]!;\n}\n"})}),"\n",(0,r.jsxs)(s.p,{children:["The ",(0,r.jsx)(s.code,{children:"User"})," schema type is represented by an ",(0,r.jsx)(s.code,{children:"User"})," CLR type. The ",(0,r.jsx)(s.code,{children:"id"})," field is an actual property on this CLR type:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-csharp",children:"public class User\n{\n    public string Id { get; set; }\n}\n"})}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"friends"})," on the other hand is a resolver i.e. method we defined. It depends on the user's ",(0,r.jsx)(s.code,{children:"Id"})," property to compute its result. From the point of view of this ",(0,r.jsx)(s.code,{children:"friends"})," resolver, the ",(0,r.jsx)(s.code,{children:"User"})," CLR type is its parent.\nWe can access this so called parent value like the following. In the Annotation-based approach we can just access the properties using the ",(0,r.jsx)(s.code,{children:"this"})," keyword:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-csharp",children:"public class User\n{\n    public string Id { get; set; }\n\n    public List<User> GetFriends()\n    {\n        var currentUserId = this.Id;\n\n        // Omitted code for brevity\n    }\n}\n"})}),"\n",(0,r.jsxs)(s.p,{children:["There's also a ",(0,r.jsx)(s.code,{children:"[Parent]"})," attribute that injects the parent into the resolver:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-csharp",children:"public class User\n{\n    public string Id { get; set; }\n\n    public List<User> GetFriends([Parent] User parent)\n    {\n        // Omitted code for brevity\n    }\n}\n"})}),"\n",(0,r.jsx)(s.h2,{id:"automatic-registration",children:"Automatic Registration"}),"\n",(0,r.jsxs)(s.p,{children:["We can automatically register all resolvers that are annotated with ",(0,r.jsx)(s.code,{children:"QueryType"}),", ",(0,r.jsx)(s.code,{children:"MutationType"})," and ",(0,r.jsx)(s.code,{children:"SubscriptionType"}),". For this we use the package ",(0,r.jsx)(s.code,{children:"HotChocolate.Types.Analyzers"}),". It is a source generator and can be added as a private assset:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-xml",metastring:'title=".csproj"',children:'<PackageReference Include="HotChocolate.Types.Analyzers" Version="x.x.x">\n    <PrivateAssets>all</PrivateAssets>\n    <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>\n</PackageReference>\n'})}),"\n",(0,r.jsxs)(s.p,{children:["Once the package is installed, we only need to add the types by adding the automatically generated ",(0,r.jsx)(s.code,{children:"AddTypes"})," method:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-csharp",metastring:'title="Startup.cs"',children:"builder.Services\n    .AddGraphQLServer()\n    .AddTypes();\n"})}),"\n",(0,r.jsxs)(s.p,{children:["If we now have a type that is annotated with ",(0,r.jsx)(s.code,{children:"QueryType"})," for example, it will be automatically added to the schema. For instance:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-csharp",children:"[QueryType]\npublic sealed class UserQueries\n{\n    public async Task<User> GetUserAsync(AssetContext context)\n    {\n        // Omitted code for brevity\n    }\n}\n"})}),"\n",(0,r.jsx)(s.p,{children:"will lead to the following code being automatically generated:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-csharp",children:"using System;\nusing HotChocolate.Execution.Configuration;\n\nnamespace Microsoft.Extensions.DependencyInjection\n{\n    public static class AssetTypesRequestExecutorBuilderExtensions\n    {\n        public static IRequestExecutorBuilder AddTypes(this IRequestExecutorBuilder builder)\n        {\n            builder.AddTypeExtension<Demo.Types.Account.UserQueries>();\n            return builder;\n        }\n    }\n}\n"})}),"\n",(0,r.jsxs)(s.p,{children:["It registers the necessary types and adds them to the schema. This way we can easily add new types without having to change the ",(0,r.jsx)(s.code,{children:"Startup.cs"})," file."]})]})}function h(e={}){const{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},79782:(e,s,n)=>{n.d(s,{A:()=>r});const r=n.p+"assets/images/resolver-tree-4b499f0440df4510ac7f98c5331a83ad.png"},28453:(e,s,n)=>{n.d(s,{R:()=>a,x:()=>o});var r=n(96540);const t={},i=r.createContext(t);function a(e){const s=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),r.createElement(i.Provider,{value:s},e.children)}}}]);