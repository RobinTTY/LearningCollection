"use strict";(self.webpackChunklearning_knowledge_base=self.webpackChunklearning_knowledge_base||[]).push([[8933],{7958:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>d});var t=n(5893),s=n(1151);const i={id:"database-schema",title:"Database Schema",sidebar_position:2},o=void 0,r={id:"databases/sql/core-concepts/database-design/database-schema",title:"Database Schema",description:"A database's schema describes how data is organized within it. Data types, table names, field names, constraints, and the relationships between all of those entities are part of a database's schema.",source:"@site/docs/databases/sql/core-concepts/database-design/database-schema.md",sourceDirName:"databases/sql/core-concepts/database-design",slug:"/databases/sql/core-concepts/database-design/database-schema",permalink:"/LearningCollection/databases/sql/core-concepts/database-design/database-schema",draft:!1,unlisted:!1,editUrl:"https://github.com/RobinTTY/LearningCollection/tree/master/website/docs/databases/sql/core-concepts/database-design/database-schema.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{id:"database-schema",title:"Database Schema",sidebar_position:2},sidebar:"docs",previous:{title:"Data Types",permalink:"/LearningCollection/databases/sql/core-concepts/database-design/data-types"},next:{title:"Table Relationships",permalink:"/LearningCollection/databases/sql/core-concepts/database-design/table-relationships"}},l={},d=[{value:"Manipulating a database schema",id:"manipulating-a-database-schema",level:2},{value:"Creating Tables",id:"creating-tables",level:3},{value:"Altering Tables",id:"altering-tables",level:3},{value:"Renaming a table or column",id:"renaming-a-table-or-column",level:4},{value:"Adding or droping a column",id:"adding-or-droping-a-column",level:4},{value:"Constraints",id:"constraints",level:2},{value:"NOT NULL constraint",id:"not-null-constraint",level:3},{value:"PRIMARY KEY constraint",id:"primary-key-constraint",level:3},{value:"FOREIGN KEY constraint",id:"foreign-key-constraint",level:3},{value:"UNIQUE constraint",id:"unique-constraint",level:3},{value:"Defining a <code>UNIQUE</code> constraint for one column",id:"defining-a-unique-constraint-for-one-column",level:4},{value:"Defining a <code>UNIQUE</code> constraint for multiple columns",id:"defining-a-unique-constraint-for-multiple-columns",level:4},{value:"Auto Increment",id:"auto-increment",level:3},{value:"ID&#39;s",id:"ids",level:4},{value:"Schema Migrations",id:"schema-migrations",level:2},{value:"Risks and benefits",id:"risks-and-benefits",level:3}];function c(e){const a={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(a.p,{children:["A database's ",(0,t.jsx)(a.a,{href:"https://www.ibm.com/topics/database-schema",children:"schema"})," describes how data is organized within it. Data types, table names, field names, constraints, and the relationships between all of those entities are part of a database's schema."]}),"\n",(0,t.jsx)(a.p,{children:"When designing a database schema there typically isn't a \"correct\" solution. We do our best to choose a sane set of tables, fields, constraints, etc that will accomplish our project's goals. Like many things in programming, different schema designs come with different tradeoffs."}),"\n",(0,t.jsx)(a.h2,{id:"manipulating-a-database-schema",children:"Manipulating a database schema"}),"\n",(0,t.jsx)(a.h3,{id:"creating-tables",children:"Creating Tables"}),"\n",(0,t.jsxs)(a.p,{children:["The ",(0,t.jsx)(a.code,{children:"CREATE TABLE"})," statement is used to create a new table in a database."]}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sql",children:"CREATE TABLE employees (id INTEGER, name TEXT, age INTEGER, is_manager BOOLEAN, salary INTEGER);\n"})}),"\n",(0,t.jsxs)(a.p,{children:["Each field name is followed by its datatype.\nIt's also acceptable and common to break up the ",(0,t.jsx)(a.code,{children:"CREATE TABLE"})," statement with some whitespace like this:"]}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sql",children:"CREATE TABLE employees(\n    id INTEGER,\n    name TEXT,\n    age INTEGER,\n    is_manager BOOLEAN,\n    salary INTEGER\n);\n"})}),"\n",(0,t.jsx)(a.h3,{id:"altering-tables",children:"Altering Tables"}),"\n",(0,t.jsxs)(a.p,{children:["We often need to alter our database schema without deleting it and re-creating it. We can use use the ",(0,t.jsx)(a.code,{children:"ALTER TABLE"})," statement to make changes in place without deleting any data. The following statements are valid for the SQLite Syntax."]}),"\n",(0,t.jsx)(a.h4,{id:"renaming-a-table-or-column",children:"Renaming a table or column"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sql",children:"ALTER TABLE employees\nRENAME TO contractors;\n\nALTER TABLE contractors\nRENAME COLUMN salary TO invoice;\n"})}),"\n",(0,t.jsx)(a.h4,{id:"adding-or-droping-a-column",children:"Adding or droping a column"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sql",children:"ALTER TABLE contractors\nADD COLUMN job_title TEXT;\n\nALTER TABLE contractors\nDROP COLUMN is_manager;\n"})}),"\n",(0,t.jsx)(a.h2,{id:"constraints",children:"Constraints"}),"\n",(0,t.jsxs)(a.p,{children:["A ",(0,t.jsx)(a.code,{children:"constraint"})," is a rule we create on a database that enforces some specific behavior. For example, setting a ",(0,t.jsx)(a.code,{children:"NOT NULL"})," constraint on a column ensures that the column will not accept ",(0,t.jsx)(a.code,{children:"NULL"})," values. Constraints are extremely useful when we need to ensure that certain kinds of data exist within our database."]}),"\n",(0,t.jsx)(a.h3,{id:"not-null-constraint",children:"NOT NULL constraint"}),"\n",(0,t.jsxs)(a.p,{children:["The ",(0,t.jsx)(a.code,{children:"NOT NULL"})," constraint can be added directly to the ",(0,t.jsx)(a.code,{children:"CREATE TABLE"})," statement. If we try to insert a ",(0,t.jsx)(a.code,{children:"NULL"})," value into a column with the ",(0,t.jsx)(a.code,{children:"NOT NULL"})," constraint, the insert will fail with an error message."]}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sql",metastring:"{2}",children:"CREATE TABLE employees(\n    title TEXT NOT NULL\n);\n"})}),"\n",(0,t.jsx)(a.h3,{id:"primary-key-constraint",children:"PRIMARY KEY constraint"}),"\n",(0,t.jsxs)(a.p,{children:["A key defines and protects relationships between tables. A ",(0,t.jsx)(a.a,{href:"https://en.wikipedia.org/wiki/Primary_key",children:"primary key"})," is a special column that uniquely identifies records within a table. Each table can have one, and only one primary key."]}),"\n",(0,t.jsxs)(a.p,{children:["It's very common to have a column named ",(0,t.jsx)(a.code,{children:"id"})," on each table in a database, and that ",(0,t.jsx)(a.code,{children:"id"})," is the primary key for that table. No two rows in that table can share an ",(0,t.jsx)(a.code,{children:"id"}),"."]}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sql",metastring:"{2}",children:"CREATE TABLE employees(\n    id INTEGER PRIMARY KEY,\n    title TEXT NOT NULL\n);\n"})}),"\n",(0,t.jsx)(a.h3,{id:"foreign-key-constraint",children:"FOREIGN KEY constraint"}),"\n",(0,t.jsxs)(a.p,{children:["Foreign keys are what makes relational databases relational! Foreign keys define the relationships between tables. Simply put, a ",(0,t.jsx)(a.code,{children:"FOREIGN KEY"})," is a field in one table that references another table's ",(0,t.jsx)(a.code,{children:"PRIMARY KEY"}),"."]}),"\n",(0,t.jsxs)(a.p,{children:["Creating a ",(0,t.jsx)(a.code,{children:"FOREIGN KEY"})," in SQLite for instance happens at table creation. After we define the table fields and constraints we add an additional constraint where we define the ",(0,t.jsx)(a.code,{children:"FOREIGN KEY"})," and its ",(0,t.jsx)(a.code,{children:"REFERENCES"}),"."]}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sql",children:"CREATE TABLE departments (\n    id INTEGER PRIMARY KEY,\n    department_name TEXT NOT NULL\n);\n\nCREATE TABLE employees (\n    id INTEGER PRIMARY KEY,\n    name TEXT NOT NULL,\n    department_id INTEGER,\n    CONSTRAINT fk_departments\n    FOREIGN KEY (department_id)\n    REFERENCES departments(id)\n);\n"})}),"\n",(0,t.jsxs)(a.p,{children:["In this example, an ",(0,t.jsx)(a.code,{children:"employee"})," has a ",(0,t.jsx)(a.code,{children:"department_id"}),". The ",(0,t.jsx)(a.code,{children:"department_id"})," must be the same as the id field of a record from the ",(0,t.jsx)(a.code,{children:"departments"})," table."]}),"\n",(0,t.jsx)(a.h3,{id:"unique-constraint",children:"UNIQUE constraint"}),"\n",(0,t.jsxs)(a.p,{children:["A ",(0,t.jsx)(a.code,{children:"UNIQUE"})," constraint ensures all values in a column or a group of columns are distinct from one another or unique. You can define a ",(0,t.jsx)(a.code,{children:"UNIQUE"})," constraint at the column or the table level. Only at the table level, you can define a ",(0,t.jsx)(a.code,{children:"UNIQUE"})," constraint across multiple columns."]}),"\n",(0,t.jsxs)(a.h4,{id:"defining-a-unique-constraint-for-one-column",children:["Defining a ",(0,t.jsx)(a.code,{children:"UNIQUE"})," constraint for one column"]}),"\n",(0,t.jsxs)(a.p,{children:["The following statement creates a new table named contacts with a ",(0,t.jsx)(a.code,{children:"UNIQUE"})," constraint defined for the ",(0,t.jsx)(a.code,{children:"email"})," column:"]}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sql",children:"CREATE TABLE contacts(\n    contact_id INTEGER PRIMARY KEY,\n    first_name TEXT,\n    last_name TEXT,\n    email TEXT NOT NULL UNIQUE\n);\n"})}),"\n",(0,t.jsxs)(a.h4,{id:"defining-a-unique-constraint-for-multiple-columns",children:["Defining a ",(0,t.jsx)(a.code,{children:"UNIQUE"})," constraint for multiple columns"]}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-sql",children:"CREATE TABLE product_suppliers (\n  product_id INTEGER,\n  supplier_id INTEGER,\n  UNIQUE(product_id, supplier_id)\n);\n"})}),"\n",(0,t.jsxs)(a.p,{children:["This ensures that we can have multiple rows with the same ",(0,t.jsx)(a.code,{children:"product_id"})," or ",(0,t.jsx)(a.code,{children:"supplier_id"}),", but we can't have two rows where both the ",(0,t.jsx)(a.code,{children:"product_id"})," and ",(0,t.jsx)(a.code,{children:"supplier_id"})," are the same."]}),"\n",(0,t.jsx)(a.h3,{id:"auto-increment",children:"Auto Increment"}),"\n",(0,t.jsxs)(a.p,{children:["Many dialects of SQL support an ",(0,t.jsx)(a.code,{children:"AUTO INCREMENT"})," feature. When inserting records into a table with ",(0,t.jsx)(a.code,{children:"AUTO INCREMENT"})," enabled, the database will assign the next value automatically. In SQLite an integer ",(0,t.jsx)(a.code,{children:"id"})," field that has the ",(0,t.jsx)(a.code,{children:"PRIMARY KEY"})," constraint will auto increment by default. Different dialects of SQL will implement this feature differently."]}),"\n",(0,t.jsx)(a.h4,{id:"ids",children:"ID's"}),"\n",(0,t.jsxs)(a.p,{children:["Depending on how your database is set up, you may be using traditional ids or you may be using ",(0,t.jsx)(a.a,{href:"https://en.wikipedia.org/wiki/Universally_unique_identifier",children:"UUIDs"}),". SQL doesn't support auto incrementing a ",(0,t.jsx)(a.code,{children:"uuid"})," so if your database is using them your server will have to handle the changing uuid's for each record."]}),"\n",(0,t.jsx)(a.h2,{id:"schema-migrations",children:"Schema Migrations"}),"\n",(0,t.jsx)(a.p,{children:"In software engineering, a schema migration (also database migration, database change management) refers to the management of version-controlled, incremental and reversible changes to relational database schemas. A schema migration is performed on a database whenever it is necessary to update or revert that database's schema to some newer or older version."}),"\n",(0,t.jsx)(a.p,{children:"Migrations are performed programmatically by using a schema migration tool. When invoked with a specified desired schema version, the tool automates the successive application or reversal of an appropriate sequence of schema changes until it is brought to the desired state."}),"\n",(0,t.jsx)(a.p,{children:"Most schema migration tools aim to minimize the impact of schema changes on any existing data in the database. Despite this, preservation of data in general is not guaranteed because schema changes such as the deletion of a database column can destroy data (i.e. all values stored under that column for all rows in that table are deleted). Instead, the tools help to preserve the meaning of the data or to reorganize existing data to meet new requirements. Since meaning of the data often cannot be encoded, the configuration of the tools usually needs manual intervention."}),"\n",(0,t.jsx)(a.h3,{id:"risks-and-benefits",children:"Risks and benefits"}),"\n",(0,t.jsx)(a.p,{children:"Schema migration allows for fixing mistakes and adapting the data as requirements change. They are an essential part of software evolution, especially in agile environments (see below)."}),"\n",(0,t.jsx)(a.p,{children:"Applying a schema migration to a production database is always a risk. Development and test databases tend to be smaller and cleaner. The data in them is better understood or, if everything else fails, the amount of data is small enough for a human to process. Production databases are usually huge, old and full of surprises. The surprises can come from many sources:"}),"\n",(0,t.jsxs)(a.ul,{children:["\n",(0,t.jsx)(a.li,{children:"Corrupt data that was written by old versions of the software and not cleaned properly"}),"\n",(0,t.jsx)(a.li,{children:"Implied dependencies in the data which no one knows about anymore"}),"\n",(0,t.jsx)(a.li,{children:"People directly changing the database without using the designated tools"}),"\n",(0,t.jsx)(a.li,{children:"Bugs in the schema migration tools"}),"\n",(0,t.jsx)(a.li,{children:"Mistakes in assumptions how data should be migrated"}),"\n"]}),"\n",(0,t.jsx)(a.p,{children:"For these reasons, the migration process needs a high level of discipline, thorough testing and a sound backup strategy."}),"\n",(0,t.jsxs)(a.p,{children:["Schema migrations may take a long time to complete and for systems that operate 24/7 it is important to be able to do ",(0,t.jsx)(a.a,{href:"https://www.aviransplace.com/post/safe-database-migration-pattern-without-downtime-1",children:"database migrations without downtime"}),". Usually it is done with the help of feature flags and continuous delivery."]})]})}function h(e={}){const{wrapper:a}={...(0,s.a)(),...e.components};return a?(0,t.jsx)(a,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},1151:(e,a,n)=>{n.d(a,{Z:()=>r,a:()=>o});var t=n(7294);const s={},i=t.createContext(s);function o(e){const a=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function r(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(i.Provider,{value:a},e.children)}}}]);