"use strict";(self.webpackChunklearning_knowledge_base=self.webpackChunklearning_knowledge_base||[]).push([[6593],{7790:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>f,default:()=>k,frontMatter:()=>p,metadata:()=>y,toc:()=>b});var a=t(7462),s=(t(7294),t(3905)),i=t(2004),r=t(614);const o="interface Animal {\n  name: string;\n}\n\ninterface Bear extends Animal {\n  honey: boolean;\n}\n\nconst bear = getBear();\nbear.name;\nbear.honey;\n",c="type Animal = {\n  name: string;\n};\n\ntype Bear = Animal & {\n  honey: boolean;\n};\n\nconst bear = getBear();\nbear.name;\nbear.honey;\n",l="interface Window {\n  title: string;\n}\n\ninterface Window {\n  ts: TypeScriptAPI;\n}\n\nconst src = 'const a = \"Hello World\"';\nwindow.ts.transpileModule(src, {});\n",d="type Window = {\n  title: string;\n};\n\ntype Window = {\n  ts: TypeScriptAPI;\n};\n\n// Error: Duplicate identifier 'Window'.\n\n",p={id:"interfaces",title:"Interfaces",sidebar_position:5},f=void 0,y={unversionedId:"web/typescript/core-concepts/interfaces",id:"web/typescript/core-concepts/interfaces",title:"Interfaces",description:"An interface declaration is another way to name an object type:",source:"@site/docs/web/typescript/core-concepts/interfaces.mdx",sourceDirName:"web/typescript/core-concepts",slug:"/web/typescript/core-concepts/interfaces",permalink:"/LearningCollection/web/typescript/core-concepts/interfaces",draft:!1,editUrl:"https://github.com/RobinTTY/LearningCollection/tree/master/website/docs/web/typescript/core-concepts/interfaces.mdx",tags:[],version:"current",sidebarPosition:5,frontMatter:{id:"interfaces",title:"Interfaces",sidebar_position:5},sidebar:"finance",previous:{title:"Classes",permalink:"/LearningCollection/web/typescript/core-concepts/classes"},next:{title:"Type Assertions",permalink:"/LearningCollection/web/typescript/core-concepts/type-assertions"}},u={},b=[{value:"Differences Between Type Aliases and Interfaces",id:"differences-between-type-aliases-and-interfaces",level:2},{value:"Extending Types vs Interfaces",id:"extending-types-vs-interfaces",level:3},{value:"Adding new fields",id:"adding-new-fields",level:3},{value:"Thoughts about Types vs Interfaces",id:"thoughts-about-types-vs-interfaces",level:3},{value:"Interfaces as Function Types",id:"interfaces-as-function-types",level:2}],m={toc:b},g="wrapper";function k(e){let{components:n,...t}=e;return(0,s.kt)(g,(0,a.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"An interface declaration is another way to name an object type:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},'interface Point {\n  x: number;\n  y: number;\n}\n\nfunction printCoord(pt: Point) {\n  console.log("The coordinate\'s x value is " + pt.x);\n  console.log("The coordinate\'s y value is " + pt.y);\n}\n\nprintCoord({ x: 100, y: 100 });\n')),(0,s.kt)("h2",{id:"differences-between-type-aliases-and-interfaces"},"Differences Between Type Aliases and Interfaces"),(0,s.kt)("p",null,"Type aliases and interfaces are very similar, and in many cases you can choose between them freely. Almost all features of an ",(0,s.kt)("inlineCode",{parentName:"p"},"interface")," are available in ",(0,s.kt)("inlineCode",{parentName:"p"},"type"),", the key distinction is that it can be extended."),(0,s.kt)("p",null,"Interfaces are often used to share common functionality between classes. So they are similar to abstract classes but without any implementation."),(0,s.kt)("h3",{id:"extending-types-vs-interfaces"},"Extending Types vs Interfaces"),(0,s.kt)("div",{style:{display:"flex"}},(0,s.kt)("div",{style:{flex:"45%"}},(0,s.kt)(r.Z,{language:"ts",title:"Extending an interface",mdxType:"CodeBlock"},o)),(0,s.kt)("div",{style:{flex:"0 0 5%"}}),(0,s.kt)("div",{style:{flex:"45%"}},(0,s.kt)(r.Z,{language:"ts",title:"Extending a type via intersections",mdxType:"CodeBlock"},c))),(0,s.kt)("h3",{id:"adding-new-fields"},"Adding new fields"),(0,s.kt)("div",{style:{display:"flex"}},(0,s.kt)("div",{style:{flex:"45%"}},(0,s.kt)(r.Z,{language:"ts",title:"Adding new fields to an existing interface",mdxType:"CodeBlock"},l)),(0,s.kt)("div",{style:{flex:"0 0 5%"}}),(0,s.kt)("div",{style:{flex:"45%"}},(0,s.kt)(r.Z,{language:"ts",title:"A type cannot be changed after being created",mdxType:"CodeBlock"},d))),(0,s.kt)("h3",{id:"thoughts-about-types-vs-interfaces"},"Thoughts about Types vs Interfaces"),(0,s.kt)(i.Z,{style:{marginBottom:"1.5em"},controls:!0,url:"https://www.youtube.com/watch?v=zM9UPcIyyhQ",mdxType:"ReactPlayer"}),(0,s.kt)("p",null,"Main takeaways:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Use types unless you need a specific feature of interfaces"),(0,s.kt)("li",{parentName:"ul"},"If you need a type that extends another type => Use an interface")),(0,s.kt)("h2",{id:"interfaces-as-function-types"},"Interfaces as Function Types"),(0,s.kt)("p",null,"Interfaces can also describe function types:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// type AddFn = (a: number, b: number) => number;\ninterface AddFn {\n  (a: number, b: number): number;\n}\n\nlet add: AddFn;\n\nadd = (n1: number, n2: number) => {\n  return n1 + n2;\n};\n")),(0,s.kt)("p",null,"Usually we use type aliases for function types, but interfaces can also be used."))}k.isMDXComponent=!0}}]);