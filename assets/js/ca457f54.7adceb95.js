"use strict";(self.webpackChunklearning_knowledge_base=self.webpackChunklearning_knowledge_base||[]).push([[6826],{1710:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>i,contentTitle:()=>c,default:()=>p,frontMatter:()=>n,metadata:()=>a,toc:()=>l});var r=o(5893),s=o(1151);const n={id:"class-decorators",title:"Class Decorators",sidebar_position:2},c=void 0,a={id:"web/typescript/decorators/class-decorators",title:"Class Decorators",description:"A Class Decorator is declared just before a class declaration. The class decorator is applied to the constructor of the class and can be used to observe, modify, or replace a class definition. A class decorator cannot be used in a declaration file, or in any other ambient context (such as on a declare class).",source:"@site/docs/web/typescript/decorators/class-decorators.md",sourceDirName:"web/typescript/decorators",slug:"/web/typescript/decorators/class-decorators",permalink:"/LearningCollection/web/typescript/decorators/class-decorators",draft:!1,unlisted:!1,editUrl:"https://github.com/RobinTTY/LearningCollection/tree/master/website/docs/web/typescript/decorators/class-decorators.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{id:"class-decorators",title:"Class Decorators",sidebar_position:2},sidebar:"docs",previous:{title:"Introduction",permalink:"/LearningCollection/web/typescript/decorators/introduction"},next:{title:"Method Decorators",permalink:"/LearningCollection/web/typescript/decorators/method-decorators"}},i={},l=[];function d(e){const t={code:"code",p:"p",pre:"pre",strong:"strong",...(0,s.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(t.p,{children:["A Class Decorator is declared just before a class declaration. The class decorator is applied to the constructor of the class and can be ",(0,r.jsx)(t.strong,{children:"used to observe, modify, or replace a class definition"}),". A class decorator cannot be used in a declaration file, or in any other ambient context (such as on a ",(0,r.jsx)(t.code,{children:"declare"})," class)."]}),"\n",(0,r.jsx)(t.p,{children:"The expression for the class decorator will be called as a function at runtime, with the constructor of the decorated class as its only argument. If the class decorator returns a value, it will replace the class declaration with the provided constructor function."}),"\n",(0,r.jsxs)(t.p,{children:["he following is an example of a class decorator (",(0,r.jsx)(t.code,{children:"@sealed"}),") applied to a ",(0,r.jsx)(t.code,{children:"BugReport"})," class:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:'@sealed\nclass BugReport {\n  type = "report";\n  title: string;\n\n  constructor(t: string) {\n    this.title = t;\n  }\n}\n'})}),"\n",(0,r.jsxs)(t.p,{children:["We can define the ",(0,r.jsx)(t.code,{children:"@sealed"})," decorator using the following function declaration:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"function sealed(constructor: Function) {\n  Object.seal(constructor);\n  Object.seal(constructor.prototype);\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["When ",(0,r.jsx)(t.code,{children:"@sealed"})," is executed, it will seal both the constructor and its prototype, and will therefore prevent any further functionality from being added to or removed from this class during runtime by accessing ",(0,r.jsx)(t.code,{children:"BugReport.prototype"})," or by defining properties on ",(0,r.jsx)(t.code,{children:"BugReport"})," itself (note that ES2015 classes are really just syntactic sugar to prototype-based constructor functions). This decorator does not prevent classes from sub-classing ",(0,r.jsx)(t.code,{children:"BugReport"}),"."]}),"\n",(0,r.jsx)(t.p,{children:"Next we have an example of how to override the constructor to set new defaults:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:'function reportableClassDecorator<T extends { new (...args: any[]): {} }>(\n  constructor: T\n) {\n  return class extends constructor {\n    reportingURL = "http://www...";\n  };\n}\n\n@reportableClassDecorator\nclass BugReport {\n  type = "report";\n  title: string;\n\n  constructor(t: string) {\n    this.title = t;\n  }\n}\n\nconst bug = new BugReport("Needs dark mode");\nconsole.log(bug.title); // Prints "Needs dark mode"\nconsole.log(bug.type); // Prints "report"\n\n// Note that the decorator _does not_ change the TypeScript type\n// and so the new property `reportingURL` is not known\n// to the type system:\nbug.reportingURL; // Property \'reportingURL\' does not exist on type \'BugReport\'.\n'})})]})}function p(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},1151:(e,t,o)=>{o.d(t,{Z:()=>a,a:()=>c});var r=o(7294);const s={},n=r.createContext(s);function c(e){const t=r.useContext(n);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),r.createElement(n.Provider,{value:t},e.children)}}}]);