"use strict";(self.webpackChunklearning_knowledge_base=self.webpackChunklearning_knowledge_base||[]).push([[7828],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>g});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,l=e.originalType,s=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),p=d(n),m=i,g=p["".concat(s,".").concat(m)]||p[m]||u[m]||l;return n?a.createElement(g,r(r({ref:t},c),{},{components:n})):a.createElement(g,r({ref:t},c))}));function g(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var l=n.length,r=new Array(l);r[0]=m;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[p]="string"==typeof e?e:i,r[1]=o;for(var d=2;d<l;d++)r[d]=n[d];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},3530:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>u,frontMatter:()=>l,metadata:()=>o,toc:()=>d});var a=n(7462),i=(n(7294),n(3905));const l={id:"entity-types",title:"Entity types",sidebar_position:2},r=void 0,o={unversionedId:"csharp/entity-framework/creating-a-model/entity-types",id:"csharp/entity-framework/creating-a-model/entity-types",title:"Entity types",description:"Including a DbSet of a type on your context means that it is included in EF Core's model; we usually refer to such a type as an entity. EF Core can read and write entity instances from/to the database, and if you're using a relational database, EF Core can create tables for your entities via migrations.",source:"@site/docs/csharp/entity-framework/creating-a-model/entity-types.md",sourceDirName:"csharp/entity-framework/creating-a-model",slug:"/csharp/entity-framework/creating-a-model/entity-types",permalink:"/LearningCollection/csharp/entity-framework/creating-a-model/entity-types",draft:!1,editUrl:"https://github.com/RobinTTY/LearningCollection/tree/master/website/docs/csharp/entity-framework/creating-a-model/entity-types.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{id:"entity-types",title:"Entity types",sidebar_position:2},sidebar:"docs",previous:{title:"Overview",permalink:"/LearningCollection/csharp/entity-framework/creating-a-model/overview"},next:{title:"Integration Testing",permalink:"/LearningCollection/csharp/entity-framework/testing/integration-testing"}},s={},d=[{value:"Including types in the model",id:"including-types-in-the-model",level:2},{value:"Table name",id:"table-name",level:3},{value:"Table schema",id:"table-schema",level:3},{value:"Table comments",id:"table-comments",level:3},{value:"Excluding types from the model",id:"excluding-types-from-the-model",level:2},{value:"View mapping",id:"view-mapping",level:3},{value:"Excluding from migrations",id:"excluding-from-migrations",level:2}],c={toc:d},p="wrapper";function u(e){let{components:t,...n}=e;return(0,i.kt)(p,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Including a DbSet of a type on your context means that it is included in EF Core's model; we usually refer to such a type as an entity. EF Core can read and write entity instances from/to the database, and if you're using a relational database, EF Core can create tables for your entities via migrations."),(0,i.kt)("h2",{id:"including-types-in-the-model"},"Including types in the model"),(0,i.kt)("p",null,"By convention, types that are exposed in DbSet properties on your context are included in the model as entities. Entity types that are specified in the ",(0,i.kt)("inlineCode",{parentName:"p"},"OnModelCreating")," method are also included, as are any types that are found by recursively exploring the navigation properties of other discovered entity types."),(0,i.kt)("p",null,"In the code sample below, all types are included:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Blog")," is included because it's exposed in a DbSet property on the context."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Post")," is included because it's discovered via the ",(0,i.kt)("inlineCode",{parentName:"li"},"Blog.Posts")," navigation property."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"AuditEntry")," because it is specified in OnModelCreating.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"internal class MyContext : DbContext\n{\n    public DbSet<Blog> Blogs { get; set; }\n\n    protected override void OnModelCreating(ModelBuilder modelBuilder)\n    {\n        modelBuilder.Entity<AuditEntry>();\n    }\n}\n\npublic class Blog\n{\n    public int BlogId { get; set; }\n    public string Url { get; set; }\n\n    public List<Post> Posts { get; set; }\n}\n\npublic class Post\n{\n    public int PostId { get; set; }\n    public string Title { get; set; }\n    public string Content { get; set; }\n\n    public Blog Blog { get; set; }\n}\n\npublic class AuditEntry\n{\n    public int AuditEntryId { get; set; }\n    public string Username { get; set; }\n    public string Action { get; set; }\n}\n")),(0,i.kt)("h3",{id:"table-name"},"Table name"),(0,i.kt)("p",null,"By convention, each entity type will be set up to map to a database table with the same name as the ",(0,i.kt)("inlineCode",{parentName:"p"},"DbSet")," property that exposes the entity. If no ",(0,i.kt)("inlineCode",{parentName:"p"},"DbSet")," exists for the given entity, the class name is used."),(0,i.kt)("p",null,"You can manually configure the table name:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"{2,12-13}","{2,12-13}":!0},'/// via annotations\n[Table("blogs")]\npublic class Blog\n{\n    public int BlogId { get; set; }\n    public string Url { get; set; }\n}\n\n/// via fluent API\nprotected override void OnModelCreating(ModelBuilder modelBuilder)\n{\n    modelBuilder.Entity<Blog>()\n        .ToTable("blogs");\n}\n')),(0,i.kt)("h3",{id:"table-schema"},"Table schema"),(0,i.kt)("p",null,"When using a relational database, tables are by convention created in your database's default schema. For example, Microsoft SQL Server will use the ",(0,i.kt)("inlineCode",{parentName:"p"},"dbo")," schema (SQLite does not support schemas)."),(0,i.kt)("p",null,"You can configure tables to be created in a specific schema as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"{2,12-13}","{2,12-13}":!0},'/// via annotations\n[Table("blogs", Schema = "blogging")]\npublic class Blog\n{\n    public int BlogId { get; set; }\n    public string Url { get; set; }\n}\n\n/// via fluent API\nprotected override void OnModelCreating(ModelBuilder modelBuilder)\n{\n    modelBuilder.Entity<Blog>()\n        .ToTable("blogs", schema: "blogging");\n}\n')),(0,i.kt)("p",null,"Rather than specifying the schema for each table, you can also define the default schema at the model level with the fluent API:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"{3}","{3}":!0},'protected override void OnModelCreating(ModelBuilder modelBuilder)\n{\n    modelBuilder.HasDefaultSchema("blogging");\n}\n')),(0,i.kt)("h3",{id:"table-comments"},"Table comments"),(0,i.kt)("p",null,"You can set an arbitrary text comment that gets set on the database table, allowing you to document your schema in the database:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp",metastring:"{2,12-13}","{2,12-13}":!0},'/// via annotations\n[Comment("Blogs managed on the website")]\npublic class Blog\n{\n    public int BlogId { get; set; }\n    public string Url { get; set; }\n}\n\n/// via fluent API\nprotected override void OnModelCreating(ModelBuilder modelBuilder)\n{\n    modelBuilder.Entity<Blog>().ToTable(\n        tableBuilder => tableBuilder.HasComment("Blogs managed on the website"));\n}\n')),(0,i.kt)("h2",{id:"excluding-types-from-the-model"},"Excluding types from the model"),(0,i.kt)("p",null,"If you don't want a type to be included in the model, you can exclude it:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"/// via annotations\n[NotMapped]\npublic class BlogMetadata\n{\n    public DateTime LoadedFromDatabase { get; set; }\n}\n\n/// via fluent API\nprotected override void OnModelCreating(ModelBuilder modelBuilder)\n{\n    modelBuilder.Ignore<BlogMetadata>();\n}\n")),(0,i.kt)("h3",{id:"view-mapping"},"View mapping"),(0,i.kt)("p",null,"Entity types can be mapped to database views using the Fluent API. EF will assume that the referenced view already exists in the database, it will not create it automatically in a migration."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'modelBuilder.Entity<Blog>()\n    .ToView("blogsView", schema: "blogging");\n')),(0,i.kt)("p",null,"Mapping to a view will remove the default table mapping, but the entity type can also be mapped to a table explicitly. In this case the query mapping will be used for queries and the table mapping will be used for updates."),(0,i.kt)("h2",{id:"excluding-from-migrations"},"Excluding from migrations"),(0,i.kt)("p",null,"It is sometimes useful to have the same entity type mapped in multiple ",(0,i.kt)("inlineCode",{parentName:"p"},"DbContext")," types. This is especially true when using ",(0,i.kt)("a",{parentName:"p",href:"https://www.martinfowler.com/bliki/BoundedContext.html"},"bounded contexts"),", for which it is common to have a different ",(0,i.kt)("inlineCode",{parentName:"p"},"DbContext")," type for each bounded context."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'protected override void OnModelCreating(ModelBuilder modelBuilder)\n{\n    modelBuilder.Entity<IdentityUser>()\n        .ToTable("AspNetUsers", t => t.ExcludeFromMigrations());\n}\n')),(0,i.kt)("p",null,"With this configuration migrations will not create the ",(0,i.kt)("inlineCode",{parentName:"p"},"AspNetUsers")," table, but ",(0,i.kt)("inlineCode",{parentName:"p"},"IdentityUser")," is still included in the model and can be used normally."),(0,i.kt)("p",null,"If you need to start managing the table using migrations again then a new migration should be created where ",(0,i.kt)("inlineCode",{parentName:"p"},"AspNetUsers")," is not excluded. The next migration will now contain any changes made to the table."))}u.isMDXComponent=!0}}]);