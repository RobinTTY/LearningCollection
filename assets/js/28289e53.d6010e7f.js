"use strict";(self.webpackChunklearning_knowledge_base=self.webpackChunklearning_knowledge_base||[]).push([[5465],{8911:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>l});var s=t(4848),i=t(8453);const r={id:"functions",title:"Functions",sidebar_position:3},a=void 0,o={id:"web/typescript/core-concepts/functions",title:"Functions",description:"Functions are the basic building block of any application, whether they\u2019re local functions, imported from another module, or methods on a class. They\u2019re also values, and just like other values, TypeScript has many ways to describe how functions can be called.",source:"@site/docs/web/typescript/core-concepts/functions.md",sourceDirName:"web/typescript/core-concepts",slug:"/web/typescript/core-concepts/functions",permalink:"/LearningCollection/web/typescript/core-concepts/functions",draft:!1,unlisted:!1,editUrl:"https://github.com/RobinTTY/LearningCollection/tree/master/website/docs/web/typescript/core-concepts/functions.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{id:"functions",title:"Functions",sidebar_position:3},sidebar:"docs",previous:{title:"Enums",permalink:"/LearningCollection/web/typescript/core-concepts/enums"},next:{title:"Classes",permalink:"/LearningCollection/web/typescript/core-concepts/classes"}},c={},l=[{value:"Type Expressions",id:"type-expressions",level:2},{value:"Rest Parameters",id:"rest-parameters",level:2},{value:"Overloads",id:"overloads",level:2}];function p(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Functions are the basic building block of any application, whether they\u2019re local functions, imported from another module, or methods on a class. They\u2019re also values, and just like other values, TypeScript has many ways to describe how functions can be called."}),"\n",(0,s.jsx)(n.h2,{id:"type-expressions",children:"Type Expressions"}),"\n",(0,s.jsx)(n.p,{children:"The simplest way to describe a function is with a function type expression. These types are syntactically similar to arrow functions:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'function greeter(fn: (a: string) => void) {\n  fn("Hello, World");\n}\n\nfunction printToConsole(s: string) {\n  console.log(s);\n}\n\ngreeter(printToConsole);\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The syntax ",(0,s.jsx)(n.code,{children:"(a: string) => void"})," means \u201ca function with one parameter, named ",(0,s.jsx)(n.code,{children:"a"}),", of type string, that doesn\u2019t have a return value\u201d. Just like with function declarations, if a parameter type isn\u2019t specified, it\u2019s implicitly ",(0,s.jsx)(n.code,{children:"any"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Of course, we can use a type alias to name a function type:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"type GreetFunction = (a: string) => void;\nfunction greeter(fn: GreetFunction) {\n  // ...\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"rest-parameters",children:"Rest Parameters"}),"\n",(0,s.jsxs)(n.p,{children:["When a function has a rest parameter, it is treated as if it were an infinite series of optional parameters. This is unsound from a type system perspective, but from a runtime point of view the idea of an optional parameter is generally not well-enforced since passing ",(0,s.jsx)(n.code,{children:"undefined"})," in that position is equivalent for most functions."]}),"\n",(0,s.jsxs)(n.p,{children:["A rest parameter appears after all other parameters, and uses the ",(0,s.jsx)(n.code,{children:"..."})," syntax:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"function multiply(n: number, ...m: number[]) {\n  return m.map((x) => n * x);\n}\n// 'a' gets value [10, 20, 30, 40]\nconst a = multiply(10, 1, 2, 3, 4);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In TypeScript, the type annotation on these parameters is implicitly ",(0,s.jsx)(n.code,{children:"any[]"})," instead of ",(0,s.jsx)(n.code,{children:"any"}),", and any type annotation given must be of the form ",(0,s.jsx)(n.code,{children:"Array<T>"})," or ",(0,s.jsx)(n.code,{children:"T[]"}),", or a tuple type."]}),"\n",(0,s.jsx)(n.p,{children:"With tuples it is possible to limit the number of elements in the rest parameter:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"function multiply(n: number, ...m: [number, number, number]) {\n  return m.map((x) => n * x);\n}\n// 'a' gets value [10, 20, 30]\nconst a = multiply(10, 1, 2, 3);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"overloads",children:"Overloads"}),"\n",(0,s.jsxs)(n.p,{children:["Some JavaScript functions can be called in a variety of argument counts and types. For example, you might write a function to produce a ",(0,s.jsx)(n.code,{children:"Date"})," that takes either a timestamp (one argument) or a month/day/year specification (three arguments)."]}),"\n",(0,s.jsx)(n.p,{children:"In TypeScript, we can specify a function that can be called in different ways by writing overload signatures:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"function makeDate(timestamp: number): Date;\nfunction makeDate(m: number, d: number, y: number): Date;\nfunction makeDate(mOrTimestamp: number, d?: number, y?: number): Date {\n  if (d !== undefined && y !== undefined) {\n    return new Date(y, mOrTimestamp, d);\n  } else {\n    return new Date(mOrTimestamp);\n  }\n}\nconst d1 = makeDate(12345678);\nconst d2 = makeDate(5, 5, 5);\n// Error if we do this:\nconst d3 = makeDate(1, 3);\n"})}),"\n",(0,s.jsx)(n.p,{children:"In this example, we wrote two overloads: one accepting one argument, and another accepting three arguments. These first two signatures are called the overload signatures."}),"\n",(0,s.jsx)(n.p,{children:"Then, we wrote a function implementation with a compatible signature (for all overload signature). Functions have an implementation signature, but this signature can\u2019t be called directly. Even though we wrote a function with two optional parameters after the required one, it can\u2019t be called with two parameters!"})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var s=t(6540);const i={},r=s.createContext(i);function a(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);