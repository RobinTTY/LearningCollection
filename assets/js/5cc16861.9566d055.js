"use strict";(self.webpackChunklearning_knowledge_base=self.webpackChunklearning_knowledge_base||[]).push([[2960],{3905:(e,t,r)=>{r.d(t,{Zo:()=>s,kt:()=>f});var n=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function c(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var p=n.createContext({}),l=function(e){var t=n.useContext(p),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},s=function(e){var t=l(e.components);return n.createElement(p.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,p=e.parentName,s=c(e,["components","mdxType","originalType","parentName"]),d=l(r),m=a,f=d["".concat(p,".").concat(m)]||d[m]||u[m]||o;return r?n.createElement(f,i(i({ref:t},s),{},{components:r})):n.createElement(f,i({ref:t},s))}));function f(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,i=new Array(o);i[0]=m;var c={};for(var p in t)hasOwnProperty.call(t,p)&&(c[p]=t[p]);c.originalType=e,c[d]="string"==typeof e?e:a,i[1]=c;for(var l=2;l<o;l++)i[l]=r[l];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}m.displayName="MDXCreateElement"},136:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>c,toc:()=>l});var n=r(7462),a=(r(7294),r(3905));const o={id:"parameter-decorators",title:"Parameter Decorators",sidebar_position:6},i=void 0,c={unversionedId:"web/typescript/decorators/parameter-decorators",id:"web/typescript/decorators/parameter-decorators",title:"Parameter Decorators",description:"A Parameter Decorator is declared just before a parameter declaration. The parameter decorator is applied to the function for a class constructor or method declaration. A parameter decorator cannot be used in a declaration file, an overload, or in any other ambient context (such as in a declare class).",source:"@site/docs/web/typescript/decorators/parameter-decorators.md",sourceDirName:"web/typescript/decorators",slug:"/web/typescript/decorators/parameter-decorators",permalink:"/LearningCollection/web/typescript/decorators/parameter-decorators",draft:!1,editUrl:"https://github.com/RobinTTY/LearningCollection/tree/master/website/docs/web/typescript/decorators/parameter-decorators.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{id:"parameter-decorators",title:"Parameter Decorators",sidebar_position:6},sidebar:"finance",previous:{title:"Property Decorators",permalink:"/LearningCollection/web/typescript/decorators/property-decorators"},next:{title:"Compiler Configuration",permalink:"/LearningCollection/web/typescript/compiler-configuration"}},p={},l=[],s={toc:l},d="wrapper";function u(e){let{components:t,...r}=e;return(0,a.kt)(d,(0,n.Z)({},s,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"A Parameter Decorator is declared just before a parameter declaration. The parameter decorator is applied to the function for a class constructor or method declaration. A parameter decorator cannot be used in a declaration file, an overload, or in any other ambient context (such as in a ",(0,a.kt)("inlineCode",{parentName:"p"},"declare")," class)."),(0,a.kt)("p",null,"The expression for the parameter decorator will be called as a function at runtime, with the following three arguments:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Either the constructor function of the class for a static member, or the prototype of the class for an instance member"),(0,a.kt)("li",{parentName:"ol"},"The name of the member"),(0,a.kt)("li",{parentName:"ol"},"The ordinal index of the parameter in the function\u2019s parameter list")),(0,a.kt)("p",null,"The return value of the parameter decorator is ignored."),(0,a.kt)("p",null,"he following is an example of a parameter decorator (",(0,a.kt)("inlineCode",{parentName:"p"},"@required"),") applied to parameter of a member of the ",(0,a.kt)("inlineCode",{parentName:"p"},"BugReport")," class:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'class BugReport {\n  type = "report";\n  title: string;\n\n  constructor(t: string) {\n    this.title = t;\n  }\n\n  @validate\n  print(@required verbose: boolean) {\n    if (verbose) {\n      return `type: ${this.type}\\ntitle: ${this.title}`;\n    } else {\n      return this.title;\n    }\n  }\n}\n')),(0,a.kt)("p",null,"We can then define the ",(0,a.kt)("inlineCode",{parentName:"p"},"@required")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"@validate")," decorators using the following function declarations:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'import "reflect-metadata";\nconst requiredMetadataKey = Symbol("required");\n\nfunction required(\n  target: Object,\n  propertyKey: string | symbol,\n  parameterIndex: number\n) {\n  let existingRequiredParameters: number[] =\n    Reflect.getOwnMetadata(requiredMetadataKey, target, propertyKey) || [];\n  existingRequiredParameters.push(parameterIndex);\n  Reflect.defineMetadata(\n    requiredMetadataKey,\n    existingRequiredParameters,\n    target,\n    propertyKey\n  );\n}\n\nfunction validate(\n  target: any,\n  propertyName: string,\n  descriptor: TypedPropertyDescriptor<Function>\n) {\n  let method = descriptor.value!;\n\n  descriptor.value = function () {\n    let requiredParameters: number[] = Reflect.getOwnMetadata(\n      requiredMetadataKey,\n      target,\n      propertyName\n    );\n    if (requiredParameters) {\n      for (let parameterIndex of requiredParameters) {\n        if (\n          parameterIndex >= arguments.length ||\n          arguments[parameterIndex] === undefined\n        ) {\n          throw new Error("Missing required argument.");\n        }\n      }\n    }\n    return method.apply(this, arguments);\n  };\n}\n')),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"@required")," decorator adds a metadata entry that marks the parameter as required. The ",(0,a.kt)("inlineCode",{parentName:"p"},"@validate")," decorator then wraps the existing ",(0,a.kt)("inlineCode",{parentName:"p"},"greet")," method in a function that validates the arguments before invoking the original method."))}u.isMDXComponent=!0}}]);