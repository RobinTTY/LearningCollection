"use strict";(globalThis.webpackChunklearning_knowledge_base=globalThis.webpackChunklearning_knowledge_base||[]).push([[8919],{16749:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>u,frontMatter:()=>l,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"kubernetes/security/overview","title":"Overview","description":"Kubernetes includes several APIs and security controls, as well as ways to define policies that can form part of how you manage information security.","source":"@site/docs/kubernetes/security/overview.md","sourceDirName":"kubernetes/security","slug":"/kubernetes/security/overview","permalink":"/LearningCollection/kubernetes/security/overview","draft":false,"unlisted":false,"editUrl":"https://github.com/RobinTTY/LearningCollection/tree/master/website/docs/kubernetes/security/overview.md","tags":[],"version":"current","frontMatter":{"id":"overview","title":"Overview"},"sidebar":"docs","previous":{"title":"Cloud Native Security","permalink":"/LearningCollection/kubernetes/security/cloud-native-security"},"next":{"title":"Kustomize","permalink":"/LearningCollection/kubernetes/tools/kustomize"}}');var t=i(74848),r=i(28453);const l={id:"overview",title:"Overview"},c=void 0,o={},a=[{value:"Security Mechanisms",id:"security-mechanisms",level:2},{value:"Authentication Mechanisms",id:"authentication-mechanisms",level:2},{value:"Certificate Issuance",id:"certificate-issuance",level:2},{value:"Authorization",id:"authorization",level:2},{value:"Role-Based Access Control (RBAC)",id:"role-based-access-control-rbac",level:3},{value:"Service Accounts",id:"service-accounts",level:2},{value:"Security Contexts",id:"security-contexts",level:2},{value:"Network policies",id:"network-policies",level:2}];function d(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"Kubernetes includes several APIs and security controls, as well as ways to define policies that can form part of how you manage information security."}),"\n",(0,t.jsx)(n.h2,{id:"security-mechanisms",children:"Security Mechanisms"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Control plane protection: Protects the API server through TLS/Encryption at rest"}),"\n",(0,t.jsx)(n.li,{children:"Secrets: Basic protection for configuration values"}),"\n",(0,t.jsx)(n.li,{children:"Admission controllers intercept API requests and can validate or mutate them"}),"\n",(0,t.jsx)(n.li,{children:"Workload protection: Network policies/Runtime classes/Pod security standards"}),"\n",(0,t.jsx)(n.li,{children:"Auditing: Auditing of actions inside the cluster"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"authentication-mechanisms",children:"Authentication Mechanisms"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"There are service accounts and normal users managed by Kubernetes"}),"\n",(0,t.jsxs)(n.li,{children:["Authentication relies on:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Static password file (Basic Auth file)"}),"\n",(0,t.jsx)(n.li,{children:"Static token file (Token Auth file)"}),"\n",(0,t.jsx)(n.li,{children:"Certificates"}),"\n",(0,t.jsx)(n.li,{children:"Identity Providers"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"The Kube-API, ETCD and Kubelet server all have certificates"}),"\n",(0,t.jsx)(n.li,{children:"Users, the Kube-Scheduler, Kube-Controller-Manager and Kube Proxy have client certificates"}),"\n",(0,t.jsxs)(n.li,{children:["There can be different certificate authorities in the cluster","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"All certs must be signed by a valid CA in the cluster"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Specified in ",(0,t.jsx)(n.code,{children:"/etc/kubernetes/manifests/kube-apiserver.yaml"})," and ",(0,t.jsx)(n.code,{children:"/etc/kubernetes/manifests/etcd.yaml"})]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"certificate-issuance",children:"Certificate Issuance"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Certificates necessary to access the Kubernetes API can be issued automatically"}),"\n",(0,t.jsxs)(n.li,{children:["Process:","\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Create CertificateSigningRequest (CSR) object"}),"\n",(0,t.jsx)(n.li,{children:"Admin reviews and approves the CSR"}),"\n",(0,t.jsx)(n.li,{children:"Kubernetes issues the certificate"}),"\n",(0,t.jsx)(n.li,{children:"Client can use the certificate to access the API"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"User needs a private key and generates a CSR -> sent to admin"}),"\n",(0,t.jsx)(n.li,{children:"Admin creates CSR object from CSR sent by user (encoded to base64)"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"authorization",children:"Authorization"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Authorization Mechanisms: Node, ABAC, RBAC, Webhook","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"ABAC: applies directly to users/groups"}),"\n",(0,t.jsx)(n.li,{children:"Webhook: external service called to authorize requests"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"Multiple authorizers can be used (one approval needed)"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"role-based-access-control-rbac",children:"Role-Based Access Control (RBAC)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Step 1: Create Role or ClusterRole"}),"\n",(0,t.jsx)(n.li,{children:"Step 2: Create RoleBinding or ClusterRoleBinding"}),"\n",(0,t.jsx)(n.li,{children:"Roles define permissions within a namespace"}),"\n",(0,t.jsx)(n.li,{children:"ClusterRoles define permissions cluster-wide"}),"\n",(0,t.jsx)(n.li,{children:"RoleBindings bind Roles to users/groups/service accounts within a namespace"}),"\n",(0,t.jsx)(n.li,{children:"ClusterRoleBindings bind ClusterRoles to users/groups/service accounts cluster-wide"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"service-accounts",children:"Service Accounts"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Used by pods to interact with the Kubernetes API"}),"\n",(0,t.jsxs)(n.li,{children:["Each namespace has a default service account","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Each pod has this service account assigned if no other SA is specified"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"security-contexts",children:"Security Contexts"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Defines privilege and access control settings for a pod/container","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Example: 'Privileged' policy lets a pod access the hosts network"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["The context can be set on pod or container level","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Capabilities can only be assigned on the container level"}),"\n",(0,t.jsx)(n.li,{children:"if context is defined on container and pod level, the container level settings override the ones on pod level for the relevant container"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"network-policies",children:"Network policies"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Control traffic flow at IP address or port level"}),"\n",(0,t.jsx)(n.li,{children:"Allow to set rules inside cluster and between pods and outside world"}),"\n",(0,t.jsx)(n.li,{children:"Traffic inside cluster is not restricted by default"}),"\n",(0,t.jsx)(n.li,{children:"Network policies are linked to pods via labels/pod selectors"}),"\n",(0,t.jsx)(n.li,{children:"The networking plugin needs to support Network policies for them to be enforced"}),"\n",(0,t.jsx)(n.li,{children:"If a network policy with type ingress/egress is applied to a pod it becomes isolated to all ports which are not specifically allowed"}),"\n",(0,t.jsx)(n.li,{children:"Rules are stateful (no explicit allow for response traffic needed)"}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>c});var s=i(96540);const t={},r=s.createContext(t);function l(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);