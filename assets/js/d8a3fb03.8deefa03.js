"use strict";(self.webpackChunklearning_knowledge_base=self.webpackChunklearning_knowledge_base||[]).push([[4815],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>u});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),d=p(n),u=r,h=d["".concat(s,".").concat(u)]||d[u]||c[u]||o;return n?a.createElement(h,i(i({ref:t},m),{},{components:n})):a.createElement(h,i({ref:t},m))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},2912:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>m});var a=n(7462),r=(n(7294),n(3905)),o=n(4996);const i={id:"components",title:"Components",sidebar_position:2},l=void 0,s={unversionedId:"Web/lit/components",id:"Web/lit/components",title:"Components",description:"A Lit component is a reusable piece of UI. You can think of a Lit component as a container that has some state and that displays a UI based on its state. It can also react to user input, fire events\u2014anything you'd expect a UI component to do. And a Lit component is an HTML element, so it has all of the standard element APIs.",source:"@site/docs/Web/lit/components.mdx",sourceDirName:"Web/lit",slug:"/Web/lit/components",permalink:"/LearningCollection/Web/lit/components",draft:!1,editUrl:"https://github.com/RobinTTY/LearningCollection/tree/master/website/docs/Web/lit/components.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{id:"components",title:"Components",sidebar_position:2},sidebar:"finance",previous:{title:"Introduction",permalink:"/LearningCollection/Web/lit/intro"},next:{title:"Docusaurus",permalink:"/LearningCollection/Web/Static Site Generators/docusaurus"}},p={},m=[{value:"Defining a component",id:"defining-a-component",level:2},{value:"A Lit component is an HTML element",id:"a-lit-component-is-an-html-element",level:3},{value:"Providing good TypeScript typings",id:"providing-good-typescript-typings",level:3},{value:"Rendering",id:"rendering",level:2},{value:"Renderable values",id:"renderable-values",level:3},{value:"A good <code>render()</code> method",id:"a-good-render-method",level:3},{value:"Composing templates",id:"composing-templates",level:3},{value:"When templates render",id:"when-templates-render",level:3},{value:"DOM Encapsulation",id:"dom-encapsulation",level:3},{value:"Reactive Properties",id:"reactive-properties",level:2}],c={toc:m};function d(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A Lit component is a reusable piece of UI. You can think of a Lit component as a container that has some state and that displays a UI based on its state. It can also react to user input, fire events\u2014anything you'd expect a UI component to do. And a Lit component is an HTML element, so it has all of the standard element APIs."),(0,r.kt)("p",null,"Creating a Lit component involves a number of concepts:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://lit.dev/docs/components/defining/"},"Defining a component"),": A Lit component is implemented as a custom element, registered with the browser."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://lit.dev/docs/components/rendering/"},"Rendering"),": A component has render method that's called to render the component's contents. In the render method, you define a template for the component."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://lit.dev/docs/components/properties/"},"Reactive properties"),": Properties hold the state of the component. Changing one or more of the components' reactive properties triggers an update cycle, re-rendering the component."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://lit.dev/docs/components/styles/"},"Styles"),": A component can define encapsulated styles to control its own appearance."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://lit.dev/docs/components/lifecycle/"},"Lifecycle"),": Lit defines a set of callbacks that you can override to hook into the component's lifecycle\u2014for example, to run code when the element's added to a page, or whenever the component updates.")),(0,r.kt)("h2",{id:"defining-a-component"},"Defining a component"),(0,r.kt)("p",null,"A Lit component is defined by creating a class, extending it with ",(0,r.kt)("inlineCode",{parentName:"p"},"LitElement")," and registering the class with the browser:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'@customElement("simple-greeting")\nexport class SimpleGreeting extends LitElement {\n  /* ... */\n}\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"@customElement")," decorator is shorthand for calling ",(0,r.kt)("inlineCode",{parentName:"p"},"customElements.define"),", which registers a custom element class with the browser and associates it with an element name (in this case, ",(0,r.kt)("inlineCode",{parentName:"p"},"simple-greeting"),")."),(0,r.kt)("h3",{id:"a-lit-component-is-an-html-element"},"A Lit component is an HTML element"),(0,r.kt)("p",null,"When you define a Lit component, you're defining a ",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements"},"custom HTML element"),". So you can use the new element like you'd use any built-in element:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-html"},'<simple-greeting name="Markup"></simple-greeting>\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const greeting = document.createElement("simple-greeting");\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"LitElement")," base class is a subclass of ",(0,r.kt)("inlineCode",{parentName:"p"},"HTMLElement"),", so a Lit component inherits all of the standard ",(0,r.kt)("inlineCode",{parentName:"p"},"HTMLElement")," properties and methods."),(0,r.kt)("p",null,"Specifically, ",(0,r.kt)("inlineCode",{parentName:"p"},"LitElement")," inherits from ",(0,r.kt)("inlineCode",{parentName:"p"},"ReactiveElement"),", which implements reactive properties, and in turn inherits from ",(0,r.kt)("inlineCode",{parentName:"p"},"HTMLElement"),"."),(0,r.kt)("div",{style:{textAlign:"center"}},(0,r.kt)("img",{src:(0,o.Z)("/img/docs/Web/lit/lit-element-inheritance.png")})),(0,r.kt)("h3",{id:"providing-good-typescript-typings"},"Providing good TypeScript typings"),(0,r.kt)("p",null,"TypeScript will infer the class of an HTML element returned from certain DOM APIs based on the tag name. For example, ",(0,r.kt)("inlineCode",{parentName:"p"},"document.createElement('img')")," returns an ",(0,r.kt)("inlineCode",{parentName:"p"},"HTMLImageElement")," instance with a ",(0,r.kt)("inlineCode",{parentName:"p"},"src: string")," property."),(0,r.kt)("p",null,"Custom elements can get this same treatment by adding to the ",(0,r.kt)("inlineCode",{parentName:"p"},"HTMLElementTagNameMap")," as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'@customElement("my-element")\nexport class MyElement extends LitElement {\n  @property({ type: Number })\n  aNumber: number = 5;\n  /* ... */\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    "my-element": MyElement;\n  }\n}\n')),(0,r.kt)("p",null,"By doing this, the following code properly type-checks:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const myElement = document.createElement("my-element");\nmyElement.aNumber = 10;\n')),(0,r.kt)("p",null,"It is recommended to add an ",(0,r.kt)("inlineCode",{parentName:"p"},"HTMLElementTagNameMap")," entry for all elements authored in TypeScript, and ensuring to publish the ",(0,r.kt)("inlineCode",{parentName:"p"},".d.ts")," typings in the npm package."),(0,r.kt)("h2",{id:"rendering"},"Rendering"),(0,r.kt)("p",null,"A template defines what the component should render. Templates can include expressions, which are placeholders for dynamic content."),(0,r.kt)("p",null,"To define a template for a Lit component, add a ",(0,r.kt)("inlineCode",{parentName:"p"},"render()")," method:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { LitElement, html } from "lit";\nimport { customElement } from "lit/decorators.js";\n\n@customElement("my-element")\nclass MyElement extends LitElement {\n  render() {\n    return html`<p>Hello from my template.</p>`;\n  }\n}\n')),(0,r.kt)("p",null,"The template is written in HTML inside a JavaScript ",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates"},"tagged template literal")," using Lit's ",(0,r.kt)("inlineCode",{parentName:"p"},"html")," tag function."),(0,r.kt)("p",null,"Lit templates can include JavaScript expressions. You can use expressions to set text content, attributes, properties, and event listeners. The ",(0,r.kt)("inlineCode",{parentName:"p"},"render()")," method can also include any JavaScript\u2014for example, you can create local variables for use in expressions."),(0,r.kt)("h3",{id:"renderable-values"},"Renderable values"),(0,r.kt)("p",null,"Typically, the component's ",(0,r.kt)("inlineCode",{parentName:"p"},"render()")," method returns a single ",(0,r.kt)("inlineCode",{parentName:"p"},"TemplateResult")," object (the same type returned by the ",(0,r.kt)("inlineCode",{parentName:"p"},"html")," tag function). However, it can return anything that Lit can render as the child of an HTML element:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Primitive values like string, number, or boolean"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"TemplateResult")," objects created by the ",(0,r.kt)("inlineCode",{parentName:"li"},"html")," function"),(0,r.kt)("li",{parentName:"ul"},"DOM Nodes\nThe sentinel values ",(0,r.kt)("a",{parentName:"li",href:"https://lit.dev/docs/templates/conditionals/#conditionally-rendering-nothing"},(0,r.kt)("inlineCode",{parentName:"a"},"nothing"))," and ",(0,r.kt)("a",{parentName:"li",href:"https://lit.dev/docs/templates/custom-directives/#signaling-no-change"},(0,r.kt)("inlineCode",{parentName:"a"},"noChange"))),(0,r.kt)("li",{parentName:"ul"},"Arrays or iterables of any of the supported types")),(0,r.kt)("p",null,"This is almost identical to the set of values that can be rendered to a Lit ",(0,r.kt)("a",{parentName:"p",href:"https://lit.dev/docs/templates/expressions/#child-expressions"},"child expression"),". The one difference is that a child expression can render an ",(0,r.kt)("inlineCode",{parentName:"p"},"SVGTemplateResult"),", returned by the ",(0,r.kt)("inlineCode",{parentName:"p"},"svg")," function. This kind of template result can only be rendered as the descendant of an ",(0,r.kt)("inlineCode",{parentName:"p"},"<svg>")," element."),(0,r.kt)("h3",{id:"a-good-render-method"},"A good ",(0,r.kt)("inlineCode",{parentName:"h3"},"render()")," method"),(0,r.kt)("p",null,"To take best advantage of Lit's functional rendering model, the render() method should follow these guidelines:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Avoid changing the component's state"),(0,r.kt)("li",{parentName:"ul"},"Avoid producing any side effects"),(0,r.kt)("li",{parentName:"ul"},"Use only the component's properties as input"),(0,r.kt)("li",{parentName:"ul"},"Return the same result when given the same property values")),(0,r.kt)("p",null,"Following these guidelines keeps the template deterministic, and makes it easier to reason about the code."),(0,r.kt)("p",null,"In most cases you should avoid making DOM updates outside of ",(0,r.kt)("inlineCode",{parentName:"p"},"render()"),". Instead, express the component's template as a function of its state, and capture its state in properties."),(0,r.kt)("p",null,"For example, if your component needs to update its UI when it receives an event, have the event listener set a reactive property that is used in ",(0,r.kt)("inlineCode",{parentName:"p"},"render()"),", rather than manipulate the DOM directly."),(0,r.kt)("p",null,"For more information, see ",(0,r.kt)("a",{parentName:"p",href:"https://lit.dev/docs/components/properties/"},"Reactive properties"),"."),(0,r.kt)("h3",{id:"composing-templates"},"Composing templates"),(0,r.kt)("p",null,"You can compose Lit templates from other templates. The following example composes a template for a component called ",(0,r.kt)("inlineCode",{parentName:"p"},"<my-page>")," from smaller templates for the page's header, footer, and main content:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { LitElement, html } from "lit";\nimport { customElement, property } from "lit/decorators.js";\n\n@customElement("my-page")\nclass MyPage extends LitElement {\n  @property({ attribute: false })\n  article = {\n    title: "My Nifty Article",\n    text: "Some witty text.",\n  };\n\n  headerTemplate() {\n    return html`<header>${this.article.title}</header>`;\n  }\n\n  articleTemplate() {\n    return html`<article>${this.article.text}</article>`;\n  }\n\n  footerTemplate() {\n    return html`<footer>Your footer here.</footer>`;\n  }\n\n  render() {\n    return html`\n      ${this.headerTemplate()} ${this.articleTemplate()} ${this.footerTemplate()}\n    `;\n  }\n}\n')),(0,r.kt)("p",null,"In this example, the individual templates are defined as instance methods, so a subclass could extend this component and override one or more templates."),(0,r.kt)("p",null,"You can also compose templates by importing other elements and using them in your template:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { LitElement, html } from "lit";\nimport { customElement } from "lit/decorators.js";\n\nimport "./my-header.js";\nimport "./my-article.js";\nimport "./my-footer.js";\n\n@customElement("my-page")\nclass MyPage extends LitElement {\n  render() {\n    return html`\n      <my-header></my-header>\n      <my-article></my-article>\n      <my-footer></my-footer>\n    `;\n  }\n}\n')),(0,r.kt)("h3",{id:"when-templates-render"},"When templates render"),(0,r.kt)("p",null,"A Lit component renders its template initially when it's added to the DOM on a page. After the initial render, any change to the component's reactive properties triggers an update cycle, re-rendering the component."),(0,r.kt)("p",null,"Lit batches updates to maximize performance and efficiency. Setting multiple properties at once triggers only one update, performed asynchronously at microtask timing."),(0,r.kt)("p",null,"During an update, only the parts of the DOM that change are re-rendered. Although Lit templates look like string interpolation, Lit parses and creates static HTML once, and then only updates changed values in expressions after that, making updates very efficient."),(0,r.kt)("h3",{id:"dom-encapsulation"},"DOM Encapsulation"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Lit uses shadow DOM to encapsulate the DOM a component renders.")," Shadow DOM lets an element create its own, isolated DOM tree that's separate from the main document tree. It's a core feature of the web components specifications that enables interoperability, style encapsulation, and other benefits."),(0,r.kt)("h2",{id:"reactive-properties"},"Reactive Properties"),(0,r.kt)("p",null,"Lit components receive input and store their state as JavaScript class fields or properties. Reactive properties are properties that can trigger the reactive update cycle when changed, re-rendering the component, and optionally be read or written to attributes."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"class MyElement extends LitElement {\n  @property()\n  name: string;\n}\n")),(0,r.kt)("p",null,"Lit manages your reactive properties and their corresponding attributes. In particular:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Reactive updates:")," Lit generates a getter/setter pair for each reactive property. When a reactive property changes, the component schedules an update."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Attribute handling:")," By default, Lit sets up an observed attribute corresponding to the property, and updates the property when the attribute changes. Property values can also, optionally, be reflected back to the attribute."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Superclass properties:")," Lit automatically applies property options declared by a superclass. You don't need to redeclare properties unless you want to change options."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Element upgrade:")," If a Lit component is defined after the element is already in the DOM, Lit handles upgrade logic, ensuring that any properties set on an element before it was upgraded trigger the correct reactive side effects when the element upgrades.")))}d.isMDXComponent=!0}}]);