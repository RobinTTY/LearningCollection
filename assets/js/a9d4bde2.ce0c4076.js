"use strict";(self.webpackChunklearning_knowledge_base=self.webpackChunklearning_knowledge_base||[]).push([[2617],{3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return m}});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=a.createContext({}),c=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},u=function(e){var n=c(e.components);return a.createElement(s.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=c(t),m=i,h=d["".concat(s,".").concat(m)]||d[m]||p[m]||o;return t?a.createElement(h,r(r({ref:n},u),{},{components:t})):a.createElement(h,r({ref:n},u))}));function m(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,r=new Array(o);r[0]=d;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,r[1]=l;for(var c=2;c<o;c++)r[c]=t[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},3780:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return c},toc:function(){return u},default:function(){return d}});var a=t(7462),i=t(3366),o=(t(7294),t(3905)),r=["components"],l={id:"userFacingBackend",title:"User-Facing Backend",sidebar_position:4},s=void 0,c={unversionedId:"Databases/MongoDB/M220N MongoDB for .NET Developers/userFacingBackend",id:"Databases/MongoDB/M220N MongoDB for .NET Developers/userFacingBackend",isDocsHomePage:!1,title:"User-Facing Backend",description:"Aggregation Pipeline",source:"@site/docs/Databases/MongoDB/M220N MongoDB for .NET Developers/User-Facing Backend.md",sourceDirName:"Databases/MongoDB/M220N MongoDB for .NET Developers",slug:"/Databases/MongoDB/M220N MongoDB for .NET Developers/userFacingBackend",permalink:"/LearningCollection/Databases/MongoDB/M220N MongoDB for .NET Developers/userFacingBackend",editUrl:"https://github.com/RobinTTY/LearningCollection/tree/master/website/docs/Databases/MongoDB/M220N MongoDB for .NET Developers/User-Facing Backend.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{id:"userFacingBackend",title:"User-Facing Backend",sidebar_position:4},sidebar:"mySidebar",previous:{title:"Using the Driver",permalink:"/LearningCollection/Databases/MongoDB/M220N MongoDB for .NET Developers/usingTheDriver"},next:{title:"Admin Backend",permalink:"/LearningCollection/Databases/MongoDB/M220N MongoDB for .NET Developers/adminBackend"}},u=[{value:"Aggregation Pipeline",id:"aggregation-pipeline",children:[{value:"Example",id:"example",children:[]},{value:"Example of a similar (but not the same) pipeline in C#",id:"example-of-a-similar-but-not-the-same-pipeline-in-c",children:[]}]},{value:"Faceted Search",id:"faceted-search",children:[{value:"MFlix Functionality",id:"mflix-functionality",children:[]}]},{value:"Basic Writes",id:"basic-writes",children:[{value:"Example",id:"example-1",children:[]}]},{value:"Basic Updates",id:"basic-updates",children:[{value:"Examples",id:"examples",children:[]}]},{value:"Write Concerns",id:"write-concerns",children:[{value:"writeConcern: { w: 1 }",id:"writeconcern--w-1-",children:[]},{value:"writeConcern: { w: majority }",id:"writeconcern--w-majority-",children:[]},{value:"writeConcern: { w: 0 }",id:"writeconcern--w-0-",children:[]},{value:"Example",id:"example-2",children:[]}]},{value:"Joins",id:"joins",children:[]},{value:"Basic Deletes",id:"basic-deletes",children:[]}],p={toc:u};function d(e){var n=e.components,l=(0,i.Z)(e,r);return(0,o.kt)("wrapper",(0,a.Z)({},p,l,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"aggregation-pipeline"},"Aggregation Pipeline"),(0,o.kt)("h3",{id:"example"},"Example"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Aggregation Pipeline",src:t(4675).Z})),(0,o.kt)("h3",{id:"example-of-a-similar-but-not-the-same-pipeline-in-c"},"Example of a similar (but not the same) pipeline in C#"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-C#"},'public void CountMovies()\n        {\n            // This stage finds all movies that have a specific director\n            var matchStage = new BsonDocument("$match",\n                new BsonDocument("directors", "Rob Reiner"));\n\n\n            // This stage sorts the results by the number of reviews,\n            // in descending order\n            var sortStage = new BsonDocument("$sort",\n                new BsonDocument("tomatoes.viewer.numReviews", -1));\n\n            // This stage generates the projection we want\n            var projectionStage = new BsonDocument("$project",\n                new BsonDocument\n                    {\n                        { "_id", 0 },\n                        { "Movie Title", "$title" },\n                        { "Year", "$year" },\n                        { "Average User Rating", "$tomatoes.viewer.rating" }\n                    });\n\n            /* We now put the stages together in a pipeline. Note that a\n             * pipeline definition requires us to specify the input and output\n             * types. In this case, the input is of type Movie, but because\n             * we are using a Projection with custom fields, our output is\n             * a generic BsonDocument object. To be really cool, we could\n             * create a mapping class for the output type, which is what we\'ve\n             * done for you in the MFlix application.\n             */\n\n            var pipeline = PipelineDefinition<Movie, BsonDocument>\n                .Create(new BsonDocument[] {\n                    matchStage,\n                    sortStage,\n                    projectionStage\n                });\n\n\n            var result = _moviesCollection.Aggregate(pipeline).ToList();\n            /* Note: we\'re making a synchronous Aggregate() call.\n             * If you want a challenge, change the line above to make an\n             * asynchronous call (hint: you\'ll need to make 2 changes),\n             * and then confirm the unit test still passes.\n             */\n\n            Assert.AreEqual(14, result.Count);\n            var firstMovie = result[0];\n            Assert.AreEqual("The Princess Bride", firstMovie.GetValue("Movie Title").AsString);\n            Assert.AreEqual(1987, firstMovie.GetValue("Year").AsInt32);\n            Assert.AreEqual(4.0, firstMovie.GetValue("Average User Rating").AsDouble);\n\n            /* We specifically excluded the "Id" field in the projection stage\n             * that we built in the code above, so let\'s make sure that field\n             * wasn\'t included in the resulting BsonDocument. We expect the call\n             * to GetValue() to throw a KeyNotFoundException exception if the\n             * field doesn\'t exist.\n             */\n\n            Assert.Throws<KeyNotFoundException>(()=> firstMovie.GetValue("Id"));\n        }\n')),(0,o.kt)("h2",{id:"faceted-search"},"Faceted Search"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"http://en.wikipedia.org/wiki/Faceted_search"},"Faceted search"),", or faceted navigation, is a way of browsing and searching for items in a set of data by applying filters on various properties (facets) of the items in the collection"),(0,o.kt)("li",{parentName:"ul"},"It is increasingly seen as an important part of the UI for many search platforms, and indeed nowadays is pretty much expected in places such as e-commerce websites"),(0,o.kt)("li",{parentName:"ul"},"It complements more free-form keyword search by facilitating exploration and discovery and is therefore useful when a user may not know the specific keywords they wish to search on.")),(0,o.kt)("p",null,"Some core functionality that a faceted search feature should provide might include:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"finding the items that match a particular value of a certain facet (e.g. colour:blue)"),(0,o.kt)("li",{parentName:"ul"},"finding the items in the intersection of multiple facet values (e.g. colour:blue AND size:medium)"),(0,o.kt)("li",{parentName:"ul"},"finding the items in the union of multiple facet values (e.g. colour:blue OR colour:red OR size:large)"),(0,o.kt)("li",{parentName:"ul"},"for each possible facet filter combination, display to the user the possible facet values on which it is possible to filter further (\u201cdrill down\u201d)"),(0,o.kt)("li",{parentName:"ul"},"for each facet value on which it is possible to drill down, display to the user the count of items matching that filter.")),(0,o.kt)("p",null,"For more info see the ",(0,o.kt)("a",{parentName:"p",href:"https://www.mongodb.com/blog/post/faceted-search-with-mongodb"},"MongoDB Blog"),"."),(0,o.kt)("h3",{id:"mflix-functionality"},"MFlix Functionality"),(0,o.kt)("p",null,"Faceted Search is a way of narrowing down search results by adding search parameters. For example let's say MFlix allows users to filter movies by a rating from 1 to 10, but Kate Winslet has only acted in movies that have a rating of 6 or higher."),(0,o.kt)("p",null,'If we didn\'t specify any other search parameters, MFlix would allow us to choose a rating between 1 and 10. But if we first search for "Kate Winslet", MFlix would only let us choose a rating between 6 and 10, because none of the movie documents in the result set have a rating below 6.'),(0,o.kt)("p",null,"To use faceted searches, the application must use the ",(0,o.kt)("strong",{parentName:"p"},"$facet pipeline stage")," of the Aggregation Framework."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note:")," To see how facets work see the ",(0,o.kt)("a",{parentName:"p",href:"https://university.mongodb.com/courses/M121/about"},"Aggregation Framework Course"),"."),(0,o.kt)("h2",{id:"basic-writes"},"Basic Writes"),(0,o.kt)("p",null,"To add something new to the database we can use the methods ",(0,o.kt)("inlineCode",{parentName:"p"},"InsertOneAsync")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"InsertManyAsync"),"."),(0,o.kt)("h3",{id:"example-1"},"Example"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-C#"},'public async Task CreateMovieAsync()\n{\n\n    var newTheater = new Theater(27777,\n                    "4 Privet Drive",\n                    "Little Whinging",\n                    "LA",\n                    "343434");\n\n    await _theatersCollection.InsertOneAsync(newTheater);\n\n\n    // Add many\n    var theater1 = new Theater(27017, "1 Foo Street", "Dingledongle", "DE", "45678");\n    var theater2 = new Theater(27018, "234 Bar Ave.", "Wishywashy", "WY", "87654");\n    var theater3 = new Theater(27019, "75 Birthday Road", "Viejo Amigo", "CA", "99887");\n\n    await _theatersCollection.InsertManyAsync(\n        new List<Theater>()\n        {\n            theater1, theater2, theater3\n        }\n    );\n}\n')),(0,o.kt)("h2",{id:"basic-updates"},"Basic Updates"),(0,o.kt)("p",null,"To update something in the database we can use the methods ",(0,o.kt)("inlineCode",{parentName:"p"},"UpdateOneAsync"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"UpdateManyAsync")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"FindOneAndUpdateAsync"),"."),(0,o.kt)("h3",{id:"examples"},"Examples"),(0,o.kt)("p",null,"Updating one document:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-C#"},'// not type safe\nvar updateResult = _theatersCollection.UpdateOne(filter,\n    new BsonDocument("$set",\n        new BsonDocument("location.address.street1", "123 Main St."))\n    );\n\n// With the builder\n_theatersCollection.UpdateOne(filter,\n    Builders<Theater>.Update.Set(t => t.Location.Address.Street1,\n        "123 Main St.")\n    );\n\n// if you want to do something with the updated document use FindOneAndUpdateAsync\nvar updatedDoc = await _theatersCollection.FindOneAndUpdateAsync<Theater>(\n                filter,\n                Builders<Theater>.Update.Set(\n                    t => t.Location.Address.Street1,\n                    "123 Main St.")\n                );\n')),(0,o.kt)("p",null,"Updating many documents:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-C#"},'var update = Builders<Theater>\n                .Update.Set(t => t.Location.Address.City, "Bloomington");\n\n// And then we run UpdateManyAsync:\nvar result = await _theatersCollection.UpdateManyAsync(\n    filter,\n    update\n    );\n')),(0,o.kt)("h2",{id:"write-concerns"},"Write Concerns"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Write concerns are important when there are more than one data source"),(0,o.kt)("li",{parentName:"ul"},"An Atlas replica set is an example where write concerns can be important")),(0,o.kt)("h3",{id:"writeconcern--w-1-"},"writeConcern: { w: 1 }"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Only requests an acknowledgement that one node applied the write"),(0,o.kt)("li",{parentName:"ul"},"This is the default writeConcern in MongoDB")),(0,o.kt)("h3",{id:"writeconcern--w-majority-"},"writeConcern: { w: majority }"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Requests acknowledgement that a majority of nodes in the replica set applied the write"),(0,o.kt)("li",{parentName:"ul"},"Takes longer than w: 1"),(0,o.kt)("li",{parentName:"ul"},"Is more durable than w: 1",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Useful for ensuring vital writes are majority-committed"),(0,o.kt)("li",{parentName:"ul"},"e.g. user registration")))),(0,o.kt)("h3",{id:"writeconcern--w-0-"},"writeConcern: { w: 0 }"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Does not request an acknowledgement that any nodes applied the write",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},'"Fire and forget"'),(0,o.kt)("li",{parentName:"ul"},"acknowledgement can still indicate network errors or socket exceptions"))),(0,o.kt)("li",{parentName:"ul"},"Fastest writeConcern level"),(0,o.kt)("li",{parentName:"ul"},"Least durable writeConcern")),(0,o.kt)("h3",{id:"example-2"},"Example"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-C#"},"await _usersCollection.WithWriteConcern(WriteConcern.WMajority).InsertOneAsync(user, cancellationToken: cancellationToken);\n")),(0,o.kt)("h2",{id:"joins"},"Joins"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Join two collections of data",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Movies and comments"))),(0,o.kt)("li",{parentName:"ul"},"Use new expressive $lookup",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"allows us to apply aggregation pipelines to data - before the data is joined"))),(0,o.kt)("li",{parentName:"ul"},"Build aggregation in Compass, and then export to language")),(0,o.kt)("p",null,"Join comments to movies (this pipeline is executed upon the movies collection):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-C#"},'// $match stage\n{\n  year: { "$gte": 1980, "$lt": 1990 }\n}\n\n// $lookup stage\n// from: collection we are joining from\n{\n  from: "comments",\n  // pipeline has access to fields inside comments collection\n  // but not to fields inside the movies collection\n  // if we need fields from movies we need to declare them in let\n  // this makes _id available in the pipeline as "id"\n  // this variable is referred to with the "$$" signs (movies collection)\n  // one "$" sign refers to the comments collection!\n  let: { "id": "$_id" },\n  pipeline: [\n    {\n      "$match":\n      // matches the comment "movie_id" field to the movie "id" field\n      { "$expr": { "$eq": [ "$movie_id", "$$id" ]} }\n    }\n  ],\n  // each movie has a new field movie_comments with the comments as array\n  as: "movie_comments"\n}\n\n// if we only care about how many comments there are, we can add a stage to our pipeline\n{\n  from: "comments",\n  let: { "id": "$_id" },\n  pipeline: [\n    {\n      "$match":\n      { "$expr": { "$eq": [ "$movie_id", "$$id" ]} }\n    },\n    {\n      "$count": "count"\n    }\n  ],\n  as: "movie_comments"\n}\n')),(0,o.kt)("p",null,"We can also export the pipeline from Compass to C# code:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-C#"},'new BsonArray\n{\n    new BsonDocument("$match",\n    new BsonDocument("year",\n    new BsonDocument\n            {\n                { "$gte", 1980 },\n                { "$lt", 1990 }\n            })),\n    new BsonDocument("$lookup",\n    new BsonDocument\n        {\n            { "from", "comments" },\n            { "let",\n    new BsonDocument("id", "$_id") },\n            { "pipeline",\n    new BsonArray\n            {\n                new BsonDocument("$match",\n                new BsonDocument("$expr",\n                new BsonDocument("$eq",\n                new BsonArray\n                            {\n                                "$movie_id",\n                                "$$id"\n                            })))\n            } },\n            { "as", "movie_comments" }\n        })\n}\n')),(0,o.kt)("p",null,"Better approach:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-C#"},'/* Approach that uses several helpful methods in the driver:\n    * Aggregate(), Match(), and Lookup(), each of which is represented\n    * in the code above as MQL. The Lookup() method is a bit complex;\n    * here is an explanation of each of the parameters:\n    *\n    *  - The collection from which we want to lookup the values\n    *      (in this case, the Comments collection)\n    *  - The "key" in the Movies collection that will match a key in\n    *      the Comments collection.\n    *  - The "key" in the Comments collection that matches the previous\n    *      parameter. In both cases, it\'s the _id of each Movie we match\n    *      in the Match state.\n    *  - The property in which we want to put the lookup results. We\n    *      have already defined a Comments property on the Movie object\n    *      for just this purpose, so we specify it here.\n    *\n    */\nvar movies = _moviesCollection\n    .Aggregate()  // begins a fluent aggregation\n    .Match(m => (int)m.Year < 1990 && (int)m.Year >= 1980)\n    .Lookup(\n        _commentsCollection,\n        m => m.Id,\n        c => c.MovieId,\n        (Movie m)=>m.Comments\n        )\n    .ToList();\n\nvar firstMovie = movies.First();\n')),(0,o.kt)("h2",{id:"basic-deletes"},"Basic Deletes"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-C#"},'// delete one document\nvar filter = Builders<Theater>.Filter.Eq(t => t.TheaterId, 27017);\nvar result = await _theatersCollection.DeleteOneAsync(filter);\n\n// delete one document but return it\nfilter = Builders<Theater>.Filter.Eq(t => t.TheaterId, 27018);\nvar deletedDoc = await _theatersCollection.FindOneAndDeleteAsync(filter);\n\n// delete many\nvar filter = Builders<Theater>.Filter.Eq(t => t.Location.Address.City, "Movieville");\nvar result = await _theatersCollection.DeleteManyAsync(filter);\n')))}d.isMDXComponent=!0},4675:function(e,n,t){n.Z=t.p+"assets/images/Pipeline-b4ab3c167f1f55b14cb4e3817a730a2b.PNG"}}]);