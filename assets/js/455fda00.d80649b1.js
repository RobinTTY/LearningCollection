"use strict";(self.webpackChunklearning_knowledge_base=self.webpackChunklearning_knowledge_base||[]).push([[6430],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>d});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),l=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=l(e.components);return a.createElement(p.Provider,{value:t},e.children)},u="mdxType",y={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,p=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=l(n),m=r,d=u["".concat(p,".").concat(m)]||u[m]||y[m]||i;return n?a.createElement(d,o(o({ref:t},c),{},{components:n})):a.createElement(d,o({ref:t},c))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=m;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s[u]="string"==typeof e?e:r,o[1]=s;for(var l=2;l<i;l++)o[l]=n[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},8098:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>o,default:()=>y,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var a=n(7462),r=(n(7294),n(3905));const i={id:"types",title:"Types",sidebar_position:1},o=void 0,s={unversionedId:"web/typescript/core-concepts/types",id:"web/typescript/core-concepts/types",title:"Types",description:"Static types systems describe the shapes and behaviors of what our values will be when we run our programs. A type-checker like TypeScript uses that information and tells us when things might be going off the rails.",source:"@site/docs/web/typescript/core-concepts/types.md",sourceDirName:"web/typescript/core-concepts",slug:"/web/typescript/core-concepts/types",permalink:"/LearningCollection/web/typescript/core-concepts/types",draft:!1,editUrl:"https://github.com/RobinTTY/LearningCollection/tree/master/website/docs/web/typescript/core-concepts/types.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{id:"types",title:"Types",sidebar_position:1},sidebar:"finance",previous:{title:"Typescript",permalink:"/LearningCollection/web/typescript/"},next:{title:"Enums",permalink:"/LearningCollection/web/typescript/core-concepts/enums"}},p={},l=[{value:"Primitive Types",id:"primitive-types",level:2},{value:"Object Types",id:"object-types",level:2},{value:"Optional Properties",id:"optional-properties",level:3},{value:"Arrays",id:"arrays",level:2},{value:"any",id:"any",level:2},{value:"Tuple Types",id:"tuple-types",level:2},{value:"Union Types",id:"union-types",level:2},{value:"Literal Types",id:"literal-types",level:2},{value:"Type Aliases",id:"type-aliases",level:2},{value:"void",id:"void",level:2},{value:"object",id:"object",level:2},{value:"unknown",id:"unknown",level:2},{value:"never",id:"never",level:2}],c={toc:l},u="wrapper";function y(e){let{components:t,...i}=e;return(0,r.kt)(u,(0,a.Z)({},c,i,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Static types systems describe the shapes and behaviors of what our values will be when we run our programs. A type-checker like TypeScript uses that information and tells us when things might be going off the rails."),(0,r.kt)("p",null,"While we could write a function in JavaScript that looks like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:"title=add.js",title:"add.js"},"function add(num1, num2) {\n  return num1 + num2;\n}\n")),(0,r.kt)("p",null,"With Typescript we can add parameter type annotations so that we immediately get an error if we supply the function with the wrong argument type:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=add.ts",title:"add.ts"},"function add(num1: number, num2: number) {\n  return num1 + num2;\n}\n")),(0,r.kt)("h2",{id:"primitive-types"},"Primitive Types"),(0,r.kt)("p",null,"JavaScript has three very commonly used primitives: ",(0,r.kt)("inlineCode",{parentName:"p"},"string"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"number"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"boolean"),". Each has a corresponding type in TypeScript."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"The type names String, Number, and Boolean (starting with capital letters) are legal, but refer to some special built-in types that will very rarely appear in your code. Always use string, number, or boolean for types.")),(0,r.kt)("h2",{id:"object-types"},"Object Types"),(0,r.kt)("p",null,"Apart from primitives, the most common sort of type you\u2019ll encounter is an object type. This refers to any JavaScript value with properties, which is almost all of them! To define an object type, we simply list its properties and their types:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{2}","{2}":!0},'// The parameter\'s type annotation is an object type\nfunction printCoord(pt: { x: number; y: number }) {\n  console.log("The coordinate\'s x value is " + pt.x);\n  console.log("The coordinate\'s y value is " + pt.y);\n}\nprintCoord({ x: 3, y: 7 });\n')),(0,r.kt)("p",null,"Here, we annotated the parameter with a type with two properties - ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," - which are both of type number. You can use ",(0,r.kt)("inlineCode",{parentName:"p"},",")," or ",(0,r.kt)("inlineCode",{parentName:"p"},";")," to separate the properties, and the last separator is optional either way."),(0,r.kt)("h3",{id:"optional-properties"},"Optional Properties"),(0,r.kt)("p",null,"Object types can also specify that some or all of their properties are optional. To do this, add a ",(0,r.kt)("inlineCode",{parentName:"p"},"?")," after the property name:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'function printName(obj: { first: string; last?: string }) {\n  // ...\n}\n// Both OK\nprintName({ first: "Bob" });\nprintName({ first: "Alice", last: "Alisson" });\n')),(0,r.kt)("h2",{id:"arrays"},"Arrays"),(0,r.kt)("p",null,"To specify the type of an array like ",(0,r.kt)("inlineCode",{parentName:"p"},"[1, 2, 3]"),", you can use the syntax ",(0,r.kt)("inlineCode",{parentName:"p"},"number[];"),". You may also see this written as ",(0,r.kt)("inlineCode",{parentName:"p"},"Array<number>"),", which means the same thing."),(0,r.kt)("h2",{id:"any"},"any"),(0,r.kt)("p",null,"TypeScript also has a special type, ",(0,r.kt)("inlineCode",{parentName:"p"},"any"),", that you can use whenever you don\u2019t want a particular value to cause typechecking errors. When a value is of type any, you can access any properties of it (which will in turn be of type ",(0,r.kt)("inlineCode",{parentName:"p"},"any"),"), call it like a function, assign it to (or from) a value of any type, or pretty much anything else that\u2019s syntactically legal:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'let obj: any = { x: 0 };\n// None of the following lines of code will throw compiler errors.\n// Using `any` disables all further type checking, and it is assumed\n// you know the environment better than TypeScript.\nobj.foo();\nobj();\nobj.bar = 100;\nobj = "hello";\nconst n: number = obj;\n')),(0,r.kt)("p",null,"The any type is useful when you don\u2019t want to write out a long type just to convince TypeScript that a particular line of code is okay. When you don\u2019t specify a type, and TypeScript can\u2019t infer it from context, the compiler will typically default to ",(0,r.kt)("inlineCode",{parentName:"p"},"any"),"."),(0,r.kt)("p",null,"You usually want to avoid this, though, because any isn\u2019t type-checked. Use the compiler flag ",(0,r.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/tsconfig#noImplicitAny"},(0,r.kt)("inlineCode",{parentName:"a"},"noImplicitAny"))," to flag any implicit any as an error."),(0,r.kt)("h2",{id:"tuple-types"},"Tuple Types"),(0,r.kt)("p",null,"A tuple type is another sort of ",(0,r.kt)("inlineCode",{parentName:"p"},"Array")," type that knows exactly how many elements it contains, and exactly which types it contains at specific positions."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"type StringNumberPair = [string, number];\n")),(0,r.kt)("p",null,"Here, ",(0,r.kt)("inlineCode",{parentName:"p"},"StringNumberPair")," is a tuple type of ",(0,r.kt)("inlineCode",{parentName:"p"},"string")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"number"),". To the type system, ",(0,r.kt)("inlineCode",{parentName:"p"},"StringNumberPair")," describes arrays whose 0 index contains a ",(0,r.kt)("inlineCode",{parentName:"p"},"string")," and whose 1 index contains a ",(0,r.kt)("inlineCode",{parentName:"p"},"number"),"."),(0,r.kt)("h2",{id:"union-types"},"Union Types"),(0,r.kt)("p",null,"A union type is a type formed from two or more other types, representing values that may be any one of those types. We refer to each of these types as the union's members."),(0,r.kt)("p",null,"Example of a function that can operate on strings or numbers:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'function printId(id: number | string) {\n  console.log("Your ID is: " + id);\n}\n// OK\nprintId(101);\n// OK\nprintId("202");\n')),(0,r.kt)("h2",{id:"literal-types"},"Literal Types"),(0,r.kt)("p",null,"In addition to the general types string and number, we can refer to specific strings and numbers in type positions. This is reflected in how TypeScript creates types for literals:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"type-literals-02",src:n(5150).Z,width:"541",height:"155"})),(0,r.kt)("p",null,"It\u2019s not much use to have a variable that can only have one value! But by combining literals into unions, you can express a much more useful concept - for example, functions that only accept a certain set of known values:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'function printText(s: string, alignment: "left" | "right" | "center") {\n  // ...\n}\nprintText("Hello, world", "left");\n// Argument of type \'"centre"\' is not assignable to parameter of type \'"left" | "right" | "center"\'\nprintText("G\'day, mate", "centre");\n')),(0,r.kt)("p",null,"Numeric literal types work the same way:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"function compare(a: string, b: string): -1 | 0 | 1 {\n  return a === b ? 0 : a > b ? 1 : -1;\n}\n")),(0,r.kt)("h2",{id:"type-aliases"},"Type Aliases"),(0,r.kt)("p",null,"We\u2019ve been using object types and union types by writing them directly in type annotations. This is convenient, but it\u2019s common to want to use the same type more than once and refer to it by a single name."),(0,r.kt)("p",null,"A type alias is exactly that - a name for any type. The syntax for a type alias is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{1-4}","{1-4}":!0},'type Point = {\n  x: number;\n  y: number;\n};\n\n// Exactly the same as the earlier example\nfunction printCoord(pt: Point) {\n  console.log("The coordinate\'s x value is " + pt.x);\n  console.log("The coordinate\'s y value is " + pt.y);\n}\n\nprintCoord({ x: 100, y: 100 });\n')),(0,r.kt)("p",null,"It's similar to an interface, but it can't be extended - and it can represent things that interfaces can't."),(0,r.kt)("h2",{id:"void"},"void"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"void")," represents the return value of functions which don\u2019t return a value. It\u2019s the inferred type any time a function doesn\u2019t have any return statements, or doesn't return any explicit value from those return statements:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'function printResult(num: number): void {\n  console.log("Result: " + num);\n}\n')),(0,r.kt)("h2",{id:"object"},"object"),(0,r.kt)("p",null,"The special type ",(0,r.kt)("inlineCode",{parentName:"p"},"object")," refers to any value that isn\u2019t a primitive (",(0,r.kt)("inlineCode",{parentName:"p"},"string"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"number"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"bigint"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"boolean"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"symbol"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", or ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined"),"). This is different from the empty object type ",(0,r.kt)("inlineCode",{parentName:"p"},"{ }"),", and also different from the global type ",(0,r.kt)("inlineCode",{parentName:"p"},"Object"),". It\u2019s very likely you will never use ",(0,r.kt)("inlineCode",{parentName:"p"},"Object"),"."),(0,r.kt)("p",null,"Note that in JavaScript, function values are objects: They have properties, have ",(0,r.kt)("inlineCode",{parentName:"p"},"Object.prototype")," in their prototype chain, are ",(0,r.kt)("inlineCode",{parentName:"p"},"instanceof Object"),", you can call ",(0,r.kt)("inlineCode",{parentName:"p"},"Object.keys")," on them, and so on. For this reason, function types are considered to be ",(0,r.kt)("inlineCode",{parentName:"p"},"object"),"s in TypeScript"),(0,r.kt)("h2",{id:"unknown"},"unknown"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"unknown")," type is the type-safe counterpart of ",(0,r.kt)("inlineCode",{parentName:"p"},"any"),". Anything is assignable to unknown, but unknown isn't assignable to anything but itself and any without a type assertion or a control flow based narrowing. Likewise, no operations are permitted on an unknown without first asserting or narrowing to a more specific type."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"let vAny: any = 10; // We can assign anything to any\nlet vUnknown: unknown = 10; // We can assign anything to unknown just like any\n\nlet s1: string = vAny; // Any is assignable to anything\nlet s2: string = vUnknown; // Invalid; we can't assign vUnknown to any other type (without an explicit assertion)\n\nvAny.method(); // Ok; anything goes with any\nvUnknown.method(); // Not ok; we don't know anything about this variable\n")),(0,r.kt)("p",null,"There are often times where we want to describe the least-capable type in TypeScript. This is useful for APIs that want to signal \u201cthis can be any value, so you must perform some type of checking before you use it\u201d. This forces users to safely introspect returned values."),(0,r.kt)("h2",{id:"never"},"never"),(0,r.kt)("p",null,"Some functions never return a value:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// Function returning never must have unreachable end point\nfunction fail(msg: string): never {\n  throw new Error(msg);\n}\n")),(0,r.kt)("p",null,"The never type represents values which are never observed. In a return type, this means that the function throws an exception or terminates execution of the program."))}y.isMDXComponent=!0},5150:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/type-literals-02-d7efbfdb651d028555939f04541575d3.png"}}]);