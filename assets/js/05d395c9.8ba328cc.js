"use strict";(self.webpackChunklearning_knowledge_base=self.webpackChunklearning_knowledge_base||[]).push([[6715],{24659:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"csharp/advanced-concepts/unmanagedConstraint","title":"Unmanaged constraint","description":"The unmanaged constraint feature will give language enforcement to the class of types known as \\"unmanaged types\\" in the C# language spec. This is defined in section 18.2 as a type which is not a reference type and doesn\'t contain reference type fields at any level of nesting.","source":"@site/docs/csharp/advanced-concepts/unmanaged-constraint.md","sourceDirName":"csharp/advanced-concepts","slug":"/csharp/advanced-concepts/unmanagedConstraint","permalink":"/LearningCollection/csharp/advanced-concepts/unmanagedConstraint","draft":false,"unlisted":false,"editUrl":"https://github.com/RobinTTY/LearningCollection/tree/master/website/docs/csharp/advanced-concepts/unmanaged-constraint.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"id":"unmanagedConstraint","title":"Unmanaged constraint","sidebar_position":5},"sidebar":"docs","previous":{"title":"Unmanaged vs managed resources","permalink":"/LearningCollection/csharp/advanced-concepts/unmanagedVsManagedResources"},"next":{"title":"Serialization","permalink":"/LearningCollection/csharp/advanced-concepts/serialization"}}');var s=t(74848),i=t(28453);const r={id:"unmanagedConstraint",title:"Unmanaged constraint",sidebar_position:5},o=void 0,c={},d=[{value:"What is an unmanaged Type",id:"what-is-an-unmanaged-type",level:2}];function l(e){const n={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["The unmanaged constraint feature ",(0,s.jsx)(n.strong,{children:'will give language enforcement to the class of types known as "unmanaged types"'})," in the C# language spec. This is defined in section 18.2 as a ",(0,s.jsx)(n.strong,{children:"type which is not a reference type and doesn't contain reference type fields at any level of nesting."})]}),"\n",(0,s.jsx)(n.p,{children:"The primary motivation is to make it easier to author low level interop code in C#."}),"\n",(0,s.jsx)(n.p,{children:"Interoperability enables you to preserve and take advantage of existing investments in unmanaged code. Code that runs under the control of the common language runtime (CLR) is called managed code, and code that runs outside the CLR is called unmanaged code. COM, COM+, C++ components, ActiveX components, and Microsoft Windows API are examples of unmanaged code."}),"\n",(0,s.jsx)(n.p,{children:"Unmanaged types are one of the core building blocks for interop code, yet the lack of support in generics makes it impossible to create re-usable routines across all unmanaged types. Instead developers are forced to author the same boiler plate code for every unmanaged type in their library:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cs",children:"int Hash(Point point) { ... }\nint Hash(TimeSpan timeSpan) { ... }\n"})}),"\n",(0,s.jsx)(n.p,{children:"To enable this type of scenario the language will be introducing a new constraint: unmanaged:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cs",children:"void Hash<T>(T value) where T : unmanaged\n{\n    ...\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"This constraint can only be met by types which fit into the unmanaged type definition in the C# language spec. Another way of looking at it is that a type satisfies the unmanaged constraint iff it can also be used as a pointer."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cs",children:'Hash(new Point()); // Okay\nHash(42); // Okay\nHash("hello") // Error: Type string does not satisfy the unmanaged constraint\n'})}),"\n",(0,s.jsx)(n.p,{children:"Type parameters with the unmanaged constraint can use all the features available to unmanaged types: pointers, fixed, etc ..."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cs",children:"void Hash<T>(T value) where T : unmanaged\n{\n    // Okay\n    fixed (T* p = &value)\n    {\n        ...\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"This constraint will also make it possible to have efficient conversions between structured data and streams of bytes. This is an operation that is common in networking stacks and serialization layers:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cs",children:"Span<byte> Convert<T>(ref T value) where T : unmanaged\n{\n    ...\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Such routines are advantageous because they are provably safe at compile time and allocation free."}),"\n",(0,s.jsx)(n.h2,{id:"what-is-an-unmanaged-type",children:"What is an unmanaged Type"}),"\n",(0,s.jsx)(n.p,{children:"The language will introduce a new constraint named unmanaged. In order to satisfy this constraint a type must be a struct and all the fields of the type must fall into one of the following categories:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Have the type sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, decimal, bool, IntPtr or UIntPtr"}),"\n",(0,s.jsx)(n.li,{children:"Be any enum type"}),"\n",(0,s.jsx)(n.li,{children:"Be a pointer type"}),"\n",(0,s.jsx)(n.li,{children:"e a user defined struct that satisfies the unmanaged constraint"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Compiler generated instance fields, such as those backing auto-implemented properties, must also meet these constraints."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cs",children:"// Unmanaged type\nstruct Point\n{\n    int X;\n    int Y {get; set;}\n}\n\n// Not an unmanaged type\nstruct Student\n{\n    string FirstName;\n    string LastName;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"The unmanaged constraint cannot be combined with struct, class or new(). This restriction derives from the fact that unmanaged implies struct hence the other constraints do not make sense."}),"\n",(0,s.jsx)(n.p,{children:"The unmanaged constraint is not enforced by CLR, only by the language. To prevent mis-use by other languages, methods which have this constraint will be protected by a mod-req. This will prevent other languages from using type arguments which are not unmanaged types."}),"\n",(0,s.jsx)(n.p,{children:"The token unmanaged in the constraint is not a keyword, nor a contextual keyword. Instead it is like var in that it is evaluated at that location and will either:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Bind to user defined or referenced type named unmanaged: This will be treated just as any other named type constraint is treated"}),"\n",(0,s.jsx)(n.li,{children:"Bind to no type: This will be interpreted as the unmanaged constraint"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Another Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cs",children:"unsafe public static byte[] ToByteArray<T>(this T argument) where T : unmanaged\n{\n    var size = sizeof(T);\n    var result = new Byte[size];\n    Byte* p = (byte*)&argument;\n    for (var i = 0; i < size; i++)\n        result[i] = *p++;\n    return result;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"The preceding method must be compiled in an unsafe context because it uses the sizeof operator on a type not known to be a built-in type. Without the unmanaged constraint, the sizeof operator is unavailable."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-7.3/blittable",children:"Reference 1"}),"\n",(0,s.jsx)(n.a,{href:"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/constraints-on-type-parameters#unmanaged-constraint",children:"Reference 2"})]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var a=t(96540);const s={},i=a.createContext(s);function r(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);