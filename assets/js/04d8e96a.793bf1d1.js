"use strict";(self.webpackChunklearning_knowledge_base=self.webpackChunklearning_knowledge_base||[]).push([[758],{14122:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"csharp/comparisons/private-protected-vs-protected-internal","title":"private protected vs protected internal","description":"Before C# 7.2 we had protected internal modifier:","source":"@site/docs/csharp/comparisons/protected-internal.md","sourceDirName":"csharp/comparisons","slug":"/csharp/comparisons/private-protected-vs-protected-internal","permalink":"/LearningCollection/csharp/comparisons/private-protected-vs-protected-internal","draft":false,"unlisted":false,"editUrl":"https://github.com/RobinTTY/LearningCollection/tree/master/website/docs/csharp/comparisons/protected-internal.md","tags":[],"version":"current","frontMatter":{"id":"private-protected-vs-protected-internal","title":"private protected vs protected internal"},"sidebar":"docs","previous":{"title":"Properties vs Public variables","permalink":"/LearningCollection/csharp/comparisons/propsVsPublicVars"},"next":{"title":"Thread vs Task","permalink":"/LearningCollection/csharp/comparisons/threadVsTask"}}');var n=r(74848),o=r(28453);const i={id:"private-protected-vs-protected-internal",title:"private protected vs protected internal"},a=void 0,c={},l=[];function d(e){const t={code:"code",p:"p",strong:"strong",...(0,o.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(t.p,{children:["Before C# 7.2 we had ",(0,n.jsx)(t.code,{children:"protected internal"})," modifier:"]}),"\n",(0,n.jsxs)(t.p,{children:["This really means ",(0,n.jsx)(t.strong,{children:"protected OR internal"}),", that is - member A is ",(0,n.jsx)(t.strong,{children:"accessible to child classes and also to any class in the current assembly"}),', even if that class is not child of class A (so restriction implied by "protected" is relaxed). The internal modifier is also relaxed.']}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"private protected"})," really means protected AND internal:"]}),"\n",(0,n.jsx)(t.p,{children:'That is - member is accessible only to child classes which are in the same assembly, but not to child classes which are outside assembly (so restriction implied by "protected" is narrowed - becomes even more restrictive). That is useful if you build hierarchy of classes in your assembly and do not want any child classes from other assemblies to access certain parts of that hierarchy.'})]})}function p(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},28453:(e,t,r)=>{r.d(t,{R:()=>i,x:()=>a});var s=r(96540);const n={},o=s.createContext(n);function i(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);