"use strict";(globalThis.webpackChunklearning_knowledge_base=globalThis.webpackChunklearning_knowledge_base||[]).push([[5158],{72064:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"web/react/advanced-concepts/errorBoundaries","title":"Error Boundaries","description":"Error boundaries are React components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of the component tree that crashed. Error boundaries catch errors during rendering, in lifecycle methods, and in constructors of the whole tree below them.","source":"@site/docs/web/react/advanced-concepts/Error Boundaries.md","sourceDirName":"web/react/advanced-concepts","slug":"/web/react/advanced-concepts/errorBoundaries","permalink":"/LearningCollection/web/react/advanced-concepts/errorBoundaries","draft":false,"unlisted":false,"editUrl":"https://github.com/RobinTTY/LearningCollection/tree/master/website/docs/web/react/advanced-concepts/Error Boundaries.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"id":"errorBoundaries","title":"Error Boundaries","sidebar_position":5},"sidebar":"docs","previous":{"title":"React.memo","permalink":"/LearningCollection/web/react/advanced-concepts/reactMemo"},"next":{"title":"useState","permalink":"/LearningCollection/web/react/hooks/useState"}}');var t=n(74848),s=n(28453);const a={id:"errorBoundaries",title:"Error Boundaries",sidebar_position:5},i=void 0,c={},d=[{value:"componentDidCatch()",id:"componentdidcatch",level:2},{value:"Syntax",id:"syntax",level:3},{value:"static getDerivedStateFromError()",id:"static-getderivedstatefromerror",level:2},{value:"Syntax",id:"syntax-1",level:3},{value:"Example",id:"example",level:2}];function l(e){const r={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(r.p,{children:["Error boundaries are React components that ",(0,t.jsx)(r.strong,{children:"catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI"})," instead of the component tree that crashed. Error boundaries catch errors during rendering, in lifecycle methods, and in constructors of the whole tree below them."]}),"\n",(0,t.jsxs)(r.admonition,{type:"caution",children:[(0,t.jsxs)(r.p,{children:["Error boundaries do ",(0,t.jsx)(r.strong,{children:"not"})," catch errors for:"]}),(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:["Event handlers (see ",(0,t.jsx)(r.a,{href:"https://reactjs.org/docs/error-boundaries.html#how-about-event-handlers",children:"documentation"}),")"]}),"\n",(0,t.jsxs)(r.li,{children:["Asynchronous code (e.g. ",(0,t.jsx)(r.code,{children:"setTimeout"})," or ",(0,t.jsx)(r.code,{children:"requestAnimationFrame"})," callbacks)"]}),"\n",(0,t.jsx)(r.li,{children:"Server side rendering"}),"\n",(0,t.jsx)(r.li,{children:"Errors thrown in the error boundary itself (rather than its children)"}),"\n"]})]}),"\n",(0,t.jsxs)(r.p,{children:["A class component becomes an error boundary if it defines either (or both) of the lifecycle methods ",(0,t.jsx)(r.code,{children:"static getDerivedStateFromError()"})," or ",(0,t.jsx)(r.code,{children:"componentDidCatch()"}),". Use ",(0,t.jsx)(r.code,{children:"static getDerivedStateFromError()"})," to render a fallback UI after an error has been thrown. Use ",(0,t.jsx)(r.code,{children:"componentDidCatch()"})," to log error information. Error boundaries work like a JavaScript ",(0,t.jsx)(r.code,{children:"catch {}"})," block, but for components."]}),"\n",(0,t.jsx)(r.h2,{id:"componentdidcatch",children:"componentDidCatch()"}),"\n",(0,t.jsx)(r.p,{children:"This lifecycle is invoked after an error has been thrown by a descendant component. It receives two parameters:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"error"})," - The error that was thrown"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"info"})," - An object with a componentStack key containing ",(0,t.jsx)(r.a,{href:"https://reactjs.org/docs/error-boundaries.html#component-stack-traces",children:"information about which component threw the error"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"componentDidCatch()"})," is called during the \u201ccommit\u201d phase, so side-effects are permitted. It should be used for things like logging errors."]}),"\n",(0,t.jsx)(r.admonition,{type:"info",children:(0,t.jsxs)(r.p,{children:["Production and development builds of React slightly differ in the way ",(0,t.jsx)(r.code,{children:"componentDidCatch()"})," handles errors. On development, the errors will bubble up to ",(0,t.jsx)(r.code,{children:"window"}),", this means that any ",(0,t.jsx)(r.code,{children:"window.onerror"})," or ",(0,t.jsx)(r.code,{children:"window.addEventListener('error', callback)"})," will intercept the errors that have been caught by ",(0,t.jsx)(r.code,{children:"componentDidCatch()"}),". On production, instead, the errors will not bubble up, which means any ancestor error handler will only receive errors not explicitly caught by ",(0,t.jsx)(r.code,{children:"componentDidCatch()"}),"."]})}),"\n",(0,t.jsx)(r.h3,{id:"syntax",children:"Syntax"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-jsx",children:"componentDidCatch(error, info);\n"})}),"\n",(0,t.jsx)(r.h2,{id:"static-getderivedstatefromerror",children:"static getDerivedStateFromError()"}),"\n",(0,t.jsx)(r.p,{children:"This lifecycle is invoked after an error has been thrown by a descendant component. It receives the error that was thrown as a parameter and should return a value to update state."}),"\n",(0,t.jsx)(r.admonition,{type:"caution",children:(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"getDerivedStateFromError()"})," is called during the \u201crender\u201d phase, so side-effects are not permitted. For those use cases, use ",(0,t.jsx)(r.code,{children:"componentDidCatch()"})," instead."]})}),"\n",(0,t.jsx)(r.h3,{id:"syntax-1",children:"Syntax"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-jsx",children:"static getDerivedStateFromError(error);\n"})}),"\n",(0,t.jsx)(r.h2,{id:"example",children:"Example"}),"\n",(0,t.jsx)(r.p,{children:"Define the error boundary:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-jsx",children:"class ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  // invoked after an error has been thrown by a descendant component\n  static getDerivedStateFromError(error) {\n    // Update state so the next render will show the fallback UI.\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    // You can also log the error to an error reporting service\n    logErrorToMyService(error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // You can render any custom fallback UI\n      return <h1>Something went wrong.</h1>;\n    }\n\n    return this.props.children;\n  }\n}\n"})}),"\n",(0,t.jsx)(r.p,{children:"Then you can use it as a regular component:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-jsx",children:"<ErrorBoundary>\n  <MyWidget />\n</ErrorBoundary>\n"})}),"\n",(0,t.jsx)(r.admonition,{type:"info",children:(0,t.jsxs)(r.p,{children:["Error boundaries ",(0,t.jsx)(r.a,{href:"https://reactjs.org/docs/hooks-faq.html#do-hooks-cover-all-use-cases-for-classes",children:"cannot be implemented as functional components"})," as of today. There is ",(0,t.jsx)(r.a,{href:"https://github.com/facebook/react/issues/19630#issuecomment-675390931",children:"no timeline"})," for the implementation as a hook."]})})]})}function h(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},28453:(e,r,n)=>{n.d(r,{R:()=>a,x:()=>i});var o=n(96540);const t={},s=o.createContext(t);function a(e){const r=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function i(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),o.createElement(s.Provider,{value:r},e.children)}}}]);