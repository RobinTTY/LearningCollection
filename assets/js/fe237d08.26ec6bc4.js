"use strict";(globalThis.webpackChunklearning_knowledge_base=globalThis.webpackChunklearning_knowledge_base||[]).push([[2304],{61377:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"graphql/core-concepts","title":"Core Concepts","description":"GraphQL has a few core concepts that are important to understanding how it works. These core concepts are explained here.","source":"@site/docs/graphql/core-concepts.md","sourceDirName":"graphql","slug":"/graphql/core-concepts","permalink":"/LearningCollection/graphql/core-concepts","draft":false,"unlisted":false,"editUrl":"https://github.com/RobinTTY/LearningCollection/tree/master/website/docs/graphql/core-concepts.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"id":"core-concepts","title":"Core Concepts","sidebar_position":3},"sidebar":"docs","previous":{"title":"Architecture","permalink":"/LearningCollection/graphql/architecture"},"next":{"title":"Clients","permalink":"/LearningCollection/graphql/clients"}}');var a=t(74848),r=t(28453);const i={id:"core-concepts",title:"Core Concepts",sidebar_position:3},o=void 0,l={},c=[{value:"The Schema Definition Language (SDL)",id:"the-schema-definition-language-sdl",level:2},{value:"Fetching Data with Queries",id:"fetching-data-with-queries",level:2},{value:"Basic Queries",id:"basic-queries",level:3},{value:"Queries with Arguments",id:"queries-with-arguments",level:3},{value:"Writing Data with Mutations",id:"writing-data-with-mutations",level:3},{value:"Realtime Updates with Subscriptions",id:"realtime-updates-with-subscriptions",level:3},{value:"Defining a Schema",id:"defining-a-schema",level:2}];function h(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"GraphQL has a few core concepts that are important to understanding how it works. These core concepts are explained here."}),"\n",(0,a.jsx)(n.h2,{id:"the-schema-definition-language-sdl",children:"The Schema Definition Language (SDL)"}),"\n",(0,a.jsxs)(n.p,{children:["GraphQL has its own type system that\u2019s used to define the schema of an API. The syntax for writing schemas is called Schema Definition Language (SDL). Here is an example of how we can use the SDL to define a simple type called ",(0,a.jsx)(n.code,{children:"Person"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",children:"type Person {\n  name: String!\n  age: Int!\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["This type has two fields, they\u2019re called ",(0,a.jsx)(n.code,{children:"name"})," and ",(0,a.jsx)(n.code,{children:"age"})," and are respectively of type ",(0,a.jsx)(n.code,{children:"String"})," and ",(0,a.jsx)(n.code,{children:"Int"}),". The ",(0,a.jsx)(n.code,{children:"!"})," following the type means that this field is required. It\u2019s also possible to express relationships between types. In the example of a blogging application, a ",(0,a.jsx)(n.code,{children:"Person"})," could be associated with a ",(0,a.jsx)(n.code,{children:"Post"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",children:"type Post {\n  title: String!\n  author: Person!\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Conversely, the other end of the relationship needs to be placed on the ",(0,a.jsx)(n.code,{children:"Person"})," type:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",children:"type Person {\n  name: String!\n  age: Int!\n  posts: [Post!]!\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["This is a one-to-many-relationship between ",(0,a.jsx)(n.code,{children:"Person"})," and ",(0,a.jsx)(n.code,{children:"Post"})," since the ",(0,a.jsx)(n.code,{children:"posts"})," field on ",(0,a.jsx)(n.code,{children:"Person"})," is actually an array of posts."]}),"\n",(0,a.jsx)(n.h2,{id:"fetching-data-with-queries",children:"Fetching Data with Queries"}),"\n",(0,a.jsx)(n.p,{children:"When working with REST APIs, data is loaded from specific endpoints. Each endpoint has a clearly defined structure of the information that it returns. This means that the data requirements of a client are effectively encoded in the URL that it connects to."}),"\n",(0,a.jsx)(n.p,{children:"The approach that\u2019s taken in GraphQL is radically different. Instead of having multiple endpoints that return fixed data structures, GraphQL APIs typically only expose a single endpoint. This works because the structure of the data that\u2019s returned is not fixed. Instead, it\u2019s completely flexible and lets the client decide what data is actually needed."}),"\n",(0,a.jsx)(n.p,{children:"That means that the client needs to send more information to the server to express its data needs - this information is called a query."}),"\n",(0,a.jsx)(n.h3,{id:"basic-queries",children:"Basic Queries"}),"\n",(0,a.jsx)(n.p,{children:"Let\u2019s take a look at an example query that a client could send to a server:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",children:"{\n  allPersons {\n    name\n  }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"allPersons"})," field in this query is called the root field of the query. Everything that follows the root field, is called the payload of the query. The only field that\u2019s specified in this query\u2019s payload is ",(0,a.jsx)(n.code,{children:"name"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"This query would return a list of all persons currently stored in the database. Here\u2019s an example response:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'{\n  "allPersons": [\n    { "name": "Johnny" },\n    { "name": "Sarah" },\n    { "name": "Alice" }\n  ]\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Notice that each person only has the ",(0,a.jsx)(n.code,{children:"name"})," in the response, but the ",(0,a.jsx)(n.code,{children:"age"})," is not returned by the server. That\u2019s exactly because ",(0,a.jsx)(n.code,{children:"name"})," was the only field that was specified in the query."]}),"\n",(0,a.jsxs)(n.p,{children:["If the client also needed the persons\u2019 ",(0,a.jsx)(n.code,{children:"age"}),", all it has to do is slightly adjust the query and include the new field in the query\u2019s payload:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",children:"{\n  allPersons {\n    name\n    age\n  }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["One of the major advantages of GraphQL is that it allows for naturally querying nested information. For example, if you wanted to load all the ",(0,a.jsx)(n.code,{children:"posts"})," that a ",(0,a.jsx)(n.code,{children:"Person"})," has written, you could simply follow the structure of your types to request this information:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",children:"{\n  allPersons {\n    name\n    age\n    posts {\n      title\n    }\n  }\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"queries-with-arguments",children:"Queries with Arguments"}),"\n",(0,a.jsxs)(n.p,{children:["In GraphQL, each field can have zero or more arguments if that\u2019s specified in the schema. For example, the ",(0,a.jsx)(n.code,{children:"allPersons"})," field could have a ",(0,a.jsx)(n.code,{children:"last"})," parameter to only return up to a specific number of persons. Here\u2019s what a corresponding query would look like:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",children:"{\n  allPersons(last: 2) {\n    name\n  }\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"writing-data-with-mutations",children:"Writing Data with Mutations"}),"\n",(0,a.jsx)(n.p,{children:"Next to requesting information from a server, the majority of applications also need some way of making changes to the data that\u2019s currently stored in the backend. With GraphQL, these changes are made using so-called mutations. There generally are three kinds of mutations:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Creating new data"}),"\n",(0,a.jsx)(n.li,{children:"Updating existing data"}),"\n",(0,a.jsx)(n.li,{children:"deleting existing data"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["Mutations follow the same syntactical structure as queries, but they always need to start with the ",(0,a.jsx)(n.code,{children:"mutation"})," keyword. Here\u2019s an example for how we might create a new ",(0,a.jsx)(n.code,{children:"Person"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",children:'mutation {\n  createPerson(name: "Bob", age: 36) {\n    name\n    age\n  }\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Notice that similar to the query we wrote before, the mutation also has a root field - in this case it\u2019s called ",(0,a.jsx)(n.code,{children:"createPerson"}),". We also already learned about the concepts of arguments for fields. In this case, the ",(0,a.jsx)(n.code,{children:"createPerson"})," field takes two arguments that specify the new person\u2019s ",(0,a.jsx)(n.code,{children:"name"})," and ",(0,a.jsx)(n.code,{children:"age"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["Like with a query, we\u2019re also able to specify a payload for a mutation in which we can ask for different properties of the new ",(0,a.jsx)(n.code,{children:"Person"})," object. In our case, we\u2019re asking for the ",(0,a.jsx)(n.code,{children:"name"})," and the ",(0,a.jsx)(n.code,{children:"age"})," - though admittedly that\u2019s not super helpful in our example since we obviously already know them as we pass them into the mutation. However, being able to also query information when sending mutations can be a very powerful tool that allows you to retrieve new information from the server in a single roundtrip!"]}),"\n",(0,a.jsx)(n.p,{children:"The server response for the above mutation would look as follows:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'{\n  "createPerson": {\n    "name": "Bob",\n    "age": 36\n  }\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["One pattern you\u2019ll often find is that GraphQL types have unique IDs that are generated by the server when new objects are created. Extending our ",(0,a.jsx)(n.code,{children:"Person"})," type from before, we could add an ",(0,a.jsx)(n.code,{children:"id"})," like this:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",children:"type Person {\n  id: ID!\n  name: String!\n  age: Int!\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Now, when a new ",(0,a.jsx)(n.code,{children:"Person"})," is created, you could directly ask for the ",(0,a.jsx)(n.code,{children:"id"})," in the payload of the mutation, since that is information that wasn\u2019t available on the client beforehand:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",children:'mutation {\n  createPerson(name: "Alice", age: 36) {\n    id\n  }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"realtime-updates-with-subscriptions",children:"Realtime Updates with Subscriptions"}),"\n",(0,a.jsx)(n.p,{children:"Another important requirement for many applications today is to have a realtime connection to the server in order to get immediately informed about important events. For this use case, GraphQL offers the concept of subscriptions."}),"\n",(0,a.jsx)(n.p,{children:"When a client subscribes to an event, it will initiate and hold a steady connection to the server. Whenever that particular event then actually happens, the server pushes the corresponding data to the client. Unlike queries and mutations that follow a typical \u201crequest-response-cycle\u201d, subscriptions represent a stream of data sent over to the client."}),"\n",(0,a.jsxs)(n.p,{children:["Subscriptions are written using the same syntax as queries and mutations. Here\u2019s an example where we subscribe on events happening on the ",(0,a.jsx)(n.code,{children:"Person"})," type:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",children:"subscription {\n  newPerson {\n    name\n    age\n  }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["After a client sent this subscription to a server, a connection is opened between them. Then, whenever a new mutation is performed that creates a new ",(0,a.jsx)(n.code,{children:"Person"}),", the server sends the information about this person over to the client:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'{\n  "newPerson": {\n    "name": "Jane",\n    "age": 23\n  }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"defining-a-schema",children:"Defining a Schema"}),"\n",(0,a.jsx)(n.p,{children:"The schema is one of the most important concepts when working with a GraphQL API. It specifies the capabilities of the API and defines how clients can request the data. It is often seen as a contract between the server and client."}),"\n",(0,a.jsx)(n.p,{children:"Generally, a schema is simply a collection of GraphQL types. However, when writing the schema for an API, there are some special root types:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",children:"type Query { ... }\ntype Mutation { ... }\ntype Subscription { ... }\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"Query"}),", ",(0,a.jsx)(n.code,{children:"Mutation"}),", and ",(0,a.jsx)(n.code,{children:"Subscription"})," types are the entry points for the requests sent by the client. To enable the ",(0,a.jsx)(n.code,{children:"allPersons"}),"-query that we saw before, the Query type would have to be written as follows:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",children:"type Query {\n  allPersons: [Person!]!\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"allPersons"})," is called a root field of the API. Considering again the example where we added the ",(0,a.jsx)(n.code,{children:"last"})," argument to the ",(0,a.jsx)(n.code,{children:"allPersons"})," field, we\u2019d have to write the ",(0,a.jsx)(n.code,{children:"Query"})," as follows:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",children:"type Query {\n  allPersons(last: Int): [Person!]!\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Similarly, for the ",(0,a.jsx)(n.code,{children:"createPerson"}),"-mutation, we\u2019ll have to add a root field to the ",(0,a.jsx)(n.code,{children:"Mutation"})," type:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",children:"type Mutation {\n  createPerson(name: String!, age: Int!): Person!\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Notice that this root field takes two arguments as well, the ",(0,a.jsx)(n.code,{children:"name"})," and the ",(0,a.jsx)(n.code,{children:"age"})," of the new Person."]}),"\n",(0,a.jsxs)(n.p,{children:["Finally, for the subscriptions, we\u2019d have to add the ",(0,a.jsx)(n.code,{children:"newPerson"})," root field:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",children:"type Subscription {\n  newPerson: Person!\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Putting it all together, this is the full schema for all the queries and mutation that you have seen in this chapter:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-graphql",children:"type Query {\n  allPersons(last: Int): [Person!]!\n  allPosts(last: Int): [Post!]!\n}\n\ntype Mutation {\n  createPerson(name: String!, age: Int!): Person!\n  updatePerson(id: ID!, name: String!, age: String!): Person!\n  deletePerson(id: ID!): Person!\n}\n\ntype Subscription {\n  newPerson: Person!\n}\n\ntype Person {\n  id: ID!\n  name: String!\n  age: Int!\n  posts: [Post!]!\n}\n\ntype Post {\n  title: String!\n  author: Person!\n}\n"})})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var s=t(96540);const a={},r=s.createContext(a);function i(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);