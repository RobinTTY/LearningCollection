"use strict";(self.webpackChunklearning_knowledge_base=self.webpackChunklearning_knowledge_base||[]).push([[5688],{558:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>r,toc:()=>l});var s=t(4848),a=t(8453);const i={id:"useReducer",title:"useReducer",sidebar_position:4},o=void 0,r={id:"web/react/hooks/useReducer",title:"useReducer",description:"The useReducer hook is an alternative to useState. useReducer is usually preferable to useState when you have complex state logic that involves multiple sub-values or when the next state depends on the previous one. useReducer also lets you optimize performance for components that trigger deep updates because you can pass dispatch down instead of callbacks.",source:"@site/docs/web/react/hooks/useReducer.md",sourceDirName:"web/react/hooks",slug:"/web/react/hooks/useReducer",permalink:"/LearningCollection/web/react/hooks/useReducer",draft:!1,unlisted:!1,editUrl:"https://github.com/RobinTTY/LearningCollection/tree/master/website/docs/web/react/hooks/useReducer.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{id:"useReducer",title:"useReducer",sidebar_position:4},sidebar:"docs",previous:{title:"useContext",permalink:"/LearningCollection/web/react/hooks/useContext"},next:{title:"useRef",permalink:"/LearningCollection/web/react/hooks/useRef"}},d={},l=[{value:"Syntax",id:"syntax",level:2},{value:"state",id:"state",level:3},{value:"dispatchFn",id:"dispatchfn",level:3},{value:"reducerFn",id:"reducerfn",level:3},{value:"initialState",id:"initialstate",level:3},{value:"initFn",id:"initfn",level:3},{value:"Using useState and useReducer",id:"using-usestate-and-usereducer",level:2},{value:"Specifying the initial state",id:"specifying-the-initial-state",level:3},{value:"Lazy initialization",id:"lazy-initialization",level:3},{value:"A more complex example",id:"a-more-complex-example",level:2},{value:"When to use useState vs useReducer",id:"when-to-use-usestate-vs-usereducer",level:2},{value:"More info",id:"more-info",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"useReducer"})," hook is an alternative to ",(0,s.jsx)(n.code,{children:"useState"}),". ",(0,s.jsx)(n.code,{children:"useReducer"})," is usually preferable to ",(0,s.jsx)(n.code,{children:"useState"})," ",(0,s.jsx)(n.strong,{children:"when you have complex state logic"})," that involves multiple sub-values or when the next state depends on the previous one. ",(0,s.jsx)(n.code,{children:"useReducer"})," also lets you optimize performance for components that trigger deep updates because ",(0,s.jsx)(n.a,{href:"https://reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down",children:"you can pass dispatch down instead of callbacks"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"syntax",children:"Syntax"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"const [state, dispatchFn] = useReducer(reducerFn, initialState, initFn);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"state",children:"state"}),"\n",(0,s.jsx)(n.p,{children:"The state snapshot used in the component re-render/re-evaluation cycle."}),"\n",(0,s.jsx)(n.h3,{id:"dispatchfn",children:"dispatchFn"}),"\n",(0,s.jsx)(n.p,{children:"A function that can be used to dispatch a new action (i.e. trigger an update of the state)."}),"\n",(0,s.jsx)(n.h3,{id:"reducerfn",children:"reducerFn"}),"\n",(0,s.jsx)(n.p,{children:"Accepts a function in the form of:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"(prevState, action) => newState;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["A function that is triggered automatically once an action is dispatched (via ",(0,s.jsx)(n.code,{children:"dispatchFn"}),"). It receives the latest state snapshot and should return the new, updated state."]}),"\n",(0,s.jsx)(n.h3,{id:"initialstate",children:"initialState"}),"\n",(0,s.jsx)(n.p,{children:"The initial state."}),"\n",(0,s.jsx)(n.h3,{id:"initfn",children:"initFn"}),"\n",(0,s.jsx)(n.p,{children:"A function to set the initial state programmatically."}),"\n",(0,s.jsx)(n.h2,{id:"using-usestate-and-usereducer",children:"Using useState and useReducer"}),"\n",(0,s.jsxs)(n.p,{children:["Take this component which currently uses the ",(0,s.jsx)(n.code,{children:"useState"})," hook:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"function Counter({ initialCount }) {\n  const [count, setCount] = useState(initialCount);\n  return (\n    <>\n      Count: {count}\n      <button onClick={() => setCount(initialCount)}>Reset</button>\n      <button onClick={() => setCount((prevCount) => prevCount - 1)}>-</button>\n      <button onClick={() => setCount((prevCount) => prevCount + 1)}>+</button>\n    </>\n  );\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["We can rewrite this using ",(0,s.jsx)(n.code,{children:"useReducer"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'const initialState = { count: 0 };\n\n// The reducer function can be created outside of the component since they don\'t need to interact\n// with anything from inside the component, instead only with the passed down parameters\nfunction reducer(state, action) {\n  switch (action.type) {\n    case "increment":\n      return { count: state.count + 1 };\n    case "decrement":\n      return { count: state.count - 1 };\n    default:\n      throw new Error();\n  }\n}\n\nfunction Counter() {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  return (\n    <>\n      Count: {state.count}\n      <button onClick={() => dispatch({ type: "decrement" })}>-</button>\n      <button onClick={() => dispatch({ type: "increment" })}>+</button>\n    </>\n  );\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"The reducer function will accept the previous app state and the action being dispatched, calculate the next state, and return the new object."}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["While ",(0,s.jsx)(n.code,{children:"useState"})," works just fine for this example and is preferable since its easier to use, ",(0,s.jsx)(n.code,{children:"useReducer"})," can be used to handle more complex state logic."]})}),"\n",(0,s.jsx)(n.h3,{id:"specifying-the-initial-state",children:"Specifying the initial state"}),"\n",(0,s.jsxs)(n.p,{children:["There are two different ways to initialize ",(0,s.jsx)(n.code,{children:"useReducer"})," state. You may choose either one depending on the use case. The simplest way is to pass the initial state as a second argument:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"const [state, dispatch] = useReducer(reducer, { count: initialCount });\n"})}),"\n",(0,s.jsx)(n.h3,{id:"lazy-initialization",children:"Lazy initialization"}),"\n",(0,s.jsxs)(n.p,{children:["You can also create the initial state lazily. To do this, you can pass an ",(0,s.jsx)(n.code,{children:"init"})," function as the third argument. The initial state will be set to ",(0,s.jsx)(n.code,{children:"init(initialArg)"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"It lets you extract the logic for calculating the initial state outside the reducer. This is also handy for resetting the state later in response to an action:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",metastring:"{1-3,11-12,19,24}",children:'function init(initialCount) {\n  return { count: initialCount };\n}\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case "increment":\n      return { count: state.count + 1 };\n    case "decrement":\n      return { count: state.count - 1 };\n    case "reset":\n      return init(action.payload);\n    default:\n      throw new Error();\n  }\n}\n\nfunction Counter({ initialCount }) {\n  const [state, dispatch] = useReducer(reducer, initialCount, init);\n  return (\n    <>\n      Count: {state.count}\n      <button\n        onClick={() => dispatch({ type: "reset", payload: initialCount })}\n      >\n        Reset\n      </button>\n      <button onClick={() => dispatch({ type: "decrement" })}>-</button>\n      <button onClick={() => dispatch({ type: "increment" })}>+</button>\n    </>\n  );\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"a-more-complex-example",children:"A more complex example"}),"\n",(0,s.jsx)(n.p,{children:"Consider this Login component:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",metastring:"{2-5,25,29}",children:'const Login = (props) => {\n  const [enteredEmail, setEnteredEmail] = useState("");\n  const [emailIsValid, setEmailIsValid] = useState();\n  const [enteredPassword, setEnteredPassword] = useState("");\n  const [passwordIsValid, setPasswordIsValid] = useState();\n  const [formIsValid, setFormIsValid] = useState(false);\n\n  const emailChangeHandler = (event) => {\n    setEnteredEmail(event.target.value);\n\n    setFormIsValid(\n      event.target.value.includes("@") && enteredPassword.trim().length > 6\n    );\n  };\n\n  const passwordChangeHandler = (event) => {\n    setEnteredPassword(event.target.value);\n\n    setFormIsValid(\n      enteredEmail.includes("@") && event.target.value.trim().length > 6\n    );\n  };\n\n  const validateEmailHandler = () => {\n    setEmailIsValid(enteredEmail.includes("@"));\n  };\n\n  const validatePasswordHandler = () => {\n    setPasswordIsValid(enteredPassword.trim().length > 6);\n  };\n\n  const submitHandler = (event) => {\n    event.preventDefault();\n    props.onLogin(enteredEmail, enteredPassword);\n  };\n\n  return (\n    // ...\n    <input\n      type="email"\n      id="email"\n      value={enteredEmail}\n      onChange={emailChangeHandler}\n      onBlur={validateEmailHandler}\n    />\n    // ...\n    <input\n    type="password"\n    id="password"\n    value={enteredPassword}\n    onChange={passwordChangeHandler}\n    onBlur={validatePasswordHandler}\n    />\n    // ...\n  );\n};\n'})}),"\n",(0,s.jsxs)(n.p,{children:["In this component we have multiple related pieces of state, like ",(0,s.jsx)(n.code,{children:"enteredEmail"}),", ",(0,s.jsx)(n.code,{children:"emailIsValid"}),", ",(0,s.jsx)(n.code,{children:"enteredPassword"})," and ",(0,s.jsx)(n.code,{children:"passwordIsValid"}),". While it might not cause many problems, accessing for instance the ",(0,s.jsx)(n.code,{children:"enteredEmail"})," state inside the ",(0,s.jsx)(n.code,{children:"setEmailIsValid"})," function is not a good practice, because it involves two separate states. The ",(0,s.jsx)(n.code,{children:"enteredEmail"})," state might not be the most current one (due to the way React updates it), so we should consider using ",(0,s.jsx)(n.code,{children:"useReducer"})," to combine these states:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",metastring:"{1-20,29-37,59,68,74,78}",children:"const emailReducer = (state, action) => {\n  if (action.type === 'USER_INPUT') {\n    return { value: action.val, isValid: action.val.includes('@') };\n  }\n  if (action.type === 'INPUT_BLUR') {\n    // if the element loses focus the value should remain => state.value\n    return { value: state.value, isValid: state.value.includes('@') };\n  }\n  return { value: '', isValid: false };\n};\n\nconst passwordReducer = (state, action) => {\n  if (action.type === 'USER_INPUT') {\n    return { value: action.val, isValid: action.val.trim().length > 6 };\n  }\n  if (action.type === 'INPUT_BLUR') {\n    return { value: state.value, isValid: state.value.trim().length > 6 };\n  }\n  return { value: '', isValid: false };\n};\n\nconst Login = (props) => {\n  // const [enteredEmail, setEnteredEmail] = useState('');\n  // const [emailIsValid, setEmailIsValid] = useState();\n  // const [enteredPassword, setEnteredPassword] = useState('');\n  // const [passwordIsValid, setPasswordIsValid] = useState();\n  const [formIsValid, setFormIsValid] = useState(false);\n\n  // second parameter is the initial value of the state\n  const [emailState, dispatchEmail] = useReducer(emailReducer, {\n    value: \"\",\n    isValid: null,\n  });\n  const [passwordState, dispatchPassword] = useReducer(passwordReducer, {\n    value: \"\",\n    isValid: null,\n  });\n\n  // this object destructuring isn't really necessary, we could also just use emailState.isValid\n  const { isValid: emailIsValid } = emailState;\n  const { isValid: passwordIsValid } = passwordState;\n\n  // this affects the styling and only needs to execute if validity changes, so we can use useEffect\n  useEffect(() => {\n    const identifier = setTimeout(() => {\n      console.log(\"Checking form validity!\");\n      setFormIsValid(emailIsValid && passwordIsValid);\n    }, 500);\n\n    return () => {\n      console.log(\"CLEANUP\");\n      clearTimeout(identifier);\n    };\n  }, [emailIsValid, passwordIsValid]);\n\n  const emailChangeHandler = (event) => {\n    // through the change handler an action is passed through the dispatch function\n    // second parameter is the payload (the value we want to update the state with)\n    dispatchEmail({ type: \"USER_INPUT\", val: event.target.value });\n\n    // it's better to not validate this on every character change, so we do this in the useEffect hook\n    // setFormIsValid(\n    //   event.target.value.includes('@') && passwordState.isValid\n    // );\n  };\n\n  const passwordChangeHandler = (event) => {\n    dispatchPassword({ type: \"USER_INPUT\", val: event.target.value });\n\n    // setFormIsValid(emailState.isValid && event.target.value.trim().length > 6);\n  };\n\n  const validateEmailHandler = () => {\n    dispatchEmail({ type: \"INPUT_BLUR\" });\n  };\n\n  const validatePasswordHandler = () => {\n    dispatchPassword({ type: \"INPUT_BLUR\" });\n  };\n\n  const submitHandler = (event) => {\n    event.preventDefault();\n    props.onLogin(emailState.value, passwordState.value);\n  };\n\n  return (\n    // ...\n    <input\n    type=\"email\"\n    id=\"email\"\n    value={emailState.value}\n    onChange={emailChangeHandler}\n    onBlur={validateEmailHandler}\n    />\n    // ...\n    <input\n    type=\"password\"\n    id=\"password\"\n    value={passwordState.value}\n    onChange={passwordChangeHandler}\n    onBlur={validatePasswordHandler}\n    />\n    // ...\n  );\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Now we have combined the 4 states into 2 state objects called ",(0,s.jsx)(n.code,{children:"emailState"})," and ",(0,s.jsx)(n.code,{children:"passwordState"}),". The ",(0,s.jsx)(n.code,{children:"emailChangeHandler"})," for instance calls the dispatch function, which in turn updates the combined state via the ",(0,s.jsx)(n.code,{children:"emailReducer"})," function. Note that we also could have used only one state object here, since the logic is very similar."]}),"\n",(0,s.jsx)(n.h2,{id:"when-to-use-usestate-vs-usereducer",children:"When to use useState vs useReducer"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"useState"}),(0,s.jsx)(n.th,{children:"useReducer"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:'The default state management "tool"'}),(0,s.jsx)(n.td,{children:"If you need to handle mor complex state"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Great for independent pieces of state/data"}),(0,s.jsx)(n.td,{children:"Great if you have related pieces of state/data"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Great if state updates are easy and limited to a few kinds of updates"}),(0,s.jsx)(n.td,{children:"Can be helpful if you have more complex state updates"})]})]})]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["Related pieces of state can also be combined into an object to handle via ",(0,s.jsx)(n.code,{children:"useState"}),", so you don't necessarily need ",(0,s.jsx)(n.code,{children:"useReducer"})," in this case. ",(0,s.jsx)(n.code,{children:"useReducer"})," can still be helpful for complex state updates!"]})}),"\n",(0,s.jsx)(n.h2,{id:"more-info",children:"More info"}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["Another good summary with examples can be found here: ",(0,s.jsx)(n.a,{href:"https://blog.webdevsimplified.com/2020-06/use-reducer/",children:"WebDevSimplified"})]})})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>r});var s=t(6540);const a={},i=s.createContext(a);function o(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);