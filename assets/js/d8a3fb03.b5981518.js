"use strict";(self.webpackChunklearning_knowledge_base=self.webpackChunklearning_knowledge_base||[]).push([[4815],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),d=p(n),u=r,h=d["".concat(l,".").concat(u)]||d[u]||m[u]||o;return n?a.createElement(h,s(s({ref:t},c),{},{components:n})):a.createElement(h,s({ref:t},c))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,s=new Array(o);s[0]=u;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[d]="string"==typeof e?e:r,s[1]=i;for(var p=2;p<o;p++)s[p]=n[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},2912:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>u,frontMatter:()=>s,metadata:()=>l,toc:()=>c});var a=n(7462),r=(n(7294),n(3905)),o=n(4996);const s={id:"components",title:"Components",sidebar_position:2},i=void 0,l={unversionedId:"Web/lit/components",id:"Web/lit/components",title:"Components",description:"A Lit component is a reusable piece of UI. You can think of a Lit component as a container that has some state and that displays a UI based on its state. It can also react to user input, fire events\u2014anything you'd expect a UI component to do. And a Lit component is an HTML element, so it has all of the standard element APIs.",source:"@site/docs/Web/lit/components.mdx",sourceDirName:"Web/lit",slug:"/Web/lit/components",permalink:"/LearningCollection/Web/lit/components",draft:!1,editUrl:"https://github.com/RobinTTY/LearningCollection/tree/master/website/docs/Web/lit/components.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{id:"components",title:"Components",sidebar_position:2},sidebar:"finance",previous:{title:"Introduction",permalink:"/LearningCollection/Web/lit/intro"},next:{title:"Docusaurus",permalink:"/LearningCollection/Web/Static Site Generators/docusaurus"}},p={},c=[{value:"Defining a component",id:"defining-a-component",level:2},{value:"A Lit component is an HTML element",id:"a-lit-component-is-an-html-element",level:3},{value:"Providing good TypeScript typings",id:"providing-good-typescript-typings",level:3},{value:"Rendering",id:"rendering",level:2},{value:"Renderable values",id:"renderable-values",level:3},{value:"A good <code>render()</code> method",id:"a-good-render-method",level:3},{value:"Composing templates",id:"composing-templates",level:3},{value:"When templates render",id:"when-templates-render",level:3},{value:"DOM Encapsulation",id:"dom-encapsulation",level:3},{value:"Reactive Properties",id:"reactive-properties",level:2},{value:"Public properties and internal state",id:"public-properties-and-internal-state",level:3},{value:"Public reactive properties",id:"public-reactive-properties",level:3},{value:"Declaring properties with decorators",id:"declaring-properties-with-decorators",level:4},{value:"Property options",id:"property-options",level:4},{value:"Internal reactive state",id:"internal-reactive-state",level:3},{value:"What happens when properties change",id:"what-happens-when-properties-change",level:3},{value:"More information",id:"more-information",level:4},{value:"Mutating object and array properties",id:"mutating-object-and-array-properties",level:4},{value:"Attributes",id:"attributes",level:3},{value:"Setting the attribute name",id:"setting-the-attribute-name",level:4},{value:"Boolean attributes",id:"boolean-attributes",level:4},{value:"Enabling attribute reflection",id:"enabling-attribute-reflection",level:4},{value:"Custom property accessors",id:"custom-property-accessors",level:3},{value:"Creating custom property accessors",id:"creating-custom-property-accessors",level:4},{value:"Preventing Lit from generating a property accessor",id:"preventing-lit-from-generating-a-property-accessor",level:4},{value:"Customizing change detection",id:"customizing-change-detection",level:3},{value:"Styles",id:"styles",level:2},{value:"Adding styles to your component",id:"adding-styles-to-your-component",level:3},{value:"Using expressions in static styles",id:"using-expressions-in-static-styles",level:4},{value:"Inheriting styles from a superclass",id:"inheriting-styles-from-a-superclass",level:4},{value:"Sharing styles",id:"sharing-styles",level:4},{value:"Using unicode escapes in styles",id:"using-unicode-escapes-in-styles",level:4},{value:"Shadow DOM styling overview",id:"shadow-dom-styling-overview",level:3},{value:"Styling the shadow tree",id:"styling-the-shadow-tree",level:4},{value:"Styling the component itself",id:"styling-the-component-itself",level:4},{value:"Styling the component&#39;s children",id:"styling-the-components-children",level:4},{value:"Expressions and style elements",id:"expressions-and-style-elements",level:4},{value:"Dynamic classes and styles",id:"dynamic-classes-and-styles",level:3},{value:"Theming",id:"theming",level:3}],d={toc:c},m="wrapper";function u(e){let{components:t,...n}=e;return(0,r.kt)(m,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A Lit component is a reusable piece of UI. You can think of a Lit component as a container that has some state and that displays a UI based on its state. It can also react to user input, fire events\u2014anything you'd expect a UI component to do. And a Lit component is an HTML element, so it has all of the standard element APIs."),(0,r.kt)("p",null,"Creating a Lit component involves a number of concepts:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://lit.dev/docs/components/defining/"},"Defining a component"),": A Lit component is implemented as a custom element, registered with the browser."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://lit.dev/docs/components/rendering/"},"Rendering"),": A component has render method that's called to render the component's contents. In the render method, you define a template for the component."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://lit.dev/docs/components/properties/"},"Reactive properties"),": Properties hold the state of the component. Changing one or more of the components' reactive properties triggers an update cycle, re-rendering the component."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://lit.dev/docs/components/styles/"},"Styles"),": A component can define encapsulated styles to control its own appearance."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://lit.dev/docs/components/lifecycle/"},"Lifecycle"),": Lit defines a set of callbacks that you can override to hook into the component's lifecycle\u2014for example, to run code when the element's added to a page, or whenever the component updates.")),(0,r.kt)("h2",{id:"defining-a-component"},"Defining a component"),(0,r.kt)("p",null,"A Lit component is defined by creating a class, extending it with ",(0,r.kt)("inlineCode",{parentName:"p"},"LitElement")," and registering the class with the browser:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'@customElement("simple-greeting")\nexport class SimpleGreeting extends LitElement {\n  /* ... */\n}\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"@customElement")," decorator is shorthand for calling ",(0,r.kt)("inlineCode",{parentName:"p"},"customElements.define"),", which registers a custom element class with the browser and associates it with an element name (in this case, ",(0,r.kt)("inlineCode",{parentName:"p"},"simple-greeting"),")."),(0,r.kt)("h3",{id:"a-lit-component-is-an-html-element"},"A Lit component is an HTML element"),(0,r.kt)("p",null,"When you define a Lit component, you're defining a ",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements"},"custom HTML element"),". So you can use the new element like you'd use any built-in element:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-html"},'<simple-greeting name="Markup"></simple-greeting>\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const greeting = document.createElement("simple-greeting");\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"LitElement")," base class is a subclass of ",(0,r.kt)("inlineCode",{parentName:"p"},"HTMLElement"),", so a Lit component inherits all of the standard ",(0,r.kt)("inlineCode",{parentName:"p"},"HTMLElement")," properties and methods."),(0,r.kt)("p",null,"Specifically, ",(0,r.kt)("inlineCode",{parentName:"p"},"LitElement")," inherits from ",(0,r.kt)("inlineCode",{parentName:"p"},"ReactiveElement"),", which implements reactive properties, and in turn inherits from ",(0,r.kt)("inlineCode",{parentName:"p"},"HTMLElement"),"."),(0,r.kt)("div",{style:{textAlign:"center"}},(0,r.kt)("img",{src:(0,o.Z)("/img/docs/Web/lit/lit-element-inheritance.png")})),(0,r.kt)("h3",{id:"providing-good-typescript-typings"},"Providing good TypeScript typings"),(0,r.kt)("p",null,"TypeScript will infer the class of an HTML element returned from certain DOM APIs based on the tag name. For example, ",(0,r.kt)("inlineCode",{parentName:"p"},"document.createElement('img')")," returns an ",(0,r.kt)("inlineCode",{parentName:"p"},"HTMLImageElement")," instance with a ",(0,r.kt)("inlineCode",{parentName:"p"},"src: string")," property."),(0,r.kt)("p",null,"Custom elements can get this same treatment by adding to the ",(0,r.kt)("inlineCode",{parentName:"p"},"HTMLElementTagNameMap")," as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'@customElement("my-element")\nexport class MyElement extends LitElement {\n  @property({ type: Number })\n  aNumber: number = 5;\n  /* ... */\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    "my-element": MyElement;\n  }\n}\n')),(0,r.kt)("p",null,"By doing this, the following code properly type-checks:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const myElement = document.createElement("my-element");\nmyElement.aNumber = 10;\n')),(0,r.kt)("p",null,"It is recommended to add an ",(0,r.kt)("inlineCode",{parentName:"p"},"HTMLElementTagNameMap")," entry for all elements authored in TypeScript, and ensuring to publish the ",(0,r.kt)("inlineCode",{parentName:"p"},".d.ts")," typings in the npm package."),(0,r.kt)("h2",{id:"rendering"},"Rendering"),(0,r.kt)("p",null,"A template defines what the component should render. Templates can include expressions, which are placeholders for dynamic content."),(0,r.kt)("p",null,"To define a template for a Lit component, add a ",(0,r.kt)("inlineCode",{parentName:"p"},"render()")," method:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { LitElement, html } from "lit";\nimport { customElement } from "lit/decorators.js";\n\n@customElement("my-element")\nclass MyElement extends LitElement {\n  render() {\n    return html`<p>Hello from my template.</p>`;\n  }\n}\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"render()")," method defines your component's internal DOM.\nThe template is written in HTML inside a JavaScript ",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates"},"tagged template literal")," using Lit's ",(0,r.kt)("inlineCode",{parentName:"p"},"html")," tag function."),(0,r.kt)("p",null,"Lit templates can include JavaScript expressions. You can use expressions to set text content, attributes, properties, and event listeners. The ",(0,r.kt)("inlineCode",{parentName:"p"},"render()")," method can also include any JavaScript\u2014for example, you can create local variables for use in expressions."),(0,r.kt)("h3",{id:"renderable-values"},"Renderable values"),(0,r.kt)("p",null,"Typically, the component's ",(0,r.kt)("inlineCode",{parentName:"p"},"render()")," method returns a single ",(0,r.kt)("inlineCode",{parentName:"p"},"TemplateResult")," object (the same type returned by the ",(0,r.kt)("inlineCode",{parentName:"p"},"html")," tag function), an object that describes the HTML for Lit to render.\nHowever, it can return anything that Lit can render as the child of an HTML element:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Primitive values like string, number, or boolean"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"TemplateResult")," objects created by the ",(0,r.kt)("inlineCode",{parentName:"li"},"html")," function"),(0,r.kt)("li",{parentName:"ul"},"DOM Nodes\nThe sentinel values ",(0,r.kt)("a",{parentName:"li",href:"https://lit.dev/docs/templates/conditionals/#conditionally-rendering-nothing"},(0,r.kt)("inlineCode",{parentName:"a"},"nothing"))," and ",(0,r.kt)("a",{parentName:"li",href:"https://lit.dev/docs/templates/custom-directives/#signaling-no-change"},(0,r.kt)("inlineCode",{parentName:"a"},"noChange"))),(0,r.kt)("li",{parentName:"ul"},"Arrays or iterables of any of the supported types")),(0,r.kt)("p",null,"This is almost identical to the set of values that can be rendered to a Lit ",(0,r.kt)("a",{parentName:"p",href:"https://lit.dev/docs/templates/expressions/#child-expressions"},"child expression"),". The one difference is that a child expression can render an ",(0,r.kt)("inlineCode",{parentName:"p"},"SVGTemplateResult"),", returned by the ",(0,r.kt)("inlineCode",{parentName:"p"},"svg")," function. This kind of template result can only be rendered as the descendant of an ",(0,r.kt)("inlineCode",{parentName:"p"},"<svg>")," element."),(0,r.kt)("h3",{id:"a-good-render-method"},"A good ",(0,r.kt)("inlineCode",{parentName:"h3"},"render()")," method"),(0,r.kt)("p",null,"To take best advantage of Lit's functional rendering model, the render() method should follow these guidelines:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Avoid changing the component's state"),(0,r.kt)("li",{parentName:"ul"},"Avoid producing any side effects"),(0,r.kt)("li",{parentName:"ul"},"Use only the component's properties as input"),(0,r.kt)("li",{parentName:"ul"},"Return the same result when given the same property values")),(0,r.kt)("p",null,"Following these guidelines keeps the template deterministic, and makes it easier to reason about the code."),(0,r.kt)("p",null,"In most cases you should avoid making DOM updates outside of ",(0,r.kt)("inlineCode",{parentName:"p"},"render()"),". Instead, express the component's template as a function of its state, and capture its state in properties."),(0,r.kt)("p",null,"For example, if your component needs to update its UI when it receives an event, have the event listener set a reactive property that is used in ",(0,r.kt)("inlineCode",{parentName:"p"},"render()"),", rather than manipulate the DOM directly."),(0,r.kt)("p",null,"For more information, see ",(0,r.kt)("a",{parentName:"p",href:"https://lit.dev/docs/components/properties/"},"Reactive properties"),"."),(0,r.kt)("h3",{id:"composing-templates"},"Composing templates"),(0,r.kt)("p",null,"You can compose Lit templates from other templates. The following example composes a template for a component called ",(0,r.kt)("inlineCode",{parentName:"p"},"<my-page>")," from smaller templates for the page's header, footer, and main content:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { LitElement, html } from "lit";\nimport { customElement, property } from "lit/decorators.js";\n\n@customElement("my-page")\nclass MyPage extends LitElement {\n  @property({ attribute: false })\n  article = {\n    title: "My Nifty Article",\n    text: "Some witty text.",\n  };\n\n  headerTemplate() {\n    return html`<header>${this.article.title}</header>`;\n  }\n\n  articleTemplate() {\n    return html`<article>${this.article.text}</article>`;\n  }\n\n  footerTemplate() {\n    return html`<footer>Your footer here.</footer>`;\n  }\n\n  render() {\n    return html`\n      ${this.headerTemplate()} ${this.articleTemplate()} ${this.footerTemplate()}\n    `;\n  }\n}\n')),(0,r.kt)("p",null,"In this example, the individual templates are defined as instance methods, so a subclass could extend this component and override one or more templates."),(0,r.kt)("p",null,"You can also compose templates by importing other elements and using them in your template:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { LitElement, html } from "lit";\nimport { customElement } from "lit/decorators.js";\n\nimport "./my-header.js";\nimport "./my-article.js";\nimport "./my-footer.js";\n\n@customElement("my-page")\nclass MyPage extends LitElement {\n  render() {\n    return html`\n      <my-header></my-header>\n      <my-article></my-article>\n      <my-footer></my-footer>\n    `;\n  }\n}\n')),(0,r.kt)("h3",{id:"when-templates-render"},"When templates render"),(0,r.kt)("p",null,"A Lit component renders its template initially when it's added to the DOM on a page. After the initial render, any change to the component's reactive properties triggers an update cycle, re-rendering the component."),(0,r.kt)("p",null,"Lit batches updates to maximize performance and efficiency. Setting multiple properties at once triggers only one update, performed asynchronously at microtask timing."),(0,r.kt)("p",null,"During an update, only the parts of the DOM that change are re-rendered. Although Lit templates look like string interpolation, Lit parses and creates static HTML once, and then only updates changed values in expressions after that, making updates very efficient."),(0,r.kt)("h3",{id:"dom-encapsulation"},"DOM Encapsulation"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Lit uses shadow DOM to encapsulate the DOM a component renders.")," Shadow DOM lets an element create its own, isolated DOM tree that's separate from the main document tree. It's a core feature of the web components specifications that enables interoperability, style encapsulation, and other benefits."),(0,r.kt)("h2",{id:"reactive-properties"},"Reactive Properties"),(0,r.kt)("p",null,"Lit components receive input and store their state as JavaScript class fields or properties. Reactive properties are properties that can trigger the reactive update cycle when changed, re-rendering the component, and optionally be read or written to attributes."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"class MyElement extends LitElement {\n  @property()\n  name: string;\n}\n")),(0,r.kt)("p",null,"Lit manages your reactive properties and their corresponding attributes. In particular:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Reactive updates:")," Lit generates a getter/setter pair for each reactive property. When a reactive property changes, the component schedules an update."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Attribute handling:")," By default, Lit sets up an observed attribute corresponding to the property, and updates the property when the attribute changes. Property values can also, optionally, be reflected back to the attribute."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Superclass properties:")," Lit automatically applies property options declared by a superclass. You don't need to redeclare properties unless you want to change options."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Element upgrade:")," If a Lit component is defined after the element is already in the DOM, Lit handles upgrade logic, ensuring that any properties set on an element before it was upgraded trigger the correct reactive side effects when the element upgrades.")),(0,r.kt)("h3",{id:"public-properties-and-internal-state"},"Public properties and internal state"),(0,r.kt)("p",null,"Public properties are part of the component's public API. In general, public properties\u2014especially public reactive properties\u2014should be treated as input."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"The component shouldn't change its own public properties, except in response to user input.")," For example, a menu component might have a public ",(0,r.kt)("inlineCode",{parentName:"p"},"selected")," property that can be initialized to a given value by the owner of the element, but that is updated by the component itself when the user selects an item. In these instances, the component should dispatch an event to indicate to the component's owner that the ",(0,r.kt)("inlineCode",{parentName:"p"},"selected")," property changed. See ",(0,r.kt)("a",{parentName:"p",href:"https://lit.dev/docs/components/events/#dispatching-events"},"Dispatching events")," for more details."),(0,r.kt)("p",null,"Lit also supports ",(0,r.kt)("strong",{parentName:"p"},"internal reactive")," state. Internal reactive state refers to reactive properties that aren't part of the component's API. These properties don't have a corresponding attribute, and are typically marked protected or private in TypeScript."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"@state()\nprivate _counter = 0;\n")),(0,r.kt)("p",null,"The component manipulates its own internal reactive state. In some cases, internal reactive state may be initialized from public properties\u2014for example, if there is an expensive transformation between the user-visible property and the internal state. As with public reactive properties, updating internal reactive state triggers an update cycle. For more information, see ",(0,r.kt)("a",{parentName:"p",href:"https://lit.dev/docs/components/properties/#internal-reactive-state"},"Internal reactive state"),"."),(0,r.kt)("h3",{id:"public-reactive-properties"},"Public reactive properties"),(0,r.kt)("p",null,"Declare your element's public reactive properties using decorators or the static ",(0,r.kt)("inlineCode",{parentName:"p"},"properties")," field. In either case, you can pass an options object to configure features for the property."),(0,r.kt)("h4",{id:"declaring-properties-with-decorators"},"Declaring properties with decorators"),(0,r.kt)("p",null,"Use the ",(0,r.kt)("inlineCode",{parentName:"p"},"@property")," decorator with a class field declaration to declare a reactive property."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"class MyElement extends LitElement {\n  @property({ type: String })\n  mode: string;\n\n  @property({ attribute: false })\n  data = {};\n}\n")),(0,r.kt)("p",null,"The argument to the ",(0,r.kt)("inlineCode",{parentName:"p"},"@property")," decorators is an ",(0,r.kt)("a",{parentName:"p",href:"#property-options"},"options object"),". Omitting the argument is equivalent to specifying the default value for all options."),(0,r.kt)("h4",{id:"property-options"},"Property options"),(0,r.kt)("p",null,"The options object can have the following properties:"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"attribute")),(0,r.kt)("p",null,"Whether the property is associated with an attribute, or a custom name for the associated attribute. Default: true. If attribute is false, the converter, reflect and type options are ignored. For more information, see ",(0,r.kt)("a",{parentName:"p",href:"https://lit.dev/docs/components/properties/#observed-attributes"},"Setting the attribute name"),"."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"converter")),(0,r.kt)("p",null,"A ",(0,r.kt)("a",{parentName:"p",href:"https://lit.dev/docs/components/properties/#conversion-converter"},"custom converter")," for converting between properties and attributes. If unspecified, use the ",(0,r.kt)("a",{parentName:"p",href:"https://lit.dev/docs/components/properties/#conversion-type"},"default attribute converter"),"."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"hasChanged")),(0,r.kt)("p",null,"A function called whenever the property is set to determine if the property has changed, and should trigger an update. If unspecified, LitElement uses a strict inequality check (newValue !== oldValue) to determine whether the property value has changed. For more information, see ",(0,r.kt)("a",{parentName:"p",href:"https://lit.dev/docs/components/properties/#haschanged"},"Customizing change detection"),"."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"noAccessor")),(0,r.kt)("p",null,"Set to true to avoid generating the default property accessors. This option is rarely necessary. Default: false. For more information, see ",(0,r.kt)("a",{parentName:"p",href:"https://lit.dev/docs/components/properties/#accessors-noaccessor"},"Preventing Lit from generating a property accessor"),"."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"reflect")),(0,r.kt)("p",null,"Whether property value is reflected back to the associated attribute. Default: false. For more information, see ",(0,r.kt)("a",{parentName:"p",href:"https://lit.dev/docs/components/properties/#reflected-attributes"},"Enabling attribute reflection"),"."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"state")),(0,r.kt)("p",null,"Set to true to declare the property as internal reactive state. Internal reactive state triggers updates like public reactive properties, but Lit doesn't generate an attribute for it, and users shouldn't access it from outside the component. Equivalent to using the ",(0,r.kt)("inlineCode",{parentName:"p"},"@state")," decorator. Default: false. For more information, see ",(0,r.kt)("a",{parentName:"p",href:"#internal-reactive-state"},"Internal reactive state"),"."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"type")),(0,r.kt)("p",null,"When converting a string-valued attribute into a property, Lit's default attribute converter will parse the string into the type given, and vice-versa when reflecting a property to an attribute. If ",(0,r.kt)("inlineCode",{parentName:"p"},"converter")," is set, this field is passed to the converter. If ",(0,r.kt)("inlineCode",{parentName:"p"},"type")," is unspecified, the default converter treats it as ",(0,r.kt)("inlineCode",{parentName:"p"},"type: String"),". See ",(0,r.kt)("a",{parentName:"p",href:"https://lit.dev/docs/components/properties/#conversion-type"},"Using the default converter"),"."),(0,r.kt)("p",null,"When using TypeScript, this field should generally match the TypeScript type declared for the field. However, the ",(0,r.kt)("inlineCode",{parentName:"p"},"type")," option is used by the Lit's runtime for string serialization/deserialization, and should not be confused with a type-checking mechanism."),(0,r.kt)("p",null,"Omitting the options object or specifying an empty options object is equivalent to specifying the default value for all options."),(0,r.kt)("h3",{id:"internal-reactive-state"},"Internal reactive state"),(0,r.kt)("p",null,"Internal reactive state refers to reactive properties that are not part of the component's public API. These state properties don't have corresponding attributes, and aren't intended to be used from outside the component. Internal reactive state should be set by the component itself."),(0,r.kt)("p",null,"Use the @state decorator to declare internal reactive state:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"@state()\nprotected _active = false;\n")),(0,r.kt)("p",null,"Internal reactive state shouldn't be referenced from outside the component. In TypeScript, these properties should be marked as private or protected. We also recommend using a convention like a leading underscore (",(0,r.kt)("inlineCode",{parentName:"p"},"_"),") to identify private or protected properties for JavaScript users."),(0,r.kt)("p",null,"Internal reactive state works just like public reactive properties, except that there is no attribute associated with the property. ",(0,r.kt)("strong",{parentName:"p"},"The only option you can specify for internal reactive state is the ",(0,r.kt)("inlineCode",{parentName:"strong"},"hasChanged")," function"),"."),(0,r.kt)("h3",{id:"what-happens-when-properties-change"},"What happens when properties change"),(0,r.kt)("p",null,"A property change can trigger a reactive update cycle, which causes the component to re-render its template. When a property changes, the following sequence occurs:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"The property's setter is called."),(0,r.kt)("li",{parentName:"ol"},"The setter calls the component's ",(0,r.kt)("inlineCode",{parentName:"li"},"requestUpdate")," method."),(0,r.kt)("li",{parentName:"ol"},"The property's old and new values are compared.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"By default Lit uses a strict inequality test to determine if the value has changed (that is ",(0,r.kt)("inlineCode",{parentName:"li"},"newValue !== oldValue"),")."),(0,r.kt)("li",{parentName:"ul"},"If the property has a ",(0,r.kt)("inlineCode",{parentName:"li"},"hasChanged")," function, it's called with the property's old and new values."))),(0,r.kt)("li",{parentName:"ol"},"If the property change is detected, an update is scheduled asynchronously. If an update is already scheduled, only a single update is executed."),(0,r.kt)("li",{parentName:"ol"},"The component's ",(0,r.kt)("inlineCode",{parentName:"li"},"update")," method is called, reflecting changed properties to attributes and re-rendering the component's templates.")),(0,r.kt)("h4",{id:"more-information"},"More information"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Note that if you mutate an object or array property, it won't trigger an update, because the object itself hasn't changed. For more information, see ",(0,r.kt)("a",{parentName:"li",href:"https://lit.dev/docs/components/properties/#mutating-properties"},"Mutating object and array properties"),"."),(0,r.kt)("li",{parentName:"ul"},"There are many ways to hook into and modify the reactive update cycle. For more information, see ",(0,r.kt)("a",{parentName:"li",href:"https://lit.dev/docs/components/lifecycle/#reactive-update-cycle"},"Reactive update cycle"),"."),(0,r.kt)("li",{parentName:"ul"},"For more information about property change detection, see ",(0,r.kt)("a",{parentName:"li",href:"https://lit.dev/docs/components/properties/#haschanged"},"Customizing change detection"),".")),(0,r.kt)("h4",{id:"mutating-object-and-array-properties"},"Mutating object and array properties"),(0,r.kt)("p",null,"Mutating an object or array doesn't change the object reference, so it won't trigger an update. You can handle object and array properties in one of two ways:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Immutable data pattern:")," Treat objects and arrays as immutable. For example, to remove an item from ",(0,r.kt)("inlineCode",{parentName:"li"},"myArray"),", construct a new array:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"this.myArray = this.myArray.filter((_, i) => i !== indexToRemove);\n")),(0,r.kt)("p",null,"While this example is simple, it's often helpful to use a library like ",(0,r.kt)("a",{parentName:"p",href:"https://immerjs.github.io/immer/"},"Immer")," to manage immutable data. This can help avoid tricky boilerplate code when setting deeply nested objects."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Manually triggering an update:")," Mutate the data and call ",(0,r.kt)("inlineCode",{parentName:"li"},"requestUpdate()")," to trigger an update directly. For example:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"this.myArray.splice(indexToRemove, 1);\nthis.requestUpdate();\n")),(0,r.kt)("p",null,"When called with no arguments, ",(0,r.kt)("inlineCode",{parentName:"p"},"requestUpdate()")," schedules an update, without calling a ",(0,r.kt)("inlineCode",{parentName:"p"},"hasChanged()")," function. But note that ",(0,r.kt)("inlineCode",{parentName:"p"},"requestUpdate()")," only causes the current component to update. That is, if a component uses the code shown above, and the component passes ",(0,r.kt)("inlineCode",{parentName:"p"},"this.myArray")," to a subcomponent, the subcomponent will detect that the array reference hasn't changed, so it won't update."),(0,r.kt)("p",null,"In general, using top-down data flow with immutable objects is best for most applications. It ensures that every component that needs to render a new value does (and does so as efficiently as possible, since parts of the data tree that didn't change won't cause components that rely on them to update)."),(0,r.kt)("p",null,"Mutating data directly and calling ",(0,r.kt)("inlineCode",{parentName:"p"},"requestUpdate()")," should be considered an advanced use case. In this case, you (or some other system) need to identify all the components that use the mutated data and call ",(0,r.kt)("inlineCode",{parentName:"p"},"requestUpdate()")," on each one. When those components are spread across an application, this gets hard to manage. Not doing so robustly means that you might modify an object that's rendered in two parts of your application, but only have one part update."),(0,r.kt)("p",null,"In simple cases, when you know that a given piece of data is only used in a single component, it should be safe to mutate the data and call ",(0,r.kt)("inlineCode",{parentName:"p"},"requestUpdate()"),", if you prefer."),(0,r.kt)("h3",{id:"attributes"},"Attributes"),(0,r.kt)("p",null,"While properties are great for receiving JavaScript data as input, attributes are the standard way HTML allows configuring elements from markup, without needing to use JavaScript to set properties. Providing both a property and attribute interface for their reactive properties is a key way Lit components can be useful in a wide variety of environments, including those rendered without a client-side templating engine, such as static HTML pages served from CMSs."),(0,r.kt)("p",null,"By default, Lit sets up an observed attribute corresponding to each public reactive property, and updates the property when the attribute changes. ",(0,r.kt)("strong",{parentName:"p"},"Property values can also, optionally, be reflected (written back to the attribute).")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"To ",(0,r.kt)("strong",{parentName:"li"},"observe")," an attribute (set a property from an attribute), the attribute value must be converted from a string to match the property type."),(0,r.kt)("li",{parentName:"ul"},"To ",(0,r.kt)("strong",{parentName:"li"},"reflect")," an attribute (set an attribute from a property), the property value must be converted to a string.")),(0,r.kt)("p",null,"Boolean properties that expose an attribute should default to false. For more information, see ",(0,r.kt)("a",{parentName:"p",href:"https://lit.dev/docs/components/properties/#boolean-attributes"},"Boolean attributes"),"."),(0,r.kt)("h4",{id:"setting-the-attribute-name"},"Setting the attribute name"),(0,r.kt)("p",null,"By default, Lit creates a corresponding observed attribute for all public reactive properties. The name of the observed attribute is the property name, lowercased:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'// observed attribute name is "myvalue"\n@property({ type: Number })\nmyValue = 0;\n')),(0,r.kt)("p",null,"To create an observed attribute with a different name, set ",(0,r.kt)("inlineCode",{parentName:"p"},"attribute")," to a string:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// Observed attribute will be called my-name\n@property({ attribute: 'my-name' })\nmyName = 'Ogden';\n")),(0,r.kt)("p",null,"To prevent an observed attribute from being created for a property, set ",(0,r.kt)("inlineCode",{parentName:"p"},"attribute")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),". The property will not be initialized from attributes in markup, and attribute changes won't affect it."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// No observed attribute for this property\n@property({ attribute: false })\nmyData = {};\n")),(0,r.kt)("p",null,"Internal reactive state never has an associated attribute. An observed attribute can be used to provide an initial value for a property from markup. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-html"},'<my-element my-name="Ogden"></my-element>\n')),(0,r.kt)("h4",{id:"boolean-attributes"},"Boolean attributes"),(0,r.kt)("p",null,"For a boolean property to be configurable from an attribute, ",(0,r.kt)("strong",{parentName:"p"},"it must default to false"),". If it defaults to true, you cannot set it to false from markup, since the presence of the attribute, with or without a value, equates to true. This is the standard behavior for attributes in the web platform."),(0,r.kt)("p",null,"If this behavior doesn't fit your use case, there are a couple of options:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Change the property name so it defaults to false. For example, the web platform uses the ",(0,r.kt)("inlineCode",{parentName:"li"},"disabled")," attribute (defaults to false), not ",(0,r.kt)("inlineCode",{parentName:"li"},"enabled")),(0,r.kt)("li",{parentName:"ul"},"Use a string-valued or number-valued attribute instead")),(0,r.kt)("h4",{id:"enabling-attribute-reflection"},"Enabling attribute reflection"),(0,r.kt)("p",null,"You can configure a property so that whenever it changes, its value is reflected to its corresponding attribute. Reflected attributes are useful because attributes are visible to CSS, and to DOM APIs like ",(0,r.kt)("inlineCode",{parentName:"p"},"querySelector"),"."),(0,r.kt)("p",null,"For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'// Value of property "active" will reflect to attribute "active"\nactive: {\n  reflect: true;\n}\n')),(0,r.kt)("p",null,"When the property changes, Lit sets the corresponding attribute value as described in ",(0,r.kt)("a",{parentName:"p",href:"https://lit.dev/docs/components/properties/#conversion-type"},"Using the default converter")," or ",(0,r.kt)("a",{parentName:"p",href:"https://lit.dev/docs/components/properties/#conversion-converter"},"Providing a custom converter"),"."),(0,r.kt)("p",null,"Attributes should generally be considered input to the element from its owner, rather than under control of the element itself, so reflecting properties to attributes should be done sparingly. It's necessary today for cases like styling and accessibility, but this is likely to change as the platform adds features like the ",(0,r.kt)("a",{parentName:"p",href:"https://wicg.github.io/custom-state-pseudo-class/"},":state pseudo selector")," and the ",(0,r.kt)("a",{parentName:"p",href:"https://wicg.github.io/aom/spec/"},"Accessibility Object Model"),", which fill these gaps."),(0,r.kt)("p",null,"Reflecting properties of type object or array is not recommended. This can cause large objects to serialize to the DOM which can result in poor performance."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Lit tracks reflection state during updates. You may have realized that if property changes are reflected to an attribute and attribute changes update the property, it has the potential to create an infinite loop. However, Lit tracks when properties and attributes are set specifically to prevent this from happening")),(0,r.kt)("h3",{id:"custom-property-accessors"},"Custom property accessors"),(0,r.kt)("p",null,"By default, LitElement generates a getter/setter pair for all reactive properties. The setter is invoked whenever you set the property:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// Declare a property\n@property()\ngreeting: string = 'Hello';\n...\n// Later, set the property\nthis.greeting = 'Hola'; // invokes greeting's generated property accessor\n")),(0,r.kt)("p",null,"Generated accessors automatically call ",(0,r.kt)("inlineCode",{parentName:"p"},"requestUpdate()"),", initiating an update if one has not already begun."),(0,r.kt)("h4",{id:"creating-custom-property-accessors"},"Creating custom property accessors"),(0,r.kt)("p",null,"To specify how getting and setting works for a property, you can define your own getter/setter pair. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"private _prop = 0;\n\nset prop(val: number) {\n  let oldVal = this._prop;\n  this._prop = Math.floor(val);\n  this.requestUpdate('prop', oldVal);\n}\n\n@property()\nget prop() { return this._prop; }\n")),(0,r.kt)("p",null,"To use custom property accessors with the ",(0,r.kt)("inlineCode",{parentName:"p"},"@property")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"@state")," decorators, put the decorator on the getter, as shown above. The setters that Lit generates automatically call ",(0,r.kt)("inlineCode",{parentName:"p"},"requestUpdate()"),". If you write your own setter you must call ",(0,r.kt)("inlineCode",{parentName:"p"},"requestUpdate()")," manually, supplying the property name and its old value."),(0,r.kt)("p",null,"In most cases, ",(0,r.kt)("strong",{parentName:"p"},"you do not need to create custom property accessors"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"To compute values from existing properties, you can use the ",(0,r.kt)("a",{parentName:"li",href:"https://lit.dev/docs/components/lifecycle/#willupdate"},(0,r.kt)("inlineCode",{parentName:"a"},"willUpdate"))," callback, which allows you to set values during the update cycle without triggering an additional update."),(0,r.kt)("li",{parentName:"ul"},"To perform a custom action after the element updates, you can use the ",(0,r.kt)("a",{parentName:"li",href:"https://lit.dev/docs/components/lifecycle/#updated"},(0,r.kt)("inlineCode",{parentName:"a"},"updated"))," callback.")),(0,r.kt)("p",null,"A custom setter can be used in rare cases when it's important to synchronously validate any value the user sets. If your class defines its own accessors for a property, Lit will not overwrite them with generated accessors. If your class does not define accessors for a property, Lit will generate them, even if a superclass has defined the property or accessors."),(0,r.kt)("h4",{id:"preventing-lit-from-generating-a-property-accessor"},"Preventing Lit from generating a property accessor"),(0,r.kt)("p",null,"In rare cases, a subclass may need to change or add property options for a property that exists on its superclass.\nTo prevent Lit from generating a property accessor that overwrites the superclass's defined accessor, set ",(0,r.kt)("inlineCode",{parentName:"p"},"noAccessor")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," in the property declaration:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"static properties = {\n  myProp: { type: Number, noAccessor: true }\n};\n")),(0,r.kt)("p",null,"You don't need to set ",(0,r.kt)("inlineCode",{parentName:"p"},"noAccessor")," when defining your own accessors."),(0,r.kt)("h3",{id:"customizing-change-detection"},"Customizing change detection"),(0,r.kt)("p",null,"All reactive properties have a function, ",(0,r.kt)("inlineCode",{parentName:"p"},"hasChanged()"),", which is called when the property is set.\n",(0,r.kt)("inlineCode",{parentName:"p"},"hasChanged")," compares the property's old and new values, and evaluates whether or not the property has changed. If ",(0,r.kt)("inlineCode",{parentName:"p"},"hasChanged()")," returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),", Lit starts an element update if one is not already scheduled. For more information on updates, see ",(0,r.kt)("a",{parentName:"p",href:"https://lit.dev/docs/components/lifecycle/#reactive-update-cycle"},"Reactive update cycle"),"."),(0,r.kt)("p",null,"The default implementation of ",(0,r.kt)("inlineCode",{parentName:"p"},"hasChanged()")," uses a strict inequality comparison: ",(0,r.kt)("inlineCode",{parentName:"p"},"hasChanged()")," returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if ",(0,r.kt)("inlineCode",{parentName:"p"},"newVal !== oldVal"),". To customize ",(0,r.kt)("inlineCode",{parentName:"p"},"hasChanged()")," for a property, specify it as a property option:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"@property({\n  hasChanged(newVal: string, oldVal: string) {\n    return newVal?.toLowerCase() !== oldVal?.toLowerCase();\n  }\n})\nmyProp: string | undefined;\n")),(0,r.kt)("p",null,"In the following example, ",(0,r.kt)("inlineCode",{parentName:"p"},"hasChanged()")," only returns true for odd values."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{8-12}","{8-12}":!0},'import { LitElement, html } from "lit";\nimport { customElement, property } from "lit/decorators.js";\n\n@customElement("my-element")\nclass MyElement extends LitElement {\n  @property({\n    // only update for odd values of newVal.\n    hasChanged(newVal: number, oldVal: number) {\n      const hasChanged: boolean = newVal % 2 == 1;\n      console.log(`${newVal}, ${oldVal}, ${hasChanged}`);\n      return hasChanged;\n    },\n  })\n  value: number = 1;\n\n  render() {\n    return html`\n      <p>${this.value}</p>\n      <button @click="${this.getNewVal}">Get new value</button>\n    `;\n  }\n\n  getNewVal() {\n    this.value = Math.floor(Math.random() * 100);\n  }\n}\n')),(0,r.kt)("h2",{id:"styles"},"Styles"),(0,r.kt)("p",null,"Your component's template is rendered to its shadow root. The styles you add to your component are automatically scoped to the shadow root and only affect elements in the component's shadow root."),(0,r.kt)("p",null,"Shadow DOM provides strong encapsulation for styling. If Lit did not use Shadow DOM, you would have to be extremely careful not to accidentally style elements outside of your component, either ancestors or children of your component. This might involve writing long, cumbersome to use class names. By using Shadow DOM, Lit ensures whatever selector you write only apply to elements in your Lit component's shadow root."),(0,r.kt)("h3",{id:"adding-styles-to-your-component"},"Adding styles to your component"),(0,r.kt)("p",null,"You define scoped styles in the static ",(0,r.kt)("inlineCode",{parentName:"p"},"styles")," class field using the tagged template literal ",(0,r.kt)("inlineCode",{parentName:"p"},"css")," function. Defining styles this way results in the most optimal performance:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{6-9}","{6-9}":!0},'import { LitElement, html, css } from "lit";\nimport { customElement } from "lit/decorators.js";\n\n@customElement("my-element")\nexport class MyElement extends LitElement {\n  static styles = css`\n    p {\n      color: green;\n    }\n  `;\n  protected render() {\n    return html`<p>I am green!</p>`;\n  }\n}\n')),(0,r.kt)("p",null,"The styles you add to your component are scoped using shadow DOM. For a quick overview, see ",(0,r.kt)("a",{parentName:"p",href:"https://lit.dev/docs/components/styles/#shadow-dom"},"Shadow DOM"),". The value of the static ",(0,r.kt)("inlineCode",{parentName:"p"},"styles")," class field can be:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A single tagged template literal",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"static styles = css`...`;\n"))),(0,r.kt)("li",{parentName:"ul"},"An array of tagged template literals.",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"static styles = [ css`...`, css`...`];\n")))),(0,r.kt)("p",null,"The static ",(0,r.kt)("inlineCode",{parentName:"p"},"styles")," class field is almost always the best way to add styles to your component, but there are some use cases you can't handle this way\u2014for example, customizing styles per instance. For alternate ways to add styles, see ",(0,r.kt)("a",{parentName:"p",href:"https://lit.dev/docs/components/styles/#styles-in-the-template"},"Defining scoped styles in the template"),"."),(0,r.kt)("h4",{id:"using-expressions-in-static-styles"},"Using expressions in static styles"),(0,r.kt)("p",null,"Static styles apply to all instances of a component. Any expressions in CSS are evaluated once, then reused for all instances. For tree-based or per-instance style customization, use CSS custom properties to allow elements to be ",(0,r.kt)("a",{parentName:"p",href:"https://lit.dev/docs/components/styles/#theming"},"themed"),"."),(0,r.kt)("p",null,"To prevent Lit components from evaluating potentially malicious code, the ",(0,r.kt)("inlineCode",{parentName:"p"},"css")," tag only allows nested expressions that are themselves ",(0,r.kt)("inlineCode",{parentName:"p"},"css")," tagged strings or numbers."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const mainColor = css`red`;\n...\nstatic styles = css`\n  div { color: ${mainColor} }\n`;\n")),(0,r.kt)("p",null,"This restriction exists to protect applications from security vulnerabilities whereby malicious styles, or even malicious code, can be injected from untrusted sources such as URL parameters or database values. If you must use an expression in a ",(0,r.kt)("inlineCode",{parentName:"p"},"css")," literal that is not itself a ",(0,r.kt)("inlineCode",{parentName:"p"},"css")," literal, and you are confident that the expression is from a fully trusted source such as a constant defined in your own code, then you can wrap the expression with the ",(0,r.kt)("inlineCode",{parentName:"p"},"unsafeCSS")," function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const mainColor = 'red';\n...\nstatic styles = css`\n  div { color: ${unsafeCSS(mainColor)} }\n`;\n")),(0,r.kt)("admonition",{type:"warning"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"p"},"Only use the ",(0,r.kt)("inlineCode",{parentName:"strong"},"unsafeCSS")," tag with trusted input."),' Injecting unsanitized CSS is a security risk. For example, malicious CSS can "phone home" by adding an image URL that points to a third-party server.')),(0,r.kt)("h4",{id:"inheriting-styles-from-a-superclass"},"Inheriting styles from a superclass"),(0,r.kt)("p",null,"Using an array of tagged template literals, a component can inherit the styles from a superclass, and add its own styles:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="super-element.ts"',title:'"super-element.ts"'},"export class SuperElement extends LitElement {\n  static styles = css`\n    div {\n      border: 1px solid gray;\n      padding: 8px;\n    }\n  ` as CSSResultGroup;\n  protected render() {\n    return html` <div>Content</div> `;\n  }\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="my-element.ts"',title:'"my-element.ts"'},'import { css } from "lit";\nimport { customElement } from "lit/decorators.js";\nimport { SuperElement } from "./super-element.js";\n\n@customElement("my-element")\nexport class MyElement extends SuperElement {\n  static styles = [\n    SuperElement.styles,\n    css`\n      div {\n        color: red;\n      }\n    `,\n  ];\n}\n')),(0,r.kt)("p",null,"You can also use ",(0,r.kt)("inlineCode",{parentName:"p"},"super.styles")," to reference the superclass's styles property in JavaScript. If you're using TypeScript, we recommend avoiding ",(0,r.kt)("inlineCode",{parentName:"p"},"super.styles")," since the compiler doesn't always convert it correctly. Explicitly referencing the superclass, as shown in the example, avoids this issue."),(0,r.kt)("p",null,"When writing components intended to be subclassed in TypeScript, the ",(0,r.kt)("inlineCode",{parentName:"p"},"static styles")," field should be explicitly typed as ",(0,r.kt)("inlineCode",{parentName:"p"},"CSSResultGroup")," to allow flexibility for users to override ",(0,r.kt)("inlineCode",{parentName:"p"},"styles")," with an array:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// Prevent typescript from narrowing the type of `styles` to `CSSResult`\n// so that subclassers can assign e.g. `[SuperElement.styles, css`...`]`;\nstatic styles: CSSResultGroup = css`...`;\n")),(0,r.kt)("h4",{id:"sharing-styles"},"Sharing styles"),(0,r.kt)("p",null,"You can share styles between components by creating a module that exports tagged styles:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"export const buttonStyles = css`\n  .blue-button {\n    color: white;\n    background-color: blue;\n  }\n  .blue-button:disabled {\n    background-color: grey;\n  }\n`;\n")),(0,r.kt)("p",null,"Your element can then import the styles and add them to its static ",(0,r.kt)("inlineCode",{parentName:"p"},"styles")," class field:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { buttonStyles } from "./button-styles.js";\n\nclass MyElement extends LitElement {\n  static styles = [\n    buttonStyles,\n    css`\n      :host {\n        display: block;\n        border: 1px solid black;\n      }\n    `,\n  ];\n}\n')),(0,r.kt)("h4",{id:"using-unicode-escapes-in-styles"},"Using unicode escapes in styles"),(0,r.kt)("p",null,"CSS's unicode escape sequence is a backslash followed by four or six hex digits: for example, ",(0,r.kt)("inlineCode",{parentName:"p"},"\\2022")," for a bullet character. This similar to the format of JavaScript's deprecated octal escape sequences, so using these sequences in a ",(0,r.kt)("inlineCode",{parentName:"p"},"css")," tagged template literal causes an error."),(0,r.kt)("p",null,"There are two work-arounds for adding a unicode escape to your styles:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Add a second backslash (for example, ",(0,r.kt)("inlineCode",{parentName:"li"},"\\\\2022"),")"),(0,r.kt)("li",{parentName:"ul"},"Use the JavaScript escape sequence, starting with ",(0,r.kt)("inlineCode",{parentName:"li"},"\\u")," (for example, ",(0,r.kt)("inlineCode",{parentName:"li"},"\\u2022"),").")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"static styles = css`\n  div::before {\n    content: '\\u2022';\n  }\n`;\n")),(0,r.kt)("h3",{id:"shadow-dom-styling-overview"},"Shadow DOM styling overview"),(0,r.kt)("p",null,"This section gives a brief overview of shadow DOM styling. Styles you add to a component can affect:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://lit.dev/docs/components/styles/#shadowroot"},"The shadow tree")," (your component's rendered template)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://lit.dev/docs/components/styles/#host"},"The component itself")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://lit.dev/docs/components/styles/#slotted"},"The component's children"))),(0,r.kt)("h4",{id:"styling-the-shadow-tree"},"Styling the shadow tree"),(0,r.kt)("p",null,"Lit templates are rendered into a shadow tree by default. Styles scoped to an element's shadow tree don't affect the main document or other shadow trees. Similarly, with the exception of ",(0,r.kt)("a",{parentName:"p",href:"https://lit.dev/docs/components/styles/#inheritance"},"inherited CSS properties"),", document-level styles don't affect the contents of a shadow tree."),(0,r.kt)("p",null,"When you use standard CSS selectors, they only match elements in your component's shadow tree. This means you can often use very simple selectors since you don't have to worry about them accidentally styling other parts of the page; for example: ",(0,r.kt)("inlineCode",{parentName:"p"},"input"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"*"),", or ",(0,r.kt)("inlineCode",{parentName:"p"},"#my-element"),"."),(0,r.kt)("h4",{id:"styling-the-component-itself"},"Styling the component itself"),(0,r.kt)("p",null,"You can style the component itself using special ",(0,r.kt)("inlineCode",{parentName:"p"},":host"),' selectors. (The element that owns, or "hosts" a shadow tree is called the host element.) To create default styles for the host element, use the ',(0,r.kt)("inlineCode",{parentName:"p"},":host")," CSS pseudo-class and ",(0,r.kt)("inlineCode",{parentName:"p"},":host()")," CSS pseudo-class function."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},":host")," selects the host element."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},":host(selector)")," selects the host element, but only if the host element matches selector.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { LitElement, html, css } from "lit";\nimport { customElement } from "lit/decorators/custom-element.js";\n\n@customElement("my-element")\nexport class MyElement extends LitElement {\n  static styles = css`\n    :host {\n      display: block;\n      background-color: lightgray;\n      padding: 8px;\n    }\n    :host(.blue) {\n      background-color: aliceblue;\n      color: darkgreen;\n    }\n  `;\n  protected render() {\n    return html`Hello World`;\n  }\n}\n')),(0,r.kt)("p",null,"Note that the host element can be affected by styles from outside the shadow tree, as well, so you should consider the styles you set in ",(0,r.kt)("inlineCode",{parentName:"p"},":host")," and ",(0,r.kt)("inlineCode",{parentName:"p"},":host()")," rules as default styles that can be overridden by the user. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-css"},"my-element {\n  display: inline-block;\n}\n")),(0,r.kt)("h4",{id:"styling-the-components-children"},"Styling the component's children"),(0,r.kt)("p",null,"Your component may accept children (like a ",(0,r.kt)("inlineCode",{parentName:"p"},"<ul>")," element can have ",(0,r.kt)("inlineCode",{parentName:"p"},"<li>")," children). To render children, your template needs to include one or more ",(0,r.kt)("inlineCode",{parentName:"p"},"<slot>")," elements, as described in ",(0,r.kt)("a",{parentName:"p",href:"https://lit.dev/docs/components/shadow-dom/#slots"},"Render children with the slot element"),"."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"<slot>")," element acts as a placeholder in a shadow tree where the host element's children are displayed. Use the ",(0,r.kt)("inlineCode",{parentName:"p"},"::slotted()")," CSS pseudo-element to select children that are included in your template via ",(0,r.kt)("inlineCode",{parentName:"p"},"<slot>"),"s."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"::slotted(*)")," matches all slotted elements"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"::slotted(p)")," matches slotted paragraphs"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"p ::slotted(*)")," matches slotted elements where the ",(0,r.kt)("inlineCode",{parentName:"li"},"<slot>")," is a descendant of a paragraph element.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { LitElement, html, css } from "lit";\nimport { customElement } from "lit/decorators.js";\n\n@customElement("my-element")\nexport class MyElement extends LitElement {\n  static styles = css`\n    ::slotted(*) {\n      font-family: Roboto;\n    }\n    ::slotted(p) {\n      color: blue;\n    }\n    div ::slotted(*) {\n      color: red;\n    }\n  `;\n  protected render() {\n    return html`\n      <slot></slot>\n      <div><slot name="hi"></slot></div>\n    `;\n  }\n}\n')),(0,r.kt)("p",null,"Note that ",(0,r.kt)("strong",{parentName:"p"},"only direct slotted children")," can be styled with ",(0,r.kt)("inlineCode",{parentName:"p"},"::slotted()"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-html"},"<my-element>\n  <div>Stylable with ::slotted()</div>\n</my-element>\n\n<my-element>\n  <div><p>Not stylable with ::slotted()</p></div>\n</my-element>\n")),(0,r.kt)("p",null,"Also, children can be styled from outside the shadow tree, so you should regard your ",(0,r.kt)("inlineCode",{parentName:"p"},"::slotted()")," styles as default styles that can be overridden."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-css"},"my-element > div {\n  /* Outside style targetting a slotted child can override ::slotted() styles */\n}\n")),(0,r.kt)("h4",{id:"expressions-and-style-elements"},"Expressions and style elements"),(0,r.kt)("p",null,"Using expressions inside style elements has some important limitations and performance issues."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"render() {\n  return html`\n    <style>\n      :host {\n        /* Warning: this approach has limitations & performance issues! */\n        color: ${myColor}\n      }\n    </style>\n    <div>template content</div>\n  `;\n}\n")),(0,r.kt)("p",null,"Evaluating an expression inside a ",(0,r.kt)("inlineCode",{parentName:"p"},"<style>")," element is extremely inefficient. When any text inside a ",(0,r.kt)("inlineCode",{parentName:"p"},"<style>")," element changes, the browser must re-parse the whole ",(0,r.kt)("inlineCode",{parentName:"p"},"<style>")," element, resulting in unnecessary work. To mitigate this cost, separate styles that require per-instance evaluation from those that don't."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"}," static styles = css`/* ... */`;\n  render() {\n    const redStyle = html`<style> :host { color: red; } </style>`;\n    return html`${this.red ? redStyle : ''}`\n  }\n")),(0,r.kt)("h3",{id:"dynamic-classes-and-styles"},"Dynamic classes and styles"),(0,r.kt)("p",null,"One way to make styles dynamic is to add expressions to the ",(0,r.kt)("inlineCode",{parentName:"p"},"class")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"style")," attributes in your template.\nLit offers two directives, ",(0,r.kt)("inlineCode",{parentName:"p"},"classMap")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"styleMap"),", to conveniently apply classes and styles in HTML templates. For more information on these and other directives, see the documentation on ",(0,r.kt)("a",{parentName:"p",href:"https://lit.dev/docs/templates/directives/"},"built-in directives"),"."),(0,r.kt)("p",null,"To use ",(0,r.kt)("inlineCode",{parentName:"p"},"styleMap")," and/or ",(0,r.kt)("inlineCode",{parentName:"p"},"classMap"),":"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Import ",(0,r.kt)("inlineCode",{parentName:"li"},"classMap")," and/or ",(0,r.kt)("inlineCode",{parentName:"li"},"styleMap"),":")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { classMap } from "lit/directives/class-map.js";\nimport { styleMap } from "lit/directives/style-map.js";\n')),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},"Use ",(0,r.kt)("inlineCode",{parentName:"li"},"classMap")," and/or ",(0,r.kt)("inlineCode",{parentName:"li"},"styleMap")," in your element template:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { LitElement, html, css } from "lit";\nimport { customElement, property } from "lit/decorators.js";\nimport { classMap } from "lit/directives/class-map.js";\nimport { styleMap } from "lit/directives/style-map.js";\n\n@customElement("my-element")\nexport class MyElement extends LitElement {\n  static styles = css`\n    .someclass {\n      border: 1px solid red;\n      padding: 4px;\n    }\n    .anotherclass {\n      background-color: navy;\n    }\n  `;\n  @property()\n  classes = { someclass: true, anotherclass: true };\n  @property()\n  styles = { color: "lightgreen", fontFamily: "Roboto" };\n  protected render() {\n    return html`\n      <div class=${classMap(this.classes)} style=${styleMap(this.styles)}>\n        Some content\n      </div>\n    `;\n  }\n}\n')),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"https://lit.dev/docs/templates/directives/#classmap"},"classMap")," and ",(0,r.kt)("a",{parentName:"p",href:"https://lit.dev/docs/templates/directives/#stylemap"},"styleMap")," for more information."),(0,r.kt)("h3",{id:"theming"},"Theming"))}u.isMDXComponent=!0}}]);