"use strict";(globalThis.webpackChunklearning_knowledge_base=globalThis.webpackChunklearning_knowledge_base||[]).push([[5465],{26860:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"web/typescript/core-concepts/functions","title":"Functions","description":"Functions are the basic building block of any application, whether they\u2019re local functions, imported from another module, or methods on a class. They\u2019re also values, and just like other values, TypeScript has many ways to describe how functions can be called.","source":"@site/docs/web/typescript/core-concepts/functions.md","sourceDirName":"web/typescript/core-concepts","slug":"/web/typescript/core-concepts/functions","permalink":"/LearningCollection/web/typescript/core-concepts/functions","draft":false,"unlisted":false,"editUrl":"https://github.com/RobinTTY/LearningCollection/tree/master/website/docs/web/typescript/core-concepts/functions.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"id":"functions","title":"Functions","sidebar_position":3},"sidebar":"docs","previous":{"title":"Enums","permalink":"/LearningCollection/web/typescript/core-concepts/enums"},"next":{"title":"Classes","permalink":"/LearningCollection/web/typescript/core-concepts/classes"}}');var i=t(74848),a=t(28453);const r={id:"functions",title:"Functions",sidebar_position:3},o=void 0,c={},l=[{value:"Type Expressions",id:"type-expressions",level:2},{value:"Rest Parameters",id:"rest-parameters",level:2},{value:"Overloads",id:"overloads",level:2}];function p(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"Functions are the basic building block of any application, whether they\u2019re local functions, imported from another module, or methods on a class. They\u2019re also values, and just like other values, TypeScript has many ways to describe how functions can be called."}),"\n",(0,i.jsx)(n.h2,{id:"type-expressions",children:"Type Expressions"}),"\n",(0,i.jsx)(n.p,{children:"The simplest way to describe a function is with a function type expression. These types are syntactically similar to arrow functions:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'function greeter(fn: (a: string) => void) {\n  fn("Hello, World");\n}\n\nfunction printToConsole(s: string) {\n  console.log(s);\n}\n\ngreeter(printToConsole);\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The syntax ",(0,i.jsx)(n.code,{children:"(a: string) => void"})," means \u201ca function with one parameter, named ",(0,i.jsx)(n.code,{children:"a"}),", of type string, that doesn\u2019t have a return value\u201d. Just like with function declarations, if a parameter type isn\u2019t specified, it\u2019s implicitly ",(0,i.jsx)(n.code,{children:"any"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Of course, we can use a type alias to name a function type:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"type GreetFunction = (a: string) => void;\nfunction greeter(fn: GreetFunction) {\n  // ...\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"rest-parameters",children:"Rest Parameters"}),"\n",(0,i.jsxs)(n.p,{children:["When a function has a rest parameter, it is treated as if it were an infinite series of optional parameters. This is unsound from a type system perspective, but from a runtime point of view the idea of an optional parameter is generally not well-enforced since passing ",(0,i.jsx)(n.code,{children:"undefined"})," in that position is equivalent for most functions."]}),"\n",(0,i.jsxs)(n.p,{children:["A rest parameter appears after all other parameters, and uses the ",(0,i.jsx)(n.code,{children:"..."})," syntax:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"function multiply(n: number, ...m: number[]) {\n  return m.map((x) => n * x);\n}\n// 'a' gets value [10, 20, 30, 40]\nconst a = multiply(10, 1, 2, 3, 4);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In TypeScript, the type annotation on these parameters is implicitly ",(0,i.jsx)(n.code,{children:"any[]"})," instead of ",(0,i.jsx)(n.code,{children:"any"}),", and any type annotation given must be of the form ",(0,i.jsx)(n.code,{children:"Array<T>"})," or ",(0,i.jsx)(n.code,{children:"T[]"}),", or a tuple type."]}),"\n",(0,i.jsx)(n.p,{children:"With tuples it is possible to limit the number of elements in the rest parameter:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"function multiply(n: number, ...m: [number, number, number]) {\n  return m.map((x) => n * x);\n}\n// 'a' gets value [10, 20, 30]\nconst a = multiply(10, 1, 2, 3);\n"})}),"\n",(0,i.jsx)(n.h2,{id:"overloads",children:"Overloads"}),"\n",(0,i.jsxs)(n.p,{children:["Some JavaScript functions can be called in a variety of argument counts and types. For example, you might write a function to produce a ",(0,i.jsx)(n.code,{children:"Date"})," that takes either a timestamp (one argument) or a month/day/year specification (three arguments)."]}),"\n",(0,i.jsx)(n.p,{children:"In TypeScript, we can specify a function that can be called in different ways by writing overload signatures:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"function makeDate(timestamp: number): Date;\nfunction makeDate(m: number, d: number, y: number): Date;\nfunction makeDate(mOrTimestamp: number, d?: number, y?: number): Date {\n  if (d !== undefined && y !== undefined) {\n    return new Date(y, mOrTimestamp, d);\n  } else {\n    return new Date(mOrTimestamp);\n  }\n}\nconst d1 = makeDate(12345678);\nconst d2 = makeDate(5, 5, 5);\n// Error if we do this:\nconst d3 = makeDate(1, 3);\n"})}),"\n",(0,i.jsx)(n.p,{children:"In this example, we wrote two overloads: one accepting one argument, and another accepting three arguments. These first two signatures are called the overload signatures."}),"\n",(0,i.jsx)(n.p,{children:"Then, we wrote a function implementation with a compatible signature (for all overload signature). Functions have an implementation signature, but this signature can\u2019t be called directly. Even though we wrote a function with two optional parameters after the required one, it can\u2019t be called with two parameters!"})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var s=t(96540);const i={},a=s.createContext(i);function r(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);