"use strict";(self.webpackChunklearning_knowledge_base=self.webpackChunklearning_knowledge_base||[]).push([[1277],{87109:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>c});var i=t(74848),s=t(28453);const o={id:"userFacingBackend",title:"User-Facing Backend",sidebar_position:4},a=void 0,r={id:"databases/mongodb/m220n-mongodb-for-dotnet-developers/userFacingBackend",title:"User-Facing Backend",description:"Aggregation Pipeline",source:"@site/docs/databases/mongodb/m220n-mongodb-for-dotnet-developers/User-Facing Backend.md",sourceDirName:"databases/mongodb/m220n-mongodb-for-dotnet-developers",slug:"/databases/mongodb/m220n-mongodb-for-dotnet-developers/userFacingBackend",permalink:"/LearningCollection/databases/mongodb/m220n-mongodb-for-dotnet-developers/userFacingBackend",draft:!1,unlisted:!1,editUrl:"https://github.com/RobinTTY/LearningCollection/tree/master/website/docs/databases/mongodb/m220n-mongodb-for-dotnet-developers/User-Facing Backend.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{id:"userFacingBackend",title:"User-Facing Backend",sidebar_position:4},sidebar:"docs",previous:{title:"Using the Driver",permalink:"/LearningCollection/databases/mongodb/m220n-mongodb-for-dotnet-developers/usingTheDriver"},next:{title:"Admin Backend",permalink:"/LearningCollection/databases/mongodb/m220n-mongodb-for-dotnet-developers/adminBackend"}},l={},c=[{value:"Aggregation Pipeline",id:"aggregation-pipeline",level:2},{value:"Example",id:"example",level:3},{value:"Example of a similar (but not the same) pipeline in C#",id:"example-of-a-similar-but-not-the-same-pipeline-in-c",level:3},{value:"Faceted Search",id:"faceted-search",level:2},{value:"MFlix Functionality",id:"mflix-functionality",level:3},{value:"Basic Writes",id:"basic-writes",level:2},{value:"Example",id:"example-1",level:3},{value:"Basic Updates",id:"basic-updates",level:2},{value:"Examples",id:"examples",level:3},{value:"Write Concerns",id:"write-concerns",level:2},{value:"writeConcern: <code>{ w: 1 }</code>",id:"writeconcern--w-1-",level:3},{value:"writeConcern: <code>{ w: majority }</code>",id:"writeconcern--w-majority-",level:3},{value:"writeConcern: <code>{ w: 0 }</code>",id:"writeconcern--w-0-",level:3},{value:"Example",id:"example-2",level:3},{value:"Joins",id:"joins",level:2},{value:"Basic Deletes",id:"basic-deletes",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"aggregation-pipeline",children:"Aggregation Pipeline"}),"\n",(0,i.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Aggregation Pipeline",src:t(12742).A+"",width:"1911",height:"1285"})}),"\n",(0,i.jsx)(n.h3,{id:"example-of-a-similar-but-not-the-same-pipeline-in-c",children:"Example of a similar (but not the same) pipeline in C#"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cs",children:'public void CountMovies()\n        {\n            // This stage finds all movies that have a specific director\n            var matchStage = new BsonDocument("$match",\n                new BsonDocument("directors", "Rob Reiner"));\n\n\n            // This stage sorts the results by the number of reviews,\n            // in descending order\n            var sortStage = new BsonDocument("$sort",\n                new BsonDocument("tomatoes.viewer.numReviews", -1));\n\n            // This stage generates the projection we want\n            var projectionStage = new BsonDocument("$project",\n                new BsonDocument\n                    {\n                        { "_id", 0 },\n                        { "Movie Title", "$title" },\n                        { "Year", "$year" },\n                        { "Average User Rating", "$tomatoes.viewer.rating" }\n                    });\n\n            /* We now put the stages together in a pipeline. Note that a\n             * pipeline definition requires us to specify the input and output\n             * types. In this case, the input is of type Movie, but because\n             * we are using a Projection with custom fields, our output is\n             * a generic BsonDocument object. To be really cool, we could\n             * create a mapping class for the output type, which is what we\'ve\n             * done for you in the MFlix application.\n             */\n\n            var pipeline = PipelineDefinition<Movie, BsonDocument>\n                .Create(new BsonDocument[] {\n                    matchStage,\n                    sortStage,\n                    projectionStage\n                });\n\n\n            var result = _moviesCollection.Aggregate(pipeline).ToList();\n            /* Note: we\'re making a synchronous Aggregate() call.\n             * If you want a challenge, change the line above to make an\n             * asynchronous call (hint: you\'ll need to make 2 changes),\n             * and then confirm the unit test still passes.\n             */\n\n            Assert.AreEqual(14, result.Count);\n            var firstMovie = result[0];\n            Assert.AreEqual("The Princess Bride", firstMovie.GetValue("Movie Title").AsString);\n            Assert.AreEqual(1987, firstMovie.GetValue("Year").AsInt32);\n            Assert.AreEqual(4.0, firstMovie.GetValue("Average User Rating").AsDouble);\n\n            /* We specifically excluded the "Id" field in the projection stage\n             * that we built in the code above, so let\'s make sure that field\n             * wasn\'t included in the resulting BsonDocument. We expect the call\n             * to GetValue() to throw a KeyNotFoundException exception if the\n             * field doesn\'t exist.\n             */\n\n            Assert.Throws<KeyNotFoundException>(()=> firstMovie.GetValue("Id"));\n        }\n'})}),"\n",(0,i.jsx)(n.h2,{id:"faceted-search",children:"Faceted Search"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"http://en.wikipedia.org/wiki/Faceted_search",children:"Faceted search"}),", or faceted navigation, is a way of browsing and searching for items in a set of data by applying filters on various properties (facets) of the items in the collection"]}),"\n",(0,i.jsx)(n.li,{children:"It is increasingly seen as an important part of the UI for many search platforms, and indeed nowadays is pretty much expected in places such as e-commerce websites"}),"\n",(0,i.jsx)(n.li,{children:"It complements more free-form keyword search by facilitating exploration and discovery and is therefore useful when a user may not know the specific keywords they wish to search on."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Some core functionality that a faceted search feature should provide might include:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["finding the items that match a particular value of a certain facet (e.g. colour",":blue",")"]}),"\n",(0,i.jsxs)(n.li,{children:["finding the items in the intersection of multiple facet values (e.g. colour",":blue"," AND size",":medium",")"]}),"\n",(0,i.jsxs)(n.li,{children:["finding the items in the union of multiple facet values (e.g. colour",":blue"," OR colour",":red"," OR size",":large",")"]}),"\n",(0,i.jsx)(n.li,{children:'for each possible facet filter combination, display to the user the possible facet values on which it is possible to filter further ("drill down")'}),"\n",(0,i.jsx)(n.li,{children:"for each facet value on which it is possible to drill down, display to the user the count of items matching that filter."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["For more info see the ",(0,i.jsx)(n.a,{href:"https://www.mongodb.com/blog/post/faceted-search-with-mongodb",children:"MongoDB Blog"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"mflix-functionality",children:"MFlix Functionality"}),"\n",(0,i.jsx)(n.p,{children:"Faceted Search is a way of narrowing down search results by adding search parameters. For example let's say MFlix allows users to filter movies by a rating from 1 to 10, but Kate Winslet has only acted in movies that have a rating of 6 or higher."}),"\n",(0,i.jsx)(n.p,{children:'If we didn\'t specify any other search parameters, MFlix would allow us to choose a rating between 1 and 10. But if we first search for "Kate Winslet", MFlix would only let us choose a rating between 6 and 10, because none of the movie documents in the result set have a rating below 6.'}),"\n",(0,i.jsxs)(n.p,{children:["To use faceted searches, the application must use the ",(0,i.jsx)(n.strong,{children:"$facet pipeline stage"})," of the Aggregation Framework."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note:"})," To see how facets work see the ",(0,i.jsx)(n.a,{href:"https://university.mongodb.com/courses/M121/about",children:"Aggregation Framework Course"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"basic-writes",children:"Basic Writes"}),"\n",(0,i.jsxs)(n.p,{children:["To add something new to the database we can use the methods ",(0,i.jsx)(n.code,{children:"InsertOneAsync"})," and ",(0,i.jsx)(n.code,{children:"InsertManyAsync"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"example-1",children:"Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cs",children:'public async Task CreateMovieAsync()\n{\n\n    var newTheater = new Theater(27777,\n                    "4 Privet Drive",\n                    "Little Whinging",\n                    "LA",\n                    "343434");\n\n    await _theatersCollection.InsertOneAsync(newTheater);\n\n\n    // Add many\n    var theater1 = new Theater(27017, "1 Foo Street", "Dingledongle", "DE", "45678");\n    var theater2 = new Theater(27018, "234 Bar Ave.", "Wishywashy", "WY", "87654");\n    var theater3 = new Theater(27019, "75 Birthday Road", "Viejo Amigo", "CA", "99887");\n\n    await _theatersCollection.InsertManyAsync(\n        new List<Theater>()\n        {\n            theater1, theater2, theater3\n        }\n    );\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"basic-updates",children:"Basic Updates"}),"\n",(0,i.jsxs)(n.p,{children:["To update something in the database we can use the methods ",(0,i.jsx)(n.code,{children:"UpdateOneAsync"}),", ",(0,i.jsx)(n.code,{children:"UpdateManyAsync"})," and ",(0,i.jsx)(n.code,{children:"FindOneAndUpdateAsync"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"examples",children:"Examples"}),"\n",(0,i.jsx)(n.p,{children:"Updating one document:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cs",children:'// not type safe\nvar updateResult = _theatersCollection.UpdateOne(filter,\n    new BsonDocument("$set",\n        new BsonDocument("location.address.street1", "123 Main St."))\n    );\n\n// With the builder\n_theatersCollection.UpdateOne(filter,\n    Builders<Theater>.Update.Set(t => t.Location.Address.Street1,\n        "123 Main St.")\n    );\n\n// if you want to do something with the updated document use FindOneAndUpdateAsync\nvar updatedDoc = await _theatersCollection.FindOneAndUpdateAsync<Theater>(\n                filter,\n                Builders<Theater>.Update.Set(\n                    t => t.Location.Address.Street1,\n                    "123 Main St.")\n                );\n'})}),"\n",(0,i.jsx)(n.p,{children:"Updating many documents:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cs",children:'var update = Builders<Theater>\n                .Update.Set(t => t.Location.Address.City, "Bloomington");\n\n// And then we run UpdateManyAsync:\nvar result = await _theatersCollection.UpdateManyAsync(\n    filter,\n    update\n    );\n'})}),"\n",(0,i.jsx)(n.h2,{id:"write-concerns",children:"Write Concerns"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Write concerns are important when there are more than one data source"}),"\n",(0,i.jsx)(n.li,{children:"An Atlas replica set is an example where write concerns can be important"}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"writeconcern--w-1-",children:["writeConcern: ",(0,i.jsx)(n.code,{children:"{ w: 1 }"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Only requests an acknowledgement that one node applied the write"}),"\n",(0,i.jsx)(n.li,{children:"This is the default writeConcern in MongoDB"}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"writeconcern--w-majority-",children:["writeConcern: ",(0,i.jsx)(n.code,{children:"{ w: majority }"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Requests acknowledgement that a majority of nodes in the replica set applied the write"}),"\n",(0,i.jsx)(n.li,{children:"Takes longer than w: 1"}),"\n",(0,i.jsxs)(n.li,{children:["Is more durable than w: 1","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Useful for ensuring vital writes are majority-committed"}),"\n",(0,i.jsx)(n.li,{children:"e.g. user registration"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"writeconcern--w-0-",children:["writeConcern: ",(0,i.jsx)(n.code,{children:"{ w: 0 }"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Does not request an acknowledgement that any nodes applied the write","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:'"Fire and forget"'}),"\n",(0,i.jsx)(n.li,{children:"acknowledgement can still indicate network errors or socket exceptions"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:"Fastest writeConcern level"}),"\n",(0,i.jsx)(n.li,{children:"Least durable writeConcern"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"example-2",children:"Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cs",children:"await _usersCollection.WithWriteConcern(WriteConcern.WMajority).InsertOneAsync(user, cancellationToken: cancellationToken);\n"})}),"\n",(0,i.jsx)(n.h2,{id:"joins",children:"Joins"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Join two collections of data","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Movies and comments"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["Use new expressive $lookup","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"allows us to apply aggregation pipelines to data - before the data is joined"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:"Build aggregation in Compass, and then export to language"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Join comments to movies (this pipeline is executed upon the movies collection):"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cs",children:'// $match stage\n{\n  year: { "$gte": 1980, "$lt": 1990 }\n}\n\n// $lookup stage\n// from: collection we are joining from\n{\n  from: "comments",\n  // pipeline has access to fields inside comments collection\n  // but not to fields inside the movies collection\n  // if we need fields from movies we need to declare them in let\n  // this makes _id available in the pipeline as "id"\n  // this variable is referred to with the "$$" signs (movies collection)\n  // one "$" sign refers to the comments collection!\n  let: { "id": "$_id" },\n  pipeline: [\n    {\n      "$match":\n      // matches the comment "movie_id" field to the movie "id" field\n      { "$expr": { "$eq": [ "$movie_id", "$$id" ]} }\n    }\n  ],\n  // each movie has a new field movie_comments with the comments as array\n  as: "movie_comments"\n}\n\n// if we only care about how many comments there are, we can add a stage to our pipeline\n{\n  from: "comments",\n  let: { "id": "$_id" },\n  pipeline: [\n    {\n      "$match":\n      { "$expr": { "$eq": [ "$movie_id", "$$id" ]} }\n    },\n    {\n      "$count": "count"\n    }\n  ],\n  as: "movie_comments"\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"We can also export the pipeline from Compass to C# code:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cs",children:'new BsonArray\n{\n    new BsonDocument("$match",\n    new BsonDocument("year",\n    new BsonDocument\n            {\n                { "$gte", 1980 },\n                { "$lt", 1990 }\n            })),\n    new BsonDocument("$lookup",\n    new BsonDocument\n        {\n            { "from", "comments" },\n            { "let",\n    new BsonDocument("id", "$_id") },\n            { "pipeline",\n    new BsonArray\n            {\n                new BsonDocument("$match",\n                new BsonDocument("$expr",\n                new BsonDocument("$eq",\n                new BsonArray\n                            {\n                                "$movie_id",\n                                "$$id"\n                            })))\n            } },\n            { "as", "movie_comments" }\n        })\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Better approach:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cs",children:'/* Approach that uses several helpful methods in the driver:\n    * Aggregate(), Match(), and Lookup(), each of which is represented\n    * in the code above as MQL. The Lookup() method is a bit complex;\n    * here is an explanation of each of the parameters:\n    *\n    *  - The collection from which we want to lookup the values\n    *      (in this case, the Comments collection)\n    *  - The "key" in the Movies collection that will match a key in\n    *      the Comments collection.\n    *  - The "key" in the Comments collection that matches the previous\n    *      parameter. In both cases, it\'s the _id of each Movie we match\n    *      in the Match state.\n    *  - The property in which we want to put the lookup results. We\n    *      have already defined a Comments property on the Movie object\n    *      for just this purpose, so we specify it here.\n    *\n    */\nvar movies = _moviesCollection\n    .Aggregate()  // begins a fluent aggregation\n    .Match(m => (int)m.Year < 1990 && (int)m.Year >= 1980)\n    .Lookup(\n        _commentsCollection,\n        m => m.Id,\n        c => c.MovieId,\n        (Movie m)=>m.Comments\n        )\n    .ToList();\n\nvar firstMovie = movies.First();\n'})}),"\n",(0,i.jsx)(n.h2,{id:"basic-deletes",children:"Basic Deletes"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cs",children:'// delete one document\nvar filter = Builders<Theater>.Filter.Eq(t => t.TheaterId, 27017);\nvar result = await _theatersCollection.DeleteOneAsync(filter);\n\n// delete one document but return it\nfilter = Builders<Theater>.Filter.Eq(t => t.TheaterId, 27018);\nvar deletedDoc = await _theatersCollection.FindOneAndDeleteAsync(filter);\n\n// delete many\nvar filter = Builders<Theater>.Filter.Eq(t => t.Location.Address.City, "Movieville");\nvar result = await _theatersCollection.DeleteManyAsync(filter);\n'})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},12742:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/Pipeline-b4ab3c167f1f55b14cb4e3817a730a2b.PNG"},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var i=t(96540);const s={},o=i.createContext(s);function a(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);