"use strict";(globalThis.webpackChunklearning_knowledge_base=globalThis.webpackChunklearning_knowledge_base||[]).push([[5726],{48916:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>t,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"kubernetes/miscellaneous-concepts","title":"Miscellaneous Concepts","description":"ConfigMaps and Secrets","source":"@site/docs/kubernetes/misc-concepts.md","sourceDirName":"kubernetes","slug":"/kubernetes/miscellaneous-concepts","permalink":"/LearningCollection/kubernetes/miscellaneous-concepts","draft":false,"unlisted":false,"editUrl":"https://github.com/RobinTTY/LearningCollection/tree/master/website/docs/kubernetes/misc-concepts.md","tags":[],"version":"current","frontMatter":{"id":"miscellaneous-concepts","title":"Miscellaneous Concepts"},"sidebar":"docs","previous":{"title":"Core Components","permalink":"/LearningCollection/kubernetes/core-components"},"next":{"title":"Network","permalink":"/LearningCollection/kubernetes/network"}}');var r=s(74848),o=s(28453);const l={id:"miscellaneous-concepts",title:"Miscellaneous Concepts"},t=void 0,d={},c=[{value:"ConfigMaps and Secrets",id:"configmaps-and-secrets",level:2},{value:"Scheduling",id:"scheduling",level:2},{value:"Taints and Tolerations",id:"taints-and-tolerations",level:2},{value:"Node Selectors and Affinity",id:"node-selectors-and-affinity",level:2},{value:"Autoscaling",id:"autoscaling",level:2},{value:"Resource Quotas and Requirements",id:"resource-quotas-and-requirements",level:2},{value:"Labels and Annotations",id:"labels-and-annotations",level:2},{value:"Admission Controller",id:"admission-controller",level:2},{value:"Monitoring",id:"monitoring",level:2},{value:"Priority",id:"priority",level:2},{value:"PriorityClass",id:"priorityclass",level:3},{value:"High priority Pods",id:"high-priority-pods",level:3},{value:"Preemption",id:"preemption",level:3}];function a(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"configmaps-and-secrets",children:"ConfigMaps and Secrets"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["ConfigMaps:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Store non-confidential data in key-value pairs"}),"\n",(0,r.jsx)(n.li,{children:"Consumed by pods as environment variables, command-line arguments, or configuration files"}),"\n",(0,r.jsx)(n.li,{children:"Used to decouple environment-specific configurations from application code"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Secrets:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Store sensitive data such as passwords, OAuth tokens, and SSH keys"}),"\n",(0,r.jsx)(n.li,{children:"Similar to ConfigMaps but with additional security measures"}),"\n",(0,r.jsx)(n.li,{children:"Can be consumed by pods in the same way as ConfigMaps"}),"\n",(0,r.jsx)(n.li,{children:"By default stored unencrypted in etcd, but can be encrypted at rest"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"scheduling",children:"Scheduling"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Kubernetes scheduler is responsible for placing pods on nodes"}),"\n",(0,r.jsx)(n.li,{children:"Scheduling is done for pods where spec.nodeName is not set"}),"\n",(0,r.jsx)(n.li,{children:"Scheduler runs as a pod in the kube-system namespace"}),"\n",(0,r.jsxs)(n.li,{children:["There can be multiple schedulers as well as custom schedulers (each one has a profile)","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["On pod: ",(0,r.jsx)(n.code,{children:'spec.schedulerName: "my-custom-scheduler"'})]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Phases:","\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Filtering: Filters nodes based on resource requirements, affinity/anti-affinity rules, taints, etc."}),"\n",(0,r.jsx)(n.li,{children:"Scoring: Ranks the filtered nodes based on various criteria (e.g., resource availability, node health)"}),"\n",(0,r.jsx)(n.li,{children:"Binding: Binds the pod to the selected node"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"taints-and-tolerations",children:"Taints and Tolerations"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Taints are applied to nodes to repel pods that do not tolerate them"}),"\n",(0,r.jsx)(n.li,{children:"Tolerations are applied to pods to allow them to be scheduled on nodes with specific taints"}),"\n",(0,r.jsx)(n.li,{children:"Taints and tolerations are used to control pod placement and ensure that pods are scheduled on appropriate nodes"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"node-selectors-and-affinity",children:"Node Selectors and Affinity"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Node selectors are used to constrain pods to run on specific nodes based on labels"}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"spec.nodeSelector"})," is used to specify the labels that a node must have for the pod to be scheduled on it"]}),"\n",(0,r.jsxs)(n.li,{children:["Affinity rules provide more advanced scheduling options:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Node affinity: Similar to node selectors but allows for more complex rules (e.g., preferred vs. required)"}),"\n",(0,r.jsx)(n.li,{children:"Pod affinity/anti-affinity: Allows pods to be scheduled based on the presence or absence of other pods"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"autoscaling",children:"Autoscaling"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Kubernetes supports automatic horizontal and vertical scaling of pods/clusters","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"for clusters: Cluster Autoscaler"}),"\n",(0,r.jsx)(n.li,{children:"for pods: Horizontal Pod Autoscaler (HPA) and Vertical Pod Autoscaler (VPA)"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.li,{children:"VPA adjusts CPU & memory of pods (good for DBs)"}),"\n",(0,r.jsx)(n.li,{children:"HPA adjusts number of pods"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"resource-quotas-and-requirements",children:"Resource Quotas and Requirements"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Resource quotas can be applied to a namespace to limit available resources"}),"\n",(0,r.jsxs)(n.li,{children:["Resource requirements can be specified for pods to ensure they have the necessary resources to run","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Requests: the minimum amount of cpu/memory that needs to be available to schedule the pod"}),"\n",(0,r.jsx)(n.li,{children:"Limits: the maximum amount of cpu/memory that can be used by the pod"}),"\n",(0,r.jsxs)(n.li,{children:["Suffixes: ",(0,r.jsx)(n.code,{children:"m"})," for milli (e.g. 1000m = 1 CPU), ",(0,r.jsx)(n.code,{children:"Mi"})," for Mebibytes (e.g. 1024 MiB = 1 GiB)\nLimit Range: Constraints resource allocation for each object kind (e.g. pod/pvc) in a namespace"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",metastring:'title="Resource Quota Example"',children:'spec:\n  containers:\n    - name: my-container\n      resources:\n        requests:\n        memory: "64Mi"\n        cpu: "250m"\n        limits:\n        memory: "128Mi"\n        cpu: "500m"\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",metastring:'title="Limit Range Example"',children:'spec:\n  limits:\n    - default:\n        cpu: "500m"\n        memory: "128Mi"\n      defaultRequest:\n        cpu: "250m"\n        memory: "64Mi"\n      type: Container\n'})}),"\n",(0,r.jsx)(n.h2,{id:"labels-and-annotations",children:"Labels and Annotations"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Labels are key-value pairs attached to objects (e.g., pods, services) for identification and selection","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Used for grouping and selecting objects (e.g., ",(0,r.jsx)(n.code,{children:"spec.selector.matchLabels"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:["Example: ",(0,r.jsx)(n.code,{children:"app: my-app"}),", ",(0,r.jsx)(n.code,{children:"env: production"})]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Annotations are also key-value pairs but used for storing non-identifying metadata","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Can be used to store additional information about an object (e.g., build version, maintainer)"}),"\n",(0,r.jsx)(n.li,{children:"Not used for selection or grouping"}),"\n",(0,r.jsxs)(n.li,{children:["Example: ",(0,r.jsx)(n.code,{children:'description: "This is my application"'}),", ",(0,r.jsx)(n.code,{children:'maintainer: "John Doe"'})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"admission-controller",children:"Admission Controller"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Admission controllers are plugins that intercept requests to the Kubernetes API that create/delete or modify objects"}),"\n",(0,r.jsx)(n.li,{children:"Can validate or mutate requests"}),"\n",(0,r.jsx)(n.li,{children:"Change enabled/disabled plugins: /etc/kubernetes/manifests/kube-apiserver.yaml"}),"\n",(0,r.jsxs)(n.li,{children:["Common admission controllers:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"NamespaceLifecycle"}),": Validates namespace lifecycle"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"LimitRanger"}),": Enforces resource limits"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"ServiceAccount"}),": Automatically creates service accounts for pods"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"NodeRestriction"}),": Restricts nodes from modifying their own objects"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.li,{children:"Custom admission controllers can be implemented (either validating or mutating) through webhooks"}),"\n",(0,r.jsx)(n.li,{children:"Flow: Mutation first then validation"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"monitoring",children:"Monitoring"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Kubernetes doesn't have a built-in monitoring solution, instead there are various third-party solutions"}),"\n",(0,r.jsx)(n.li,{children:"Metrics Server is one possible solution"}),"\n",(0,r.jsx)(n.li,{children:"Each kubelet contains a component called cAdvisor which monitors performance of pods and exposes them"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"priority",children:"Priority"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Pods can have a priority assigned to them"}),"\n",(0,r.jsx)(n.li,{children:"Higher priority pods are scheduled before lower priority pods"}),"\n",(0,r.jsxs)(n.li,{children:["If a high priority pod cannot be scheduled due to resource constraints, lower priority pods may be evicted to make room","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"This process is called preemption"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Priorities are added via ",(0,r.jsx)(n.code,{children:"PriorityClass"})," objects","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Classes are assigned to pods via ",(0,r.jsx)(n.code,{children:"spec.priorityClassName"})]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["There are different preemption policies:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"PreemptLowerPriority"}),": Default, preempts lower priority pods"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Never"}),": Does not preempt any pods"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"priorityclass",children:"PriorityClass"}),"\n",(0,r.jsxs)(n.p,{children:["If you want to ensure that your apps running in Kubernetes stay running, even when the cluster is under heavy load, you can create a custom ",(0,r.jsx)(n.code,{children:"PriorityClass"})," for them to use."]}),"\n",(0,r.jsx)(n.p,{children:"Assigning them a higher priority ensures they get scheduled first, and lower-priority pods get evicted before them if the node is full."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"kubectl create priorityclass high-priority --value=1000000\n"})}),"\n",(0,r.jsxs)(n.p,{children:["If no priority class is set in the pod spec, the pod gets a priority value of ",(0,r.jsx)(n.code,{children:"0"})," by default. This means, it's the first to be evicted if the node is under memory or CPU pressure."]}),"\n",(0,r.jsx)(n.h3,{id:"high-priority-pods",children:"High priority Pods"}),"\n",(0,r.jsx)(n.p,{children:"You may have apps that must always stay running, such as:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Logging/monitoring agents"}),"\n",(0,r.jsx)(n.li,{children:"Control-plane components (in self-managed clusters)"}),"\n",(0,r.jsx)(n.li,{children:"Payment gateways"}),"\n",(0,r.jsx)(n.li,{children:"Message queues"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Assigning them higher priority ensures they get scheduled first, and they don't get evicted before the lower priority pods."}),"\n",(0,r.jsx)(n.h3,{id:"preemption",children:"Preemption"}),"\n",(0,r.jsx)(n.p,{children:"Preemption is the process of evicting pods with lower priority when the node(s) experiences CPU or memory stress."})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>t});var i=s(96540);const r={},o=i.createContext(r);function l(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);