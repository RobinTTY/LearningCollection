"use strict";(self.webpackChunklearning_knowledge_base=self.webpackChunklearning_knowledge_base||[]).push([[8242],{94656:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"kubernetes/core-components","title":"Core Components","description":"Pods","source":"@site/docs/kubernetes/core-components.md","sourceDirName":"kubernetes","slug":"/kubernetes/core-components","permalink":"/LearningCollection/kubernetes/core-components","draft":false,"unlisted":false,"editUrl":"https://github.com/RobinTTY/LearningCollection/tree/master/website/docs/kubernetes/core-components.md","tags":[],"version":"current","frontMatter":{"id":"core-components","title":"Core Components"},"sidebar":"docs","previous":{"title":"CKA Exam Questions","permalink":"/LearningCollection/kubernetes/cka-exam/questions"},"next":{"title":"Miscellaneous Concepts","permalink":"/LearningCollection/kubernetes/miscellaneous-concepts"}}');var t=s(74848),l=s(28453);const r={id:"core-components",title:"Core Components"},o=void 0,c={},a=[{value:"Pods",id:"pods",level:2},{value:"Replica Sets",id:"replica-sets",level:2},{value:"Deployments",id:"deployments",level:2},{value:"Services",id:"services",level:2},{value:"Daemon Sets",id:"daemon-sets",level:2},{value:"Static Pods",id:"static-pods",level:2},{value:"Custom Resources",id:"custom-resources",level:2}];function d(e){const n={code:"code",h2:"h2",li:"li",ul:"ul",...(0,l.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"pods",children:"Pods"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"One or multiple containers that contain the application code"}),"\n",(0,t.jsx)(n.li,{children:"Containers can communicate through localhost and share storage space"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"replica-sets",children:"Replica Sets"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Runs multiple instances of a pod (can also run a single one)"}),"\n",(0,t.jsx)(n.li,{children:"Ensures that there is always a stable set of replicated pods running"}),"\n",(0,t.jsx)(n.li,{children:"Replication Controller is the older way of doing this"}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"matchlabels"})," identifies potential pods to acquire"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"deployments",children:"Deployments"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Higher level than replica set"}),"\n",(0,t.jsx)(n.li,{children:"Manages a set of pods"}),"\n",(0,t.jsx)(n.li,{children:"Provides declarative updates for pods and replica sets"}),"\n",(0,t.jsx)(n.li,{children:"In the deployment we describe the desired state"}),"\n",(0,t.jsx)(n.li,{children:"Deployment controller changes the state"}),"\n",(0,t.jsx)(n.li,{children:"Can be used for rollbacks"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"services",children:"Services"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Enable communication between services"}),"\n",(0,t.jsxs)(n.li,{children:["There are different types of services","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["ClusterIP","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"internal IP inside cluster"}),"\n",(0,t.jsx)(n.li,{children:"can be exposed via ingress/gateway"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["NodePort","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Exposes service on each node in the cluster at a static port"}),"\n",(0,t.jsx)(n.li,{children:"to make the node port available Kubernetes sets up a ClusterIP"}),"\n",(0,t.jsx)(n.li,{children:"Spec: Pod -> TargetPort, Service -> Port, Node -> NodePort (30000-32767)"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["LoadBalancer","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Exposes service externally through load balancer"}),"\n",(0,t.jsx)(n.li,{children:"Used with Cloud Providers"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["External Name","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Mapping to hostname via cluster DNS"}),"\n",(0,t.jsx)(n.li,{children:"e.g. api.foo.bar.example"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"daemon-sets",children:"Daemon Sets"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Ensures that all (or some) nodes run a copy of a pod"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"static-pods",children:"Static Pods"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Managed directly by the kubelet without api-server observing them"}),"\n",(0,t.jsx)(n.li,{children:"There is a mirror pod on the api-server so it knows about it but no control"}),"\n",(0,t.jsx)(n.li,{children:"Use-case: primarily running control plane pods"}),"\n",(0,t.jsx)(n.li,{children:"Pod definition is read from specific directory -> kubelet monitors this directory"}),"\n",(0,t.jsxs)(n.li,{children:["kubelet.service -> --config: kubeconfig.yaml, kubeconfig.yaml -> staticPodPath: ",(0,t.jsx)(n.code,{children:"/etc/kubernetes/manifests"})]}),"\n",(0,t.jsx)(n.li,{children:"Static pods have the node name they are deployed to suffixed to their podname"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"custom-resources",children:"Custom Resources"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Extension of the Kubernetes API"}),"\n",(0,t.jsx)(n.li,{children:"Example: Certificate from cert-manager"}),"\n",(0,t.jsx)(n.li,{children:"Custom controllers can act upon the created custom resources"}),"\n",(0,t.jsx)(n.li,{children:"Custom resources are defined through a CustomResourceDefinition"}),"\n",(0,t.jsx)(n.li,{children:"Operators: One or multiple controllers that act upon a custom resource (or multiple)"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>o});var i=s(96540);const t={},l=i.createContext(t);function r(e){const n=i.useContext(l);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);