"use strict";(self.webpackChunklearning_knowledge_base=self.webpackChunklearning_knowledge_base||[]).push([[3818],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=p(n),u=r,m=d["".concat(s,".").concat(u)]||d[u]||h[u]||o;return n?a.createElement(m,i(i({ref:t},c),{},{components:n})):a.createElement(m,i({ref:t},c))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:r,i[1]=l;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},5967:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const o={id:"core-concepts",title:"Core Concepts",sidebar_position:2},i=void 0,l={unversionedId:"apis/graphql/core-concepts",id:"apis/graphql/core-concepts",title:"Core Concepts",description:"GraphQL has a few core concepts that are important to understanding how it works. These core concepts are explained here.",source:"@site/docs/apis/graphql/core-concepts.md",sourceDirName:"apis/graphql",slug:"/apis/graphql/core-concepts",permalink:"/LearningCollection/apis/graphql/core-concepts",draft:!1,editUrl:"https://github.com/RobinTTY/LearningCollection/tree/master/website/docs/apis/graphql/core-concepts.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{id:"core-concepts",title:"Core Concepts",sidebar_position:2},sidebar:"finance",previous:{title:"Introduction",permalink:"/LearningCollection/apis/graphql/intro"},next:{title:"Record Types",permalink:"/LearningCollection/C-Sharp/Core Concepts/Types/recordTypes"}},s={},p=[{value:"The Schema Definition Language (SDL)",id:"the-schema-definition-language-sdl",level:2},{value:"Fetching Data with Queries",id:"fetching-data-with-queries",level:2},{value:"Basic Queries",id:"basic-queries",level:3}],c={toc:p},d="wrapper";function h(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"GraphQL has a few core concepts that are important to understanding how it works. These core concepts are explained here."),(0,r.kt)("h2",{id:"the-schema-definition-language-sdl"},"The Schema Definition Language (SDL)"),(0,r.kt)("p",null,"GraphQL has its own type system that\u2019s used to define the schema of an API. The syntax for writing schemas is called Schema Definition Language (SDL). Here is an example of how we can use the SDL to define a simple type called ",(0,r.kt)("inlineCode",{parentName:"p"},"Person"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"type Person {\n  name: String!\n  age: Int!\n}\n")),(0,r.kt)("p",null,"This type has two fields, they\u2019re called ",(0,r.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"age")," and are respectively of type ",(0,r.kt)("inlineCode",{parentName:"p"},"String")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Int"),". The ",(0,r.kt)("inlineCode",{parentName:"p"},"!")," following the type means that this field is required. It\u2019s also possible to express relationships between types. In the example of a blogging application, a ",(0,r.kt)("inlineCode",{parentName:"p"},"Person")," could be associated with a ",(0,r.kt)("inlineCode",{parentName:"p"},"Post"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"type Post {\n  title: String!\n  author: Person!\n}\n")),(0,r.kt)("p",null,"Conversely, the other end of the relationship needs to be placed on the ",(0,r.kt)("inlineCode",{parentName:"p"},"Person")," type:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"type Person {\n  name: String!\n  age: Int!\n  posts: [Post!]!\n}\n")),(0,r.kt)("p",null,"This is a one-to-many-relationship between ",(0,r.kt)("inlineCode",{parentName:"p"},"Person")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Post")," since the ",(0,r.kt)("inlineCode",{parentName:"p"},"posts")," field on ",(0,r.kt)("inlineCode",{parentName:"p"},"Person")," is actually an array of posts."),(0,r.kt)("h2",{id:"fetching-data-with-queries"},"Fetching Data with Queries"),(0,r.kt)("p",null,"When working with REST APIs, data is loaded from specific endpoints. Each endpoint has a clearly defined structure of the information that it returns. This means that the data requirements of a client are effectively encoded in the URL that it connects to."),(0,r.kt)("p",null,"The approach that\u2019s taken in GraphQL is radically different. Instead of having multiple endpoints that return fixed data structures, GraphQL APIs typically only expose a single endpoint. This works because the structure of the data that\u2019s returned is not fixed. Instead, it\u2019s completely flexible and lets the client decide what data is actually needed."),(0,r.kt)("p",null,"That means that the client needs to send more information to the server to express its data needs - this information is called a query."),(0,r.kt)("h3",{id:"basic-queries"},"Basic Queries"),(0,r.kt)("p",null,"Let\u2019s take a look at an example query that a client could send to a server:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"{\n  allPersons {\n    name\n  }\n}\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"allPersons")," field in this query is called the root field of the query. Everything that follows the root field, is called the payload of the query. The only field that\u2019s specified in this query\u2019s payload is ",(0,r.kt)("inlineCode",{parentName:"p"},"name"),"."),(0,r.kt)("p",null,"This query would return a list of all persons currently stored in the database. Here\u2019s an example response:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "allPersons": [\n    { "name": "Johnny" },\n    { "name": "Sarah" },\n    { "name": "Alice" }\n  ]\n}\n')),(0,r.kt)("p",null,"Notice that each person only has the ",(0,r.kt)("inlineCode",{parentName:"p"},"name")," in the response, but the ",(0,r.kt)("inlineCode",{parentName:"p"},"age")," is not returned by the server. That\u2019s exactly because ",(0,r.kt)("inlineCode",{parentName:"p"},"name")," was the only field that was specified in the query."),(0,r.kt)("p",null,"If the client also needed the persons\u2019 ",(0,r.kt)("inlineCode",{parentName:"p"},"age"),", all it has to do is slightly adjust the query and include the new field in the query\u2019s payload:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"{\n  allPersons {\n    name\n    age\n  }\n}\n")),(0,r.kt)("p",null,"One of the major advantages of GraphQL is that it allows for naturally querying nested information. For example, if you wanted to load all the ",(0,r.kt)("inlineCode",{parentName:"p"},"posts")," that a ",(0,r.kt)("inlineCode",{parentName:"p"},"Person")," has written, you could simply follow the structure of your types to request this information:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"{\n  allPersons {\n    name\n    age\n    posts {\n      title\n    }\n  }\n}\n")))}h.isMDXComponent=!0}}]);