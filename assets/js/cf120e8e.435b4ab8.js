"use strict";(self.webpackChunklearning_knowledge_base=self.webpackChunklearning_knowledge_base||[]).push([[6237],{2379:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>r});var o=a(4848),t=a(8453);const s={id:"useCallback",title:"useCallback",sidebar_position:2},c=void 0,i={id:"web/react/hooks/advanced-hooks/useCallback",title:"useCallback",description:"The useCallback hook basically allows us to store a function across component executions. This allows us to avoid the re-creation of the function every time a component is re-executed. The return value of useCallback is a memoized callback (with it we can reuse the same function across executions).",source:"@site/docs/web/react/hooks/advanced-hooks/useCallback.md",sourceDirName:"web/react/hooks/advanced-hooks",slug:"/web/react/hooks/advanced-hooks/useCallback",permalink:"/LearningCollection/web/react/hooks/advanced-hooks/useCallback",draft:!1,unlisted:!1,editUrl:"https://github.com/RobinTTY/LearningCollection/tree/master/website/docs/web/react/hooks/advanced-hooks/useCallback.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{id:"useCallback",title:"useCallback",sidebar_position:2},sidebar:"docs",previous:{title:"useImperativeHandle",permalink:"/LearningCollection/web/react/hooks/advanced-hooks/useImperativeHandle"},next:{title:"useMemo",permalink:"/LearningCollection/web/react/hooks/advanced-hooks/useMemo"}},l={},r=[{value:"Syntax",id:"syntax",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"useCallback"})," hook basically allows us to store a function across component executions. This allows us to avoid the re-creation of the function every time a component is re-executed. The return value of ",(0,o.jsx)(n.code,{children:"useCallback"})," is a ",(0,o.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Memoization",children:"memoized"})," callback (with it we can reuse the same function across executions)."]}),"\n",(0,o.jsx)(n.h2,{id:"syntax",children:"Syntax"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:"// we wrap the function we want to memoize inside useCallback\nconst memoizedCallback = useCallback(() => {\n  doSomething(a, b);\n}, [a, b]);\n"})}),"\n",(0,o.jsxs)(n.p,{children:["A new function instance will only be generated if any value of the variables inside the dependency array changes between re-renders. If nothing changes, ",(0,o.jsx)(n.code,{children:"useCallback"})," will just return the cached version of the function instance."]}),"\n",(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsx)(n.p,{children:"The array of dependencies is not passed as arguments to the callback. Conceptually, though, that\u2019s what they represent: every value referenced inside the callback should also appear in the dependencies array. In the future, a sufficiently advanced compiler could create this array automatically."})})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>c,x:()=>i});var o=a(6540);const t={},s=o.createContext(t);function c(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);