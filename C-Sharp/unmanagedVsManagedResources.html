<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.4">
<title data-react-helmet="true">Unmanaged vs managed resources | Learning Collection Knowledge Base</title><meta data-react-helmet="true" property="og:url" content="https://RobinTTY.github.io/LearningCollection/C-Sharp/unmanagedVsManagedResources"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Unmanaged vs managed resources | Learning Collection Knowledge Base"><meta data-react-helmet="true" name="description" content="- Managed resources basically means &quot;managed memory&quot; that is managed by the garbage collector."><meta data-react-helmet="true" property="og:description" content="- Managed resources basically means &quot;managed memory&quot; that is managed by the garbage collector."><link data-react-helmet="true" rel="shortcut icon" href="/LearningCollection/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://RobinTTY.github.io/LearningCollection/C-Sharp/unmanagedVsManagedResources"><link data-react-helmet="true" rel="alternate" href="https://RobinTTY.github.io/LearningCollection/C-Sharp/unmanagedVsManagedResources" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://RobinTTY.github.io/LearningCollection/C-Sharp/unmanagedVsManagedResources" hreflang="x-default"><link rel="stylesheet" href="/LearningCollection/assets/css/styles.bd168e87.css">
<link rel="preload" href="/LearningCollection/assets/js/runtime~main.7d13e80f.js" as="script">
<link rel="preload" href="/LearningCollection/assets/js/main.f5886633.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/LearningCollection/"><img src="/LearningCollection/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/LearningCollection/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">Learning Collection</b></a><a class="navbar__item navbar__link navbar__link--active" href="/LearningCollection/">Docs</a></div><div class="navbar__items navbar__items--right"><div class="react-toggle toggle_3Zt9 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">ðŸŒœ</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">ðŸŒž</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><button class="clean-btn backToTopButton_35hR" type="button" title="Scroll to top"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">C-Sharp</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/LearningCollection/C-Sharp/aspnet">ASP.NET</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/LearningCollection/C-Sharp/assemblyClass">Assembly Class</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/LearningCollection/C-Sharp/asyncProgramming">Asynchronous Programming</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/LearningCollection/C-Sharp/closures">Closures</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/LearningCollection/C-Sharp/netFramework">.NET Framework</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/LearningCollection/C-Sharp/generics">Generics</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/LearningCollection/C-Sharp/ienumerable">IEnumerable</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/LearningCollection/C-Sharp/manResetEvent">ManualResetEvent</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/LearningCollection/C-Sharp/memVsFileStream">Memory Stream vs FileStream</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/LearningCollection/C-Sharp/netstandardVsNetcoreVsUwp">.Net Core vs .Net Standard vs UWP</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/LearningCollection/C-Sharp/propsVsPublicVars">Properties vs Public variables</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/LearningCollection/C-Sharp/serialization">Serialization</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/LearningCollection/C-Sharp/taskFactoryStartNew">Task.Factory.StartNew()</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/LearningCollection/C-Sharp/threadVsTask">Thread vs Task</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/LearningCollection/C-Sharp/nullCoalescingOperator">Null-coalescing operator</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/LearningCollection/C-Sharp/nullConditionalOperator">Null-conditional operator</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/LearningCollection/C-Sharp/privateProtectedVsProtectedInternal">Private protected vs protected internal access modifier</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/LearningCollection/C-Sharp/unmanagedConstraint">Unmanaged constraint</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/LearningCollection/C-Sharp/unmanagedVsManagedResources">Unmanaged vs managed resources</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/LearningCollection/C-Sharp/volatileKeyword">Volatile Keyword</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Databases</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Tools</a></li><li class="menu__list-item"><a class="menu__link" href="/LearningCollection/">docs-home</a></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="tocCollapsible_1PrD tocMobile_3Hoh"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">On this page</button></div><div class="markdown"><header><h1 class="h1Heading_27L5">Unmanaged vs managed resources</h1></header><ul><li><strong>Managed resources basically means &quot;managed memory&quot; that is managed by the garbage collector.</strong></li><li>When you no longer have any references to a managed object (which uses managed memory), the garbage collector will (eventually) release that memory for you.</li></ul><p>Unmanaged resources are then everything that the garbage collector does not know about. For example:</p><ul><li>Open files</li><li>Open network connections</li><li>Open Gpio Ports</li><li>Unmanaged memory</li></ul><p>Normally you want to release those unmanaged resources before you lose all the references you have to the object managing them.
You do this by calling Dispose on that object, or (in C#) using the using statement which will handle calling Dispose for you.</p><p>If you neglect to Dispose of your unmanaged resources correctly, the garbage collector will eventually handle it for you when the object containing that resource is garbage collected (this is &quot;finalization&quot;).
But because the garbage collector doesn&#x27;t know about the unmanaged resources, it can&#x27;t tell how badly it needs to release them - so it&#x27;s possible for your program to perform poorly or run out of resources entirely.</p><p>If you implement a class yourself that handles unmanaged resources, it is up to you to implement Dispose and Finalize correctly.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="idisposable"></a>IDisposable<a class="hash-link" href="#idisposable" title="Direct link to heading">#</a></h2><p>The point of Dispose is to free unmanaged resources. It needs to be done at some point, otherwise they will never be cleaned up. The garbage collector doesn&#x27;t know how to call DeleteHandle() on a variable of type IntPtr, it doesn&#x27;t know whether or not it needs to call DeleteHandle().</p><p><strong>Note:</strong> What is an unmanaged resource? If you found it in the Microsoft .NET Framework: it&#x27;s managed. If you went poking around MSDN yourself, it&#x27;s unmanaged. Anything you&#x27;ve used P/Invoke calls to get outside of the nice comfy world of everything available to you in the .NET Framework is unmanaged â€“ and you&#x27;re now responsible for cleaning it up.</p><p>The object that you&#x27;ve created needs to expose some method, that the outside world can call, in order to clean up unmanaged resources. There is a standardized name for this method:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly C#"><pre tabindex="0" class="prism-code language-C# codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public void Dispose()</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>The IDisposable interface has just this one method that needs to be implemented.</p><p>So you make your object expose the IDisposable interface, and that way you promise that you&#x27;ve written that single method to clean up your unmanaged resources:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly C#"><pre tabindex="0" class="prism-code language-C# codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public void Dispose()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   Win32.DestroyHandle(this.CursorFileBitmapIconServiceHandle);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><strong>But we can do more:</strong></p><p>What if your object has allocated a 250MB System.Drawing.Bitmap (i.e. the .NET managed Bitmap class) as some sort of frame buffer? Sure, this is a managed .NET object, and the garbage collector will free it. But do you really want to leave 250MB of memory just sitting there â€“ waiting for the garbage collector to eventually come along and free it?</p><p>If the user has called <code>Dispose()</code> (meaning they no longer plan to use the object) why not get rid of those wasteful bitmaps and database connections?</p><p>So now we will:</p><ul><li>get rid of unmanaged resources (because we have to), and</li><li>get rid of managed resources (because we want to be helpful)</li></ul><p>So let&#x27;s update our <code>Dispose()</code> method to get rid of those managed objects:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly C#"><pre tabindex="0" class="prism-code language-C# codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public void Dispose()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   //Free unmanaged resources</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   Win32.DestroyHandle(this.CursorFileBitmapIconServiceHandle);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   //Free managed resources too</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   if (this.databaseConnection != null)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      this.databaseConnection.Dispose();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      this.databaseConnection = null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   if (this.frameBufferImage != null)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      this.frameBufferImage.Dispose();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      this.frameBufferImage = null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><strong>We can still do more:</strong></p><p>What if the person forgot to call <code>Dispose()</code> on your object? Then they would leak some unmanaged resources!</p><p><strong>Note:</strong> They won&#x27;t leak managed resources, because eventually the garbage collector is going to run, on a background thread, and free the memory associated with any unused objects. This will include your object, and any managed objects you use (e.g. the Bitmap and the DbConnection).</p><p>If the person forgot to call <code>Dispose()</code>, we can still save their bacon! We still have a way to call it for them: when the garbage collector finally gets around to freeing (i.e. finalizing) our object.</p><p>The garbage collector will eventually free all managed objects. When it does, it calls the <code>Finalize</code> method on the object. <strong>The GC doesn&#x27;t know, or care, about your <code>Dispose</code> method. That was just a name we chose for a method we call when we want to get rid of unmanaged stuff.</strong></p><p>The destruction of our object by the Garbage collector is the perfect time to free those unmanaged resources. We do this by overriding the <code>Finalize()</code> method.</p><p><strong>Note:</strong> In C#, you don&#x27;t explicitly override the Finalize() method. You write a method that looks like a C++ destructor, and the compiler takes that to be your implementation of the Finalize() method:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly C#"><pre tabindex="0" class="prism-code language-C# codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">~MyObject()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   //we&#x27;re being finalized (i.e. destroyed), call Dispose in case the user forgot to</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   Dispose(); //&lt;--Warning: subtle bug! Keep reading!</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><strong>But there&#x27;s a bug in that code.</strong> You see, the garbage collector runs on a background thread; you don&#x27;t know the order in which two objects are destroyed. It is entirely possible that in your Dispose() code, the managed object you&#x27;re trying to get rid of (because you wanted to be helpful) is no longer there:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly C#"><pre tabindex="0" class="prism-code language-C# codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public void Dispose()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   //Free unmanaged resources</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   Win32.DestroyHandle(this.gdiCursorBitmapStreamFileHandle);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   //Free managed resources too</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   if (this.databaseConnection != null)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      this.databaseConnection.Dispose(); //&lt;-- crash, GC already destroyed it</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      this.databaseConnection = null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   if (this.frameBufferImage != null)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      this.frameBufferImage.Dispose(); //&lt;-- crash, GC already destroyed it</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      this.frameBufferImage = null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>So what you need is a way for <code>Finalize()</code> to tell <code>Dispose()</code> that it should not touch any managed resources (because they might not be there anymore), while still freeing unmanaged resources.</p><p>The standard pattern to do this is to have <code>Finalize()</code> and <code>Dispose()</code> both call a third(!) method; where you pass a Boolean saying if you&#x27;re calling it from <code>Dispose()</code> (as opposed to <code>Finalize()</code>), meaning it&#x27;s safe to free managed resources.</p><p>This internal method could be given some arbitrary name like &quot;CoreDispose&quot;, or &quot;MyInternalDispose&quot;, but is tradition to call it Dispose(Boolean):</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly C#"><pre tabindex="0" class="prism-code language-C# codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">protected void Dispose(Boolean disposing)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>But a more helpful parameter name might be:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly C#"><pre tabindex="0" class="prism-code language-C# codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">protected void Dispose(Boolean itIsSafeToAlsoFreeManagedObjects)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   //Free unmanaged resources</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   Win32.DestroyHandle(this.CursorFileBitmapIconServiceHandle);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   //Free managed resources too, but only if I&#x27;m being called from Dispose</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   //(If I&#x27;m being called from Finalize then the objects might not exist</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   //anymore</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   if (itIsSafeToAlsoFreeManagedObjects)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (this.databaseConnection != null)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         this.databaseConnection.Dispose();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         this.databaseConnection = null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (this.frameBufferImage != null)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         this.frameBufferImage.Dispose();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         this.frameBufferImage = null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>And you change your implementation of the <code>IDisposable.Dispose()</code> method to:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly C#"><pre tabindex="0" class="prism-code language-C# codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public void Dispose()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   Dispose(true); //I am calling you from Dispose, it&#x27;s safe</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>and your finalizer to:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly C#"><pre tabindex="0" class="prism-code language-C# codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">~MyObject()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   Dispose(false); //I am *not* calling you from Dispose, it&#x27;s *not* safe</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><strong>Note:</strong> If your object descends from an object that implements Dispose, then don&#x27;t forget to call their base Dispose method when you override Dispose:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly C#"><pre tabindex="0" class="prism-code language-C# codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">    public override void Dispose()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        try</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            Dispose(true); //true: safe to free managed resources</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        finally</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            base.Dispose();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><strong>We can do even more:</strong></p><p>If the user calls <code>Dispose()</code> on your object, then everything has been cleaned up. Later on, when the garbage collector comes along and calls Finalize, it will then call Dispose again.</p><p>Not only is this wasteful, but if your object has junk references to objects you already disposed of from the last call to <code>Dispose()</code>, you&#x27;ll try to dispose them again!</p><p>You&#x27;ll notice in my code I was careful to remove references to objects that I&#x27;ve disposed, so I don&#x27;t try to call Dispose on a junk object reference. But that didn&#x27;t stop a subtle bug from creeping in.</p><p>When the user calls <code>Dispose()</code>: the handle <strong>CursorFileBitmapIconServiceHandle</strong> is destroyed. Later when the garbage collector runs, it will try to destroy the same handle again.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly C#"><pre tabindex="0" class="prism-code language-C# codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">protected void Dispose(Boolean iAmBeingCalledFromDisposeAndNotFinalize)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   //Free unmanaged resources</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   Win32.DestroyHandle(this.CursorFileBitmapIconServiceHandle); //&lt;--double destroy</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   ...</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>The way you fix this is tell the garbage collector that it doesn&#x27;t need to bother finalizing the object â€“ its resources have already been cleaned up, and no more work is needed. You do this by calling <code>GC.SuppressFinalize()</code> in the <code>Dispose()</code> method:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly C#"><pre tabindex="0" class="prism-code language-C# codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">public void Dispose()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   Dispose(true); //I am calling you from Dispose, it&#x27;s safe</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   GC.SuppressFinalize(this); //Hey, GC: don&#x27;t bother calling finalize later</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>Now that the user has called <code>Dispose()</code>, we have:</p><ul><li>freed unmanaged resources</li><li>freed managed resources</li></ul><p>There&#x27;s no point in the GC running the finalizer â€“ everything&#x27;s taken care of.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="couldnt-i-use-finalize-to-cleanup-unmanaged-resources"></a>Couldn&#x27;t I use Finalize to cleanup unmanaged resources<a class="hash-link" href="#couldnt-i-use-finalize-to-cleanup-unmanaged-resources" title="Direct link to heading">#</a></h2><p>The documentation for Object.Finalize says:</p><blockquote><p>The Finalize method is used to perform cleanup operations on unmanaged resources held by the current object before the object is destroyed.</p></blockquote><p>But the MSDN documentation also says, for <code>IDisposable.Dispose</code>:</p><blockquote><p>Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.</p></blockquote><p>So which is it? Which one is the place for me to cleanup unmanaged resources? The answer is:</p><p>It&#x27;s your choice! But choose Dispose.</p><p>You certainly could place your unmanaged cleanup in the finalizer:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly C#"><pre tabindex="0" class="prism-code language-C# codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">~MyObject()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   //Free unmanaged resources</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   Win32.DestroyHandle(this.CursorFileBitmapIconServiceHandle);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   //A C# destructor automatically calls the destructor of its base class.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>The problem with that is you have no idea when the garbage collector will get around to finalizing your object. Your un-managed, un-needed, un-used native resources will stick around until the garbage collector eventually runs. Then it will call your finalizer method; cleaning up unmanaged resources. The documentation of Object.Finalize points this out:</p><p>The exact time when the finalizer executes is undefined. To ensure deterministic release of resources for instances of your class, implement a Close method or provide a IDisposable.Dispose implementation.</p><p>This is the virtue of using Dispose to cleanup unmanaged resources; you get to know, and control, when unmanaged resource are cleaned up. Their destruction is &quot;deterministic&quot;.</p></div><footer class="row docusaurus-mt-lg"><div class="col"><a href="https://github.com/RobinTTY/LearningCollection/tree/master/website/docs/C-Sharp/unmanaged vs managed resources.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_3DPF"></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/LearningCollection/C-Sharp/unmanagedConstraint"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Â« Unmanaged constraint</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/LearningCollection/C-Sharp/volatileKeyword"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Volatile Keyword Â»</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#idisposable" class="table-of-contents__link">IDisposable</a></li><li><a href="#couldnt-i-use-finalize-to-cleanup-unmanaged-resources" class="table-of-contents__link">Couldn&#39;t I use Finalize to cleanup unmanaged resources</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">My other sites</div><ul class="footer__items"><li class="footer__item"><a href="https://robintty.github.io/" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Website<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">Socials</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/RobinTTY" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://www.linkedin.com/in/robin-m%C3%BCller-574782170/" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>LinkedIn<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright Â© 2021 Robin MÃ¼ller. Built with Docusaurus.</div></div></div></footer></div>
<script src="/LearningCollection/assets/js/runtime~main.7d13e80f.js"></script>
<script src="/LearningCollection/assets/js/main.f5886633.js"></script>
</body>
</html>