/*	File lcg_actions.hpp

Authors: J. Koch, M. Dausmann

The class LCGActions implements the actions
that can be performed on a selected LCG.
It allows to select among the actions
and executes the selected one.

Reference: Chapter Random Numbers

*/

#include <iostream>
#include <iomanip>
#include <cmath>
#include <limits>
#include "lcg_actions.hpp"
using namespace std;

#define M_PI       3.14159265358979323846

void LCGActions::chooseAction(LCGenerator & lcg) {
	cout << "What shall be done with the linear congruential generator?" << endl;
	cout << "1: output the generated numbers" << endl;
	cout << "2: list the generated numbers" << endl;
	cout << "3: simulate the rolling of a dice" << endl;
	cout << "4: transform numbers into standard random numbers in [0,1)" << endl;
	cout << "5: transform numbers into a normal distribution" << endl;
	int what;
	cin >> what;
	if (!cin) {
		what = 1; cin.clear();
		cin.ignore(numeric_limits<streamsize>::max(), '\n');
	}
	int max = 1;
	switch (what) {
	case 1: outputRandomNumbers(lcg); break;
	case 2: max = readNumberOfTrials();
		listRandomSequence(lcg, max); break;
	case 3: simulateDice(lcg); break;
	case 4: max = readNumberOfTrials();
		transformToStandardNumbers(lcg, max); break;
	case 5: max = readNumberOfTrials();
		transformToNormalDist(lcg, max); break;
	default: outputRandomNumbers(lcg);
	}
}

void LCGActions::outputRandomNumbers(LCGenerator & lcg)
{
	cout << endl << "Output of the random numbers generated by the" << endl;
	cout << "linear congruential generator " << lcg.toString() << endl;

	for (int i = 1; i <= 30; i++)
	{
		cout << lcg.nextRandomNumber();
		if (i % 10 == 0) cout << endl;
		else cout << ", ";
	}
	cout << endl << endl;
}

void LCGActions::listRandomSequence(LCGenerator & lcg, int N)
{
	int nxr;
	cout << endl << "List of " << N << " random numbers using the ";
	cout << "linear congruential generator " << lcg.toString() << endl;
	for (int i = 0; i < N; i++)
	{
		nxr = lcg.nextRandomNumber();
		cout << "x[" << i << "]=" << nxr << endl;
	}
	cout << endl << endl;
}

// Simulate rolling a dice by generating random numbers
// in the intervall [1,6]
//<-lcg_dice--
int LCGActions::rollDice(LCGenerator& lcg)
{
	int nxr = lcg.nextRandomNumber();
	// transform the random number into [0,1)
	double norm = (double)nxr / (lcg.getModulus());
	// and now extend the normalized number into [1,6]
	int score = (int)(floor((norm * (6 - 1 + 1))) + 1);
	return score;
}
//--lcg_dice->

void LCGActions::simulateDice(LCGenerator& lcg)
{
	cout << endl << "Simulating the rolling of a dice using the" << endl;
	cout << "linear congruential generator " << lcg.toString() << endl;

	for (int i = 0; i < 36; i++)
	{
		int score = rollDice(lcg);
		// output in 6 columns 
		if (i % 6 == 0) cout << endl;
		cout << score << ", ";
	}
	cout << endl << endl;
}

void LCGActions::transformToStandardNumbers(LCGenerator & lcg, int N) {
	double rn;
	cout << endl << "List of " << N << " standard random numbers using the ";
	cout << "linear congruential generator " << lcg.toString() << endl;
	for (int i = 0; i < N; i++) {
		rn = ((double)lcg.nextRandomNumber()) / (lcg.getModulus());
		cout << "x[" << i << "]=" << rn << endl;
	}
	cout << endl << endl;
}

//<-lcg_boxmuller--
void LCGActions::applyBoxMuller(vector<double>& uniform_dist, 
	vector<double>& normal_dist, int N) {
	double sqrt_val, trig_val;
	for (int i = 1; i <= N - 1; i = i + 2) {
		// two numbers uniformly distributed in [0,1)
		double u1 = uniform_dist[i - 1];
		double u2 = uniform_dist[i];
		// Box-Muller-Method
		sqrt_val = sqrt(-2 * log(u2));
		trig_val = 2 * M_PI * u1;
		double x1 = cos(trig_val) * sqrt_val;
		double x2 = sin(trig_val) * sqrt_val;
		// store these normal distributed numbers
		normal_dist[i - 1] = x1;
		normal_dist[i] = x2;
	}
}
//--lcg_boxmuller->

void LCGActions::transformToNormalDist(LCGenerator & lcg, int N) {
  if( N % 2 ){
    cout << "\nFor Box-Muller transformation an even number of trials is required!\n"
         << "Increasing number of trials from " << N << " to " << N+1 << "\n\n"; 
    ++N;
  }
	vector<double> uniform_dist(N);
	for (int i = 0; i < N; i++) {
		// random numbers transformed into [0,1)
		uniform_dist[i] = ((double)lcg.nextRandomNumber()) / (lcg.getModulus());
	}
	vector<double> normal_dist(N);
	applyBoxMuller(uniform_dist, normal_dist, N);
	//Output of both distributions
	cout << "Uniform      Normal" << endl;
	for (int i = 0; i <= N - 1; i++)
	{
		cout << setw(7) << setfill(' ') << setprecision(5) << fixed;
		cout << left << noshowpos << uniform_dist[i] << "   ";
		cout << setw(7) << setfill(' ') << setprecision(5) << fixed;
		cout << right << showpos << normal_dist[i] << endl; // "," <<
	}
}

int LCGActions::readNumberOfTrials() {
	cout << "How many numbers shall be generated with the LCG?" << endl;
	cout << "Number of trials: ";
	int trials;
	cin >> trials;
	if (!cin) {
		trials = 10; cin.clear();
		cin.ignore(numeric_limits<streamsize>::max(), '\n');
	}
	return trials;
}

